
#Область СлужебныйПрограммныйИнтерфейс

// Удаляет указанные ключи структуры.
//
// Параметры:
//   Структура - Структура
//   Ключи - Строка
//
Процедура УдалитьКлючиСтруктуры(Структура, Ключи) Экспорт
	Если ТипЗнч(Ключи) = Тип("Структура") Или ТипЗнч(Ключи) = Тип("ФиксированнаяСтруктура") Тогда
		УдаляемаяСтруктура = Ключи;
	Иначе
		УдаляемаяСтруктура = Новый Структура(Ключи);
	КонецЕсли;
	Для Каждого КлючИЗначение Из УдаляемаяСтруктура Цикл
		Структура.Удалить(КлючИЗначение.Ключ);
	КонецЦикла;
КонецПроцедуры

Функция НовыйОписаниеТаблицыИнтервалов() Экспорт
	Описание = Новый Структура();
	Описание.Вставить("Таблица");
	Описание.Вставить("ИмяПоляДатаНачала", "ДатаНачала");
	Описание.Вставить("ИмяПоляДатаОкончания", "ДатаОкончания");
	Описание.Вставить("Отсортирована", Ложь);
	
	Возврат Описание;
КонецФункции	

// Удаляет из исходной таблицы те интервалы, которые пересекаются с интервалами из втрой таблицы.
// Для корректной работы метода в таблицах не должно быть пересекающихся (в разрезе полей ключа) интервалов
// 
// Параметры:
//  ОписаниеТаблицыИсходныхИнтервалов - см. НовыйОписаниеТаблицыИнтервалов 
//  ОписаниеТаблицыУдаляемыхИнтервалов - см. НовыйОписаниеТаблицыИнтервалов
//  ПоляКлюча - Строка - поля в разрезе котрых будут анализироваться интервалы. Должны совпадать в обеих таблицах
// 
Процедура УдалитьИнтервалы(ОписаниеТаблицыИсходныхИнтервалов, ОписаниеТаблицыУдаляемыхИнтервалов, ПоляКлюча) Экспорт
	Если ОписаниеТаблицыИсходныхИнтервалов.Таблица.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;	
	
	ОбходТаблицыУдаляемыхПериодов = КоллекцииБЗК.ОбходТаблицы(
		ОписаниеТаблицыУдаляемыхИнтервалов.Таблица, 
		ПоляКлюча, 
		ОписаниеТаблицыУдаляемыхИнтервалов.ИмяПоляДатаНачала, 
		ОписаниеТаблицыУдаляемыхИнтервалов.ИмяПоляДатаОкончания, 
		ОписаниеТаблицыУдаляемыхИнтервалов.Отсортирована);
	
	Если Не ОписаниеТаблицыИсходныхИнтервалов.Отсортирована Тогда
		ПоляСортировки = ПоляКлюча + ", " + ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаНачала + ", " + ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаОкончания;
		ОписаниеТаблицыИсходныхИнтервалов.Таблица.Сортировать(ПоляСортировки, Новый СравнениеЗначений());
	КонецЕсли;
	 
	ИндексТекущейСтроки = 0;
	ИндексПоследнейСтроки = ОписаниеТаблицыИсходныхИнтервалов.Таблица.Количество() - 1;
	
	СтрокиИсходныхИнтервалов = ОписаниеТаблицыИсходныхИнтервалов.Таблица;
	УдаляемыйПериод = Неопределено;
	Пока ИндексТекущейСтроки <= ИндексПоследнейСтроки Цикл
		ТекущаяСтрока = СтрокиИсходныхИнтервалов[ИндексТекущейСтроки];
		
		УдаляемыйПериод = СледующаяАктуальнаяСтрока(ТекущаяСтрока, ОбходТаблицыУдаляемыхПериодов, УдаляемыйПериод);
		
		Если УдаляемыйПериод = Неопределено Тогда
			ИндексТекущейСтроки = ИндексТекущейСтроки + 1;
			Продолжить;
		КонецЕсли;	
		
		ДатаНачалаТекущегоИнтервала = НачалоДня(ТекущаяСтрока[ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаНачала]);
		ДатаОкончанияТекущегоИнтервала = КонецДня(ТекущаяСтрока[ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаОкончания]);
		ДатаНачалаУдаляемогоИнтервала = НачалоДня(ТекущаяСтрока[ОписаниеТаблицыУдаляемыхИнтервалов.ИмяПоляДатаНачала]);
		ДатаОкончанияУдаляемогоИнтервала = КонецДня(ТекущаяСтрока[ОписаниеТаблицыУдаляемыхИнтервалов.ИмяПоляДатаОкончания]);
		
		
		Если ДатаНачалаУдаляемогоИнтервала <= ДатаНачалаТекущегоИнтервала
			И ДатаОкончанияУдаляемогоИнтервала >= ДатаОкончанияТекущегоИнтервала Тогда
			
			// вычеркиваемый период полностью покрывает рассматриваемый период
			СтрокиИсходныхИнтервалов.Удалить(ТекущаяСтрока);
			ИндексТекущейСтроки = ИндексТекущейСтроки - 1;
			ИндексПоследнейСтроки = ИндексПоследнейСтроки - 1;
		ИначеЕсли ДатаНачалаТекущегоИнтервала < ДатаНачалаУдаляемогоИнтервала
			И ДатаОкончанияТекущегоИнтервала > ДатаОкончанияУдаляемогоИнтервала Тогда
			
			// текущий интервал полностью включает вычеркиваемый
			ТекущаяСтрока[ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаНачала] = ДатаНачалаУдаляемогоИнтервала - 1;
			
			НоваяСтрока = ВставитьСтрокуВТаблицу(СтрокиИсходныхИнтервалов, ИндексТекущейСтроки + 1, ТекущаяСтрока);
			НоваяСтрока[ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаНачала] = ДатаОкончанияУдаляемогоИнтервала + 1;	
			НоваяСтрока[ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаОкончания] = ДатаОкончанияТекущегоИнтервала;
			
			ИндексПоследнейСтроки = ИндексПоследнейСтроки + 1;
		ИначеЕсли ДатаНачалаУдаляемогоИнтервала <= ДатаНачалаТекущегоИнтервала Тогда
			ТекущаяСтрока[ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаНачала] = ДатаОкончанияУдаляемогоИнтервала + 1;
			// Остаетмся на текущей строке, т.к. интервал не полностью удален	
			Продолжить;
		ИначеЕсли ДатаОкончанияУдаляемогоИнтервала >= ДатаОкончанияТекущегоИнтервала Тогда
			ТекущаяСтрока[ОписаниеТаблицыИсходныхИнтервалов.ИмяПоляДатаОкончания] = ДатаНачалаУдаляемогоИнтервала - 1;
		КонецЕсли;	
		
		ИндексТекущейСтроки = ИндексТекущейСтроки + 1;
	КонецЦикла;		
КонецПроцедуры

Функция ОбходТаблицы(Таблица, КлючСтрокой, ИмяПоляДатаНачала, ИмяПоляДатаОкончания = Неопределено, Отсортирована = Ложь) Экспорт
	ОбходТаблицы = Новый Структура;
	ОбходТаблицы.Вставить("Таблица", Таблица);
	ОбходТаблицы.Вставить("Ключ", СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(КлючСтрокой, ",", Истина, Истина));
	ОбходТаблицы.Вставить("ИмяПоляДатаНачала", ИмяПоляДатаНачала);
	ОбходТаблицы.Вставить("ИмяПоляДатаОкончания", ИмяПоляДатаОкончания);
	ОбходТаблицы.Вставить("ИндексТекущейСтроки", Неопределено);
	ОбходТаблицы.Вставить("ИндексОчереднойСтроки", 0);
	ОбходТаблицы.Вставить("ИндексПервойСтрокиПоЗначениюКлюча", Неопределено);
	ОбходТаблицы.Вставить("ТекущееЗначениеКлюча", Новый Структура(КлючСтрокой));
	ОбходТаблицы.Вставить("СравнениеЗначений", Новый СравнениеЗначений);
	
	ПоляСортировки = Новый Массив;
	ПоляСортировки.Добавить(КлючСтрокой);
	ПоляСортировки.Добавить(ИмяПоляДатаНачала);
	Если ИмяПоляДатаОкончания <> Неопределено Тогда
		ПоляСортировки.Добавить(ИмяПоляДатаОкончания + " УБЫВ");
	КонецЕсли;	

	
	Если НЕ Отсортирована Тогда
		Таблица.Сортировать(СтрСоединить(ПоляСортировки, ","), Новый СравнениеЗначений);
	КонецЕсли;
	
	Возврат ОбходТаблицы;
КонецФункции	

Функция СледующаяАктуальнаяСтрока(ТекущаяСтрокаИсходнойТаблицы, ОбходТаблицыРазбиения, ТекущаяАктуальнаяСтрока = Неопределено) Экспорт
	Если ТекущаяАктуальнаяСтрока <> Неопределено
		И СравнитьЗначенияКлюча(ТекущаяСтрокаИсходнойТаблицы, ТекущаяАктуальнаяСтрока, ОбходТаблицыРазбиения.Ключ, ОбходТаблицыРазбиения.СравнениеЗначений) = 0
		И ТекущаяАктуальнаяСтрока.ДатаОкончания >= ТекущаяСтрокаИсходнойТаблицы.ДатаНачала 
		И ТекущаяАктуальнаяСтрока.ДатаНачала <= ТекущаяСтрокаИсходнойТаблицы.ДатаНачала Тогда
		
		Возврат ТекущаяАктуальнаяСтрока;
	КонецЕсли;
	
	ТекущаяАктуальнаяСтрока = СледующаяСтрокаВключающаяПериод(ОбходТаблицыРазбиения, ТекущаяСтрокаИсходнойТаблицы, ТекущаяСтрокаИсходнойТаблицы.ДатаНачала);
	
	Если ТекущаяАктуальнаяСтрока <> Неопределено Тогда
		Возврат ТекущаяАктуальнаяСтрока;
	КонецЕсли;	
	
	ТекущаяАктуальнаяСтрока = СледующаяСтрокаПоВхождениюВИнтервал(ОбходТаблицыРазбиения, ТекущаяСтрокаИсходнойТаблицы, ТекущаяСтрокаИсходнойТаблицы.ДатаНачала, ТекущаяСтрокаИсходнойТаблицы.ДатаОкончания);
	
	Возврат ТекущаяАктуальнаяСтрока;
КонецФункции

Функция СпозиционироватьОбходНаОчереднойСтрокеПоКлючу(ОбходТаблицы, ЗначениеКлюча) Экспорт
	Если СравнитьЗначенияКлюча(ОбходТаблицы.ТекущееЗначениеКлюча, ЗначениеКлюча, ОбходТаблицы.Ключ, ОбходТаблицы.СравнениеЗначений) <> 0 Тогда 
		Если СпозиционироватьОбходНаПервойСтрокеПоКлючу(ОбходТаблицы, ЗначениеКлюча) Тогда
			Возврат Истина;
		КонецЕсли;	
	КонецЕсли; 	
			
	Для Индекс = ОбходТаблицы.ИндексОчереднойСтроки По ОбходТаблицы.Таблица.Количество() - 1 Цикл
		ТекущаяСтрокаТаблицы = ОбходТаблицы.Таблица[Индекс];
		РезультатСравнения = СравнитьЗначенияКлюча(ТекущаяСтрокаТаблицы, ЗначениеКлюча, ОбходТаблицы.Ключ, ОбходТаблицы.СравнениеЗначений);
		Если РезультатСравнения > 0 Тогда
			ОбходТаблицы.ИндексОчереднойСтроки = Индекс;
			ОбходТаблицы.ИндексТекущейСтроки = Неопределено;                   
			Возврат Ложь;
		ИначеЕсли РезультатСравнения < 0 Тогда
			Продолжить;
		Иначе
			ОбходТаблицы.ИндексОчереднойСтроки = Индекс;
			ОбходТаблицы.ИндексТекущейСтроки = Индекс;			
			Возврат Истина;	
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат Ложь;
КонецФункции

Функция СпозиционироватьОбходНаПервойСтрокеПоКлючу(ОбходТаблицы, ЗначениеКлюча) Экспорт
	ОбходТаблицы.ИндексПервойСтрокиПоЗначениюКлюча = Неопределено;

	Для Индекс = ОбходТаблицы.ИндексОчереднойСтроки По ОбходТаблицы.Таблица.Количество() - 1 Цикл
		ТекущаяСтрокаТаблицы = ОбходТаблицы.Таблица[Индекс];
		РезультатСравнения = СравнитьЗначенияКлюча(ТекущаяСтрокаТаблицы, ЗначениеКлюча, ОбходТаблицы.Ключ, ОбходТаблицы.СравнениеЗначений);
		Если РезультатСравнения > 0 Тогда
			ОбходТаблицы.ИндексОчереднойСтроки = Индекс;
			ОбходТаблицы.ИндексТекущейСтроки = Неопределено;
			Возврат Ложь;
		ИначеЕсли РезультатСравнения < 0 Тогда
			Продолжить;
		Иначе
			ОбходТаблицы.ИндексОчереднойСтроки = Индекс;
			ОбходТаблицы.ИндексТекущейСтроки = Индекс;

			ЗаполнитьЗначенияСвойств(ОбходТаблицы.ТекущееЗначениеКлюча, ЗначениеКлюча);
			
			Если ОбходТаблицы.ИндексПервойСтрокиПоЗначениюКлюча = Неопределено Тогда
				ОбходТаблицы.ИндексПервойСтрокиПоЗначениюКлюча = Индекс;
			КонецЕсли;
			
			Возврат Истина;	
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат Ложь;
КонецФункции

Функция СледующаяСтрокаПоВхождениюВИнтервал(ОбходТаблицы, ЗначениеКлюча, ДатаНачалаИнтервала, ДатаОкончанияИнтервала = Неопределено) Экспорт
	Результат = Неопределено;
	
	Если Не ЗначениеЗаполнено(ДатаОкончанияИнтервала) Тогда
		ДатаОкончанияИнтервала = ЗарплатаКадрыПериодическиеРегистры.МаксимальнаяДата();
	КонецЕсли;
	
	Пока СпозиционироватьОбходНаОчереднойСтрокеПоКлючу(ОбходТаблицы, ЗначениеКлюча) Цикл
		ТекущаяСтрокаТаблицы = ОбходТаблицы.Таблица[ОбходТаблицы.ИндексТекущейСтроки];
	
		Если ТекущаяСтрокаТаблицы[ОбходТаблицы.ИмяПоляДатаНачала] < ДатаНачалаИнтервала Тогда
			ОбходТаблицы.ИндексОчереднойСтроки = ОбходТаблицы.ИндексОчереднойСтроки + 1;
			Продолжить;
		Иначе
			Если ТекущаяСтрокаТаблицы[ОбходТаблицы.ИмяПоляДатаНачала] <= ДатаОкончанияИнтервала Тогда
				ОбходТаблицы.ИндексОчереднойСтроки = ОбходТаблицы.ИндексОчереднойСтроки + 1;
				Возврат ТекущаяСтрокаТаблицы;
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;				
	КонецЦикла;
	
	Возврат Результат;	
КонецФункции

Функция СледующаяСтрокаВключающаяПериод(ОбходТаблицы, ЗначениеКлюча, Период, ТекущаяСтрокаТаблицы = Неопределено) Экспорт
	Если ТекущаяСтрокаТаблицы <> Неопределено
		И СравнитьЗначенияКлюча(ЗначениеКлюча, ТекущаяСтрокаТаблицы, ОбходТаблицы.Ключ, ОбходТаблицы.СравнениеЗначений) = 0
		И ТекущаяСтрокаТаблицы[ОбходТаблицы.ИмяПоляДатаНачала] <= Период
		И ТекущаяСтрокаТаблицы[ОбходТаблицы.ИмяПоляДатаОкончания] >= Период Тогда
		
		Возврат ТекущаяСтрокаТаблицы;
	КонецЕсли;	
	
	Пока СпозиционироватьОбходНаОчереднойСтрокеПоКлючу(ОбходТаблицы, ЗначениеКлюча) Цикл
		ТекущаяСтрокаТаблицы = ОбходТаблицы.Таблица[ОбходТаблицы.ИндексТекущейСтроки];
	
		Если ТекущаяСтрокаТаблицы[ОбходТаблицы.ИмяПоляДатаНачала] > Период Тогда
			Возврат Неопределено;
		Иначе
			Если ТекущаяСтрокаТаблицы[ОбходТаблицы.ИмяПоляДатаОкончания] >= Период Тогда
				ОбходТаблицы.ИндексОчереднойСтроки = ОбходТаблицы.ИндексОчереднойСтроки + 1;

				Возврат ТекущаяСтрокаТаблицы;
			КонецЕсли;
			ОбходТаблицы.ИндексОчереднойСтроки = ОбходТаблицы.ИндексОчереднойСтроки + 1;
		КонецЕсли;				
	КонецЦикла;
		
	Возврат Неопределено;	
КонецФункции

Процедура СброситьОбходТаблицыНаПервуюСтрокуПоКлючу(ОбходТаблицы) Экспорт
	ОбходТаблицы.ИндексТекущейСтроки = Неопределено;
	ОбходТаблицы.ИндексОчереднойСтроки = ?(ОбходТаблицы.ИндексПервойСтрокиПоЗначениюКлюча = Неопределено, ОбходТаблицы.ИндексОчереднойСтроки, ОбходТаблицы.ИндексПервойСтрокиПоЗначениюКлюча);	
КонецПроцедуры	

Функция СравнитьЗначенияКлюча(ПервоеЗначение, ВтороеЗначение, ПоляКлюча, СравнениеЗначений)
	Результат = 0;
	Для Каждого Поле Из ПоляКлюча Цикл 
		Результат = СравнениеЗначений.Сравнить(ПервоеЗначение[Поле], ВтороеЗначение[Поле]);
		Если Результат <> 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;	
		
	Возврат Результат;	
КонецФункции	

Функция СтрокаВключающаяДату(СтрокиТаблицы, Дата) Экспорт
	Для Каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
		Если ОбщегоНазначенияБЗК.ДатаВИнтервале(Дата, СтрокаТаблицы.ДатаНачала, СтрокаТаблицы.ДатаОкончания) Тогда
			Возврат СтрокаТаблицы;
		КонецЕсли;			
	КонецЦикла;	
	
	Возврат Неопределено;
КонецФункции	

Функция СтрокиВключающиеДату(СтрокиТаблицы, Дата) Экспорт
	Результат = Новый Массив;
	Для Каждого СтрокаТаблицы Из СтрокиТаблицы Цикл
		Если ОбщегоНазначенияБЗК.ДатаВИнтервале(Дата, СтрокаТаблицы.ДатаНачала, СтрокаТаблицы.ДатаОкончания) Тогда
			Результат.Добавить(СтрокаТаблицы);
		КонецЕсли;			
	КонецЦикла;	
	
	Возврат Результат;
КонецФункции

Функция СгруппироватьТаблицу(Таблица, ПоляГруппировкиСтрокой, ГруппируемыеПоляСтрокой) Экспорт
	МакетКомпоновки = МакетКомпоновкиДанных();
	
	ПоляГруппировки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПоляГруппировкиСтрокой, ",", Истина, Истина);	
	ГруппируемыеПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ГруппируемыеПоляСтрокой, ",", Истина, Истина);
	
	ТипыПолей = Новый Соответствие;
	
	ВыраженияПолейГруппировки = Новый Массив;
	Для Каждого Поле Из ПоляГруппировки Цикл
		ВыражениеПоля = "Таблица." + Поле;
		ДобавитьВыбираемоеПолеВМакетКомпоновки(МакетКомпоновки, ВыражениеПоля, Поле);
		ВыраженияПолейГруппировки.Добавить(ВыражениеПоля);
		ТипыПолей.Вставить(Поле, Таблица.Колонки[Поле].ТипЗначения);
	КонецЦикла;	
	
	Для Каждого Поле Из ГруппируемыеПоля Цикл
		ПервыйСимволПоля = СтрНайти(Поле, "(") + 1;
		ПоследнийСимволПоля = СтрНайти(Поле, ")") - 1;
		ПолеТаблицы = Сред(Поле, ПервыйСимволПоля, ПоследнийСимволПоля - ПервыйСимволПоля + 1);
		ТипыПолей.Вставить(ПолеТаблицы, Таблица.Колонки[ПолеТаблицы].ТипЗначения);
	
		ВыражениеПоля = СтрЗаменить(Поле, ПолеТаблицы, "Таблица." + ПолеТаблицы);
		ДобавитьВыбираемоеПолеВМакетКомпоновки(МакетКомпоновки, ВыражениеПоля, ПолеТаблицы);
	КонецЦикла;	
	
	ДобавитьНаборДанныхСКДПоТаблицеЗначений(МакетКомпоновки.НаборыДанных, Таблица, "Таблица", "Таблица");		
	ТаблицыИсточники = Новый Структура("Таблица", Таблица);
	
	Возврат ПолучитьДанныеПоМакетуКомпоновки(МакетКомпоновки, ТаблицыИсточники, ВыраженияПолейГруппировки, ТипыПолей);
КонецФункции

Функция ПолучитьДанныеПоМакетуКомпоновки(МакетКомпоновки, ТаблицыИсточники, ВыраженияПолейГруппировки = Неопределено, ТипыПолейРезультирующейТаблицы = Неопределено) Экспорт
	СоздатьТелоМакетаКомпоновки(МакетКомпоновки, ВыраженияПолейГруппировки);
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки, ТаблицыИсточники);
	
	Результат = Новый ТаблицаЗначений;
	Если ТипыПолейРезультирующейТаблицы <> Неопределено Тогда
		Для Каждого Поле Из ТипыПолейРезультирующейТаблицы Цикл
			Результат.Колонки.Добавить(Поле.Ключ, Поле.Значение);
		КонецЦикла;	
	КонецЕсли;	
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.УстановитьОбъект(Результат);
	
	ПроцессорВывода.Вывести(ПроцессорКомпоновки);

	Возврат Результат;	                	
КонецФункции	

Процедура ДобавитьНаборДанныхСКДПоТаблицеЗначений(Приемник, Таблица, ИмяТаблицы, Псевдоним) Экспорт
	
	Набор = Приемник.Добавить(Тип("НаборДанныхОбъектМакетаКомпоновкиДанных"));
	Набор.Имя = Псевдоним;
	Набор.ИмяОбъекта = ИмяТаблицы;
	Набор.ИсточникДанных = "Источник";
	
	Для Каждого КолонкаТаблицы Из Таблица.Колонки Цикл
		ПолеНабораДанных = Набор.Поля.Добавить();
		ПолеНабораДанных.ПутьКДанным = КолонкаТаблицы.Имя;
		ПолеНабораДанных.Имя = КолонкаТаблицы.Имя;
	КонецЦикла;	
	
КонецПроцедуры	

Процедура ДобавитьВыбираемоеПолеВМакетКомпоновки(МакетКомпоновки, Выражение, Псевдоним) Экспорт
	Если МакетКомпоновки.Макеты.Количество() = 0 Тогда
		ОписаниеМакетаЗаголовкаКоллекции = МакетКомпоновки.Макеты.Добавить();
		ОписаниеМакетаЗаголовкаКоллекции.Имя = "Макет1";
		
		ОписаниеМакетаКоллекцииЗначений = МакетКомпоновки.Макеты.Добавить();
		ОписаниеМакетаКоллекцииЗначений.Имя = "Макет2";
	Иначе
		ОписаниеМакетаЗаголовкаКоллекции = МакетКомпоновки.Макеты[0];
		ОписаниеМакетаКоллекцииЗначений = МакетКомпоновки.Макеты[1];
	КонецЕсли;	
	
	ПараметрОбласти = ОписаниеМакетаКоллекцииЗначений.Параметры.Добавить(Тип("ПараметрОбластиВыражениеКомпоновкиДанных"));
	ПараметрОбласти.Выражение = Выражение;
	ПараметрОбласти.Имя = Псевдоним;
	
	Если ОписаниеМакетаКоллекцииЗначений.Макет = Неопределено Тогда
		ОписаниеМакетаКоллекцииЗначений.Макет = Новый МакетКоллекцииЗначенийОбластиКомпоновкиДанных;
	КонецЕсли;	
	
	Ячейка = ОписаниеМакетаКоллекцииЗначений.Макет.Ячейки.Добавить();
	Ячейка.Значение = Новый ПараметрКомпоновкиДанных(Псевдоним);
	Ячейка.Колонка = Псевдоним;	
	
	Если ОписаниеМакетаЗаголовкаКоллекции.Макет = Неопределено Тогда
		ОписаниеМакетаЗаголовкаКоллекции.Макет = Новый МакетЗаголовкаКоллекцииЗначенийОбластиКомпоновкиДанных;
	КонецЕсли;	
		
	Ячейка = ОписаниеМакетаЗаголовкаКоллекции.Макет.Ячейки.Добавить();
	Ячейка.Имя = Псевдоним;		
КонецПроцедуры	

Функция МакетКомпоновкиДанных() Экспорт
	МакетКомпоновки = Новый МакетКомпоновкиДанных;
	Источник = МакетКомпоновки.ИсточникиДанных.Добавить();
	Источник.Имя = "Источник";
	Источник.Тип = "Local";
	
	Возврат МакетКомпоновки;
КонецФункции

#Область Таблицы

Функция УникальныеЗначенияКолонки(ТаблицаЗначений, ИмяКолонки, Сортировать = Ложь) Экспорт
	Если ТипЗнч(ТаблицаЗначений) = Тип("ТаблицаЗначений") Тогда
		Копия = ТаблицаЗначений.Скопировать(, ИмяКолонки);
	Иначе
		Копия = ТаблицаЗначений.Выгрузить(, ИмяКолонки);
	КонецЕсли;
	Копия.Свернуть(ИмяКолонки);
	Если Сортировать Тогда
		Копия.Сортировать(ИмяКолонки);
	КонецЕсли;
	Возврат Копия.ВыгрузитьКолонку(ИмяКолонки);
КонецФункции

Функция УникальныеЗначенияКолонкиСФильтром(ТаблицаЗначений, Фильтр, ИмяКолонки, Сортировать = Ложь) Экспорт
	Копия = ТаблицаЗначений.Скопировать(Фильтр, ИмяКолонки);
	Копия.Свернуть(ИмяКолонки);
	Если Сортировать Тогда
		Копия.Сортировать(ИмяКолонки);
	КонецЕсли;
	Возврат Копия.ВыгрузитьКолонку(ИмяКолонки);
КонецФункции

// Преобразует массив структур в таблицу значений.
//
// Если элементы массива имеют тип Структура или ФиксированнаяСтруктура,
// то колонки таблицы будут образованы из ключей структуры, иначе в результирующей таблице
// будет одна колонка с именем "Колонка1".
//
// Параметры:
//  Массив - Массив - Элементы которого должны быть типа Структура или ФиксированнаяСтруктура.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Таблица с колонками по ключам структур.
//
Функция МассивВТаблицу(Массив) Экспорт
	
	Результат = Новый ТаблицаЗначений;
	
	Если Массив.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Элемент = Массив[0];
	ТипЭлемента = ТипЗнч(Элемент);
	
	Если ТипЭлемента = Тип("Структура") Или ТипЭлемента = Тип("ФиксированнаяСтруктура") Тогда
		Для Каждого ЭлементСтруктуры Из Элемент Цикл
			Результат.Колонки.Добавить(ЭлементСтруктуры.Ключ);
		КонецЦикла;
		Для Каждого Элемент Из Массив Цикл
			ЗаполнитьЗначенияСвойств(Результат.Добавить(), Элемент);
		КонецЦикла;
	Иначе
		Результат.Колонки.Добавить("Колонка1");
		Для Каждого Элемент Из Массив Цикл
			НоваяСтрока = Результат.Добавить();
			НоваяСтрока.Колонка1 = Элемент;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает объединенную таблицу с ключевыми колонками и признаком наличия данных в таблицах 1 и 2.
//
// Параметры:
//   Таблица1 - ТаблицаЗначений - Сравниваемая таблица 1.
//   Таблица2 - ТаблицаЗначений - Сравниваемая таблица 2.
//   КлючевыеКолонки - Строка - Имена ключевых колонок по которым будут сравниваться таблицы.
//   Фильтр - Структура, Неопределено - Фильтр выбираемых данных из таблиц 1 и 2.
//   ТолькоИзменения - Булево - Если Истина, то в возвращаемой таблице будут только строки с изменениями.
//       (ВидИзмененияСтроки <> 0)
//
// Возвращаемое значение:
//   ТаблицаЗначений - Таблица со свернутыми ключевыми данными из таблиц 1 и 2.
//       В этой таблице есть колонки указанные в параметре КлючевыеКолонки,
//       а также добавлена колонка "ВидИзмененияСтроки" (тип: Число),
//       которая содержит признак наличия строки в таблицах 1 и 2.
//       ВидИзмененияСтроки = -1 - Строка (или строки) есть только в таблице 1;
//       ВидИзмененияСтроки = 0  - Строка (или строки) есть в обеих таблицах;
//       ВидИзмененияСтроки = 1  - Строка (или строки) есть только в таблице 2.
//
Функция СравнитьТаблицы(Таблица1, Таблица2, КлючевыеКолонки, Фильтр = Неопределено, ТолькоИзменения = Ложь) Экспорт
	Таблица = Таблица1.Скопировать(Фильтр, КлючевыеКолонки);
	Таблица.Свернуть(КлючевыеКолонки);
	
	Таблица.Колонки.Добавить("ВидИзмененияСтроки", Новый ОписаниеТипов("Число"));
	Таблица.ЗаполнитьЗначения(-1, "ВидИзмененияСтроки");
	
	Копия = Таблица2.Скопировать(Фильтр, КлючевыеКолонки);
	Копия.Свернуть(КлючевыеКолонки);
	Для Каждого СтрокаПравая Из Копия Цикл
		СтрокаТаблицы = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, СтрокаПравая);
		СтрокаТаблицы.ВидИзмененияСтроки = 1;
	КонецЦикла;
	
	Таблица.Свернуть(КлючевыеКолонки, "ВидИзмененияСтроки");
	
	Если ТолькоИзменения Тогда
		УдалитьСтрокиТаблицыПоЗначению(Таблица, "ВидИзмененияСтроки", 0);
	КонецЕсли;
	
	Возврат Таблица;
КонецФункции

// Возвращает Истина если таблицы совпадают, Ложь - если есть отличия.
//
// Параметры:
//   Таблица1 - ТаблицаЗначений - Сравниваемая таблица 1.
//   Таблица2 - ТаблицаЗначений - Сравниваемая таблица 2.
//
// Возвращаемое значение:
//   Булево - Истина: таблицы идентичны; Ложь: есть различия.
//
Функция ТаблицыИдентичны(Таблица1, Таблица2) Экспорт
	
	Если Таблица1.Колонки.Количество() <> Таблица2.Колонки.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИменаКолонок = "";
	Для Каждого Колонка Из Таблица1.Колонки Цикл 
		ИменаКолонок = ИменаКолонок + ", " + Колонка.Имя;
	КонецЦикла;
	ИменаКолонок = Сред(ИменаКолонок, 3);
	
	Сравнение = Таблица1.Скопировать();
	Сравнение.Колонки.Добавить("Счетчик", Новый ОписаниеТипов("Число"));
	Сравнение.ЗаполнитьЗначения(1, "Счетчик");
	
	Для Каждого Строка Из Таблица2 Цикл
		НоваяСтрока = Сравнение.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		НоваяСтрока.Счетчик = -1;
	КонецЦикла;
	
	Сравнение.Свернуть(ИменаКолонок, "Счетчик");
	
	Возврат Сравнение.НайтиСтроки(Новый Структура("Счетчик", 0)).Количество() = Сравнение.Количество();
	
КонецФункции

Функция ЗначенияСвойствСовпадают(ЛеваяКоллекция, ПраваяКоллекция, ИменаСвойств) Экспорт
	Для Каждого ИмяСвойства Из ИменаСвойств Цикл
		Если ЛеваяКоллекция[ИмяСвойства] <> ПраваяКоллекция[ИмяСвойства] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Создает пустую таблицу значений по метаданным ссылочного объекта.
Функция ТаблицаЗначенийПоМетаданным(МетаданныеТаблицы) Экспорт
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	Для Каждого Реквизит Из МетаданныеТаблицы.Реквизиты Цикл
		ТаблицаЗначений.Колонки.Добавить(Реквизит.Имя, Реквизит.Тип);
	КонецЦикла;
	
	Возврат ТаблицаЗначений;
КонецФункции

Функция СкопироватьКолонки(Таблица, Колонки = "") Экспорт
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		Возврат Таблица.СкопироватьКолонки(Колонки);
	Иначе
		Возврат Таблица.Выгрузить(Новый Массив).СкопироватьКолонки(Колонки);
	КонецЕсли;
КонецФункции

// Удаляет строки таблицы соответствующие указанному отбору по ИмяКолонки = ЗначениеКолонки.
//
// Параметры:
//   Таблица - ТаблицаЗначений
//   ИмяКолонки - Строка
//   ЗначениеКолонки - Произвольный
//
Процедура УдалитьСтрокиТаблицыПоЗначению(Таблица, ИмяКолонки, ЗначениеКолонки) Экспорт
	Найденные = Таблица.НайтиСтроки(Новый Структура(ИмяКолонки, ЗначениеКолонки));
	Для Каждого СтрокаТаблицы Из Найденные Цикл
		Таблица.Удалить(СтрокаТаблицы);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти

// Создает нерекурсивную копию структуры. Работает эффективнее чем другие методы копирования структуры.
Функция СкопироватьСтруктуру(Структура) Экспорт
	Возврат Новый Структура(Новый ФиксированнаяСтруктура(Структура));
КонецФункции

// Создает рекурсивную копию коллекции. Ограничение: все вложенные значения должны быть сериализуемыми в XML.
//   Работает эффективнее чем ОбщегоНазначения.СкопироватьРекурсивно().
//
// Параметры:
//   Коллекция - Произвольный - Коллекция, которую необходимо скопировать.
//
Функция СкопироватьРекурсивно(Коллекция) Экспорт
	Возврат ОбщегоНазначения.ЗначениеИзСтрокиXML(ОбщегоНазначения.ЗначениеВСтрокуXML(Коллекция));
КонецФункции

#Область Массивы

// Добавляет значение в массив, если оно заполнено и его нет в массиве.
Процедура ДобавитьНеПустоеЗначениеВМассив(Массив, Значение) Экспорт
	Если ЗначениеЗаполнено(Значение) И Массив.Найти(Значение) = Неопределено Тогда
		Массив.Добавить(Значение);
	КонецЕсли;
КонецПроцедуры

// Удаляет из массива пустые значения.
Процедура УдалитьПустыеЗначенияМассива(Массив) Экспорт
	ОбратныйИндекс = Массив.Количество();
	Пока ОбратныйИндекс > 0 Цикл
		ОбратныйИндекс = ОбратныйИндекс - 1;
		Значение = Массив[ОбратныйИндекс];
		Если Не ЗначениеЗаполнено(Значение) Тогда
			Массив.Удалить(ОбратныйИндекс);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция СортироватьМассив(Массив, Направление = Неопределено) Экспорт
	Список = Новый СписокЗначений;
	Список.ЗагрузитьЗначения(Массив);
	Список.СортироватьПоЗначению(?(Направление = Неопределено, НаправлениеСортировки.Возр, Направление));
	Возврат Список.ВыгрузитьЗначения();
КонецФункции

// Возвращает свернутый массив.
//   Отличия от ОбщегоНазначенияКлиентСервер.СвернутьМассив() - работает быстрее
//   и название соответствует стандартам (меньше риск ошибиться при использовании).
//
// Параметры:
//   Массив - Массив - Исходный массив.
//
// Возвращаемое значение:
//   Массив - Копия исходного массива без дублей (содержит только уникальные значения).
//
Функция СвернутыйМассив(Массив) Экспорт
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("А");
	Для НомерЭлемента = 1 По Массив.Количество() Цикл
		Таблица.Добавить();
	КонецЦикла;
	Таблица.ЗагрузитьКолонку(Массив, "А");
	Таблица.Свернуть("А");
	Возврат Таблица.ВыгрузитьКолонку("А");
КонецФункции

// Сравнивает массивы значений. Возвращает структуру "ДобавленныеВЛевом, ДобавленныеВПравом, ПрисутствующиеВОбоих".
//
// Параметры:
//   МассивЛевый  - Массив
//   МассивПравый - Массив
//
// Возвращаемое значение:
//   Структура - Результат сравнения массивов.
//       * ДобавленныеВЛевом - Массив
//       * ДобавленныеВПравом - Массив
//       * ПрисутствующиеВОбоих - Массив
//
Функция СравнитьМассивы(МассивЛевый, МассивПравый) Экспорт
	ДобавленныеВЛевом  = Новый Массив;
	ДобавленныеВПравом = СкопироватьМассив(МассивПравый);
	ПрисутствующиеВОбоих = Новый Массив;
	
	Для Каждого Элемент Из МассивЛевый Цикл
		Индекс = ДобавленныеВПравом.Найти(Элемент);
		Если Индекс = Неопределено Тогда
			ДобавленныеВЛевом.Добавить(Элемент);
		Иначе
			ПрисутствующиеВОбоих.Добавить(Элемент);
			ДобавленныеВПравом.Удалить(Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("ДобавленныеВЛевом, ДобавленныеВПравом, ПрисутствующиеВОбоих", ДобавленныеВЛевом, ДобавленныеВПравом, ПрисутствующиеВОбоих);
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура СоздатьТелоМакетаКомпоновки(МакетКомпоновки, ПоляГруппировки = Неопределено)	
	Тело = МакетКомпоновки.Тело.Добавить(Тип("МакетОбластиМакетаКомпоновкиДанных"));
	Тело.Макет = "Макет1";
	
	Тело = МакетКомпоновки.Тело.Добавить(Тип("ГруппировкаМакетаКомпоновкиДанных"));
	
	Если ПоляГруппировки <> Неопределено Тогда
		Для Каждого Поле Из ПоляГруппировки Цикл
			ПолеГруппировки = Тело.Группировка.Добавить();	
			ПолеГруппировки.Выражение = Поле;
			ПолеГруппировки.ИмяПоля  = Поле
		КонецЦикла;	
	Иначе
		Тело = МакетКомпоновки.Тело.Добавить(Тип("ЗаписиМакетаКомпоновкиДанных"));
		 
		Для Каждого Набор Из МакетКомпоновки.НаборыДанных Цикл
			Тело.НаборыДанных.Добавить(Набор.Имя);
		КонецЦикла;
	КонецЕсли;	
	
	Тело.Идентификатор = "Записи";
	Тело.Имя = "Записи";
	Тело.КоличествоЗаписей = -1;
			
	МакетОбласти = Тело.Тело.Добавить(Тип("МакетОбластиМакетаКомпоновкиДанных"));
	МакетОбласти.Макет = "Макет2";
	
КонецПроцедуры	

Функция ВставитьСтрокуВТаблицу(Таблица, ИндексСтроки = Неопределено, ШаблонЗаполнения = Неопределено)
	Если ИндексСтроки = Неопределено 
		Или ИндексСтроки > Таблица.Количество() - 1 Тогда
		
		НоваяСтрока = Таблица.Добавить();		
	Иначе
		НоваяСтрока = Таблица.Вставить(ИндексСтроки);
	КонецЕсли;
	
	Если ШаблонЗаполнения <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ШаблонЗаполнения);
	КонецЕсли;
	
	Возврат НоваяСтрока;
КонецФункции

Функция СкопироватьМассив(Массив)
	Возврат Новый Массив(Новый ФиксированныйМассив(Массив));
КонецФункции

#КонецОбласти
