
#Область ПрограммныйИнтерфейс

// Выполняет разузлование продукции и полуфабрикатов и для каждого элемента в структуре изделий
//  получает заданный набор данных ресурсной спецификации. В процессе обработки так же выполняется
//  укрупнение партий выпуска продукции и полуфабрикатов.
//
// Параметры:
//  Изделия	              - ТаблицаЗначений - таблица с номенклатурой, структуру производства которой необходимо получить.
//	ПараметрыРазузлования - см. РазузлованиеИзделий.ПараметрыРазузлования.
//  ПараметрыВыборки      - Структура - параметры выборки данных ресурсной спецификации
//		см. Справочники.РесурсныеСпецификации.ПараметрыВыборкиДанных.
// 
// Возвращаемое значение:
//  Структура - структура с элементами:
//  	* ДанныеСпецификаций - Массив, Неопределено - элементами массива являются структуры, содержащие данные ресурсных спецификаций.
//  	* ЕстьОшибка - Булево - Истина если при разузловании возникла ошибка (ДанныеСпецификаций в этом случае имеют значение Неопределено).
//  	* ОшибкаТекст - Строка - описание возникшей ошибки.
//  	* ОшибкаСсылка - СправочникСсылка, ДокументСсылка - ссылка на объект, с которым связана ошибка.
//
Функция Разузловать(Изделия, ПараметрыРазузлования, ПараметрыВыборки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ДанныеСпецификаций", Неопределено);
	Результат.Вставить("ЕстьОшибка",         Ложь);
	Результат.Вставить("ОшибкаТекст",        "");
	Результат.Вставить("ОшибкаСсылка",       Неопределено);
	
	Потребности = ВыгрузитьВходящиеИзделияДляОбработки(Изделия);
	ПараметрыВыборки.ПереченьДанных = Справочники.РесурсныеСпецификации.ПереченьДанныхСпецификации();
	РазузловатьПотребностиРекурсивно(Потребности, Потребности, ПараметрыРазузлования, ПараметрыВыборки);
	
	ОписаниеОшибки = Новый Структура("ЕстьОшибка, ОшибкаТекст, ОшибкаСсылка", Ложь, "", Неопределено);
	ПроверитьКорректностьСпецификаций(Потребности.ВыгрузитьКолонку("Спецификация"), ОписаниеОшибки);
	
	Если НЕ ОписаниеОшибки.ЕстьОшибка Тогда
		
		//++ НЕ УТКА
		ЗаполнитьСрокиОбеспеченияПролеживанияПотребностей(Потребности);
		Если ПараметрыРазузлования.ГруппироватьДанные Тогда
			СвернутьПотребности(Потребности, ПараметрыРазузлования, ПараметрыВыборки);
		КонецЕсли;
		//-- НЕ УТКА
		
		Результат.ДанныеСпецификаций = РазделитьПотребностиНаПартии(Потребности, ПараметрыРазузлования);
		
	Иначе
		ЗаполнитьЗначенияСвойств(Результат, ОписаниеОшибки);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Функция - конструктор структуры, определяющей параметры разузлования изделий.
//
// Возвращаемое значение:
//  Структура - структура параметров.
Функция ПараметрыРазузлования() Экспорт
	
	Результат = Новый Структура;
	
	// Разделять результат разузлования на опт. партии либо возвращать его одной партией.
	Результат.Вставить("РазделятьНаОптимальныеПартии", Истина);
	
	// Параметр ГруппироватьДанные определяет необходимость объединения (укрупнения) 
	// данных, относящихся к одной спецификации. Помимо спецификации можно задать
	// произвольный набор полей в разрезе которых будет выполняться объединение - ПоляГруппировки.
	// В качестве значения следует указать имена колонок таблицы изделий без пробелов, разделенных запятыми.
	// Поля группировки так же будут перенесены в результат разузлования.
	Результат.Вставить("ГруппироватьДанные", Ложь);
	Результат.Вставить("ПоляГруппировки", "");
	
	// Параметр содержит имена колонок таблицы изделий которые необходимо "протянуть" сквозь всю
	// структуру изделий, наследуя их значений от родителя к его потомкам. Значения полей переносятся
	// в результат разузлования. При группировке доп. информация наследуется от одного из изделий,
	// выбираемого произвольным образом.
	Результат.Вставить("ДополнительнаяИнформация", "");
	
	// Если параметр РезервПФСоСклада имеет значение Истина,
	// то по производимым в процессе ПФ вначале выполняется попытка сделать резерв на
	// складе/в графике, и дальнейшее разузлование выполняется на недостающую часть.
	// Если при резерве необходимо так же анализировать обособленные остатки, то таблица
	// изделий должна содержать колонку с соответствующим назначением, а имя колонки
	// следует передать через параметр РезервПФИмяПоляНазначение. Для резервирования
	// исключительно обособленных остатков служит параметр РезервПФТолькоОбособленно.
	Результат.Вставить("РезервПФСоСклада", Ложь);
	Результат.Вставить("РезервПФИмяПоляНазначение", "");
	Результат.Вставить("РезервПФТолькоОбособленно", Ложь);
	
	//++ НЕ УТКА

	// Флаг необходимости замены ПФ в процессе на аналоги. Замена происходит лишь в том случае, если
	// остаток аналога имеется на складе. Поэтому данный параметр может принимать Истина только
	// совместно параметром РезервПФСоСклада.
	Результат.Вставить("ЗаменятьПФНаАналоги", Ложь);
	//-- НЕ УТКА
	
	Возврат Результат;
	
КонецФункции

// Функция - определяет поля группировки для разузлования изделий
//
// Параметры:
//  Поля - Строка - список полей, необходимый потребителю интерфейса разузлования
//
// Возвращаемое значение:
//  Строка - список полей, дополненный обязательными полями
Функция ПоляГруппировки(Поля = "") Экспорт
	
	Результат = Новый Массив;
	
	Если НЕ ПустаяСтрока(Поля) Тогда
		Результат.Добавить(Поля);
	КонецЕсли;
	
	Для каждого ИмяПараметра Из СтрРазделить("НаправлениеДеятельности,ПодразделениеДиспетчер", ",") Цикл
		Если УправлениеДаннымиОбИзделияхПовтИсп.ВидПараметраНазначенияИспользуется(
				Перечисления.ВидыПараметровНазначенияСпецификаций[ИмяПараметра]) Тогда
			Результат.Добавить(ИмяПараметра);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(Результат, ",");
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращаемое значение:
// 	ТаблицаЗначений:
// * Идентификатор - Число -
// * ДанныеСпецификации - Структура -
// * Входы - см. НовыйСвязиПотребностей
// * Выходы - см. НовыйСвязиПотребностей
// * СвернутыеВходящиеПотребности - Массив -
// * Обеспечение - см. НовыйОбеспечениеПотребности
// * Аналоги - см. НовыйАналогиПотребности
// * ПланироватьНеРанее - СправочникСсылка.ЭтапыПроизводства -
// * ЭтоРазборка - Булево -
// * ЭтоРемонт - Булево -
// * ЭтоВходящаяПотребность - Булево -
// * ЭтоТолкающаяСхема - Булево -
// * Начало - Дата -
// * Окончание - Дата -
// * ДатаОбеспеченияПФ - Дата -
// * МаксимальныйСрокПролеживания - Число -
// * СрокПролеживания - Дата -
// * ПартияВыпуска - Структура -
// * ДнейОтПотребности - Число -
// * ПодразделениеДиспетчер - СправочникСсылка.СтруктураПредприятия -
// * НаправлениеДеятельности - СправочникСсылка.НаправленияДеятельности -
// * СписатьНаРасходы - Булево -
// * СтатьяРасходов - ПланВидовХарактеристикСсылка.СтатьиРасходов, ПланВидовХарактеристикСсылка.СтатьиАктивовПассивов -
// * АналитикаРасходов - Характеристика.СтатьиРасходов
// * АналитикаАктивовПассивов - Характеристика.СтатьиАктивовПассивов
// * ПодразделениеПолучатель - СправочникСсылка.Склады, СправочникСсылка.СтруктураПредприятия -
// * НачалоПроизводства - Дата -
// * Родитель - СтрокаТаблицыЗначений -
// * Свернута - Булево -
// * Обработана - Булево -
// * Отправитель - СправочникСсылка.Склады - 
// * Получатель - СправочникСсылка.Склады -
Функция ВыгрузитьВходящиеИзделияДляОбработки(Изделия)
	
	Потребности = Изделия.Скопировать();
	
	Потребности.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Потребности.Колонки.Добавить("ДанныеСпецификации", Новый ОписаниеТипов("Структура"));
	
	Потребности.Колонки.Добавить("Входы", Новый ОписаниеТипов("ТаблицаЗначений"));
	Потребности.Колонки.Добавить("Выходы", Новый ОписаниеТипов("ТаблицаЗначений"));
	Потребности.Колонки.Добавить("СвернутыеВходящиеПотребности", Новый ОписаниеТипов("Массив"));
	Потребности.Колонки.Добавить("Обеспечение", Новый ОписаниеТипов("ТаблицаЗначений"));
	//++ НЕ УТКА
	Потребности.Колонки.Добавить("Аналоги", Новый ОписаниеТипов("ТаблицаЗначений"));
	//-- НЕ УТКА
	
	Потребности.Колонки.Добавить("ПланироватьНеРанее", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	
	Потребности.Колонки.Добавить("ЭтоРазборка", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("ЭтоРемонт", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("ЭтоВходящаяПотребность", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("ЭтоТолкающаяСхема", Новый ОписаниеТипов("Булево"));
	
	Потребности.Колонки.Добавить("Начало", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	Потребности.Колонки.Добавить("Окончание", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	
	Потребности.Колонки.Добавить("МаксимальныйСрокПролеживания", Новый ОписаниеТипов("Число"));
	Потребности.Колонки.Добавить("СрокПролеживания", Новый ОписаниеТипов("Дата"));
	
	Потребности.Колонки.Добавить("ПартияВыпуска", Новый ОписаниеТипов("Структура"));
	Потребности.Колонки.Добавить("ДнейОтПотребности", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	Если Потребности.Колонки.Найти("ПодразделениеДиспетчер") = Неопределено Тогда
		Потребности.Колонки.Добавить("ПодразделениеДиспетчер",
			Новый ОписаниеТипов("СправочникСсылка.СтруктураПредприятия"));
	КонецЕсли;
		
	Если Потребности.Колонки.Найти("НаправлениеДеятельности") = Неопределено Тогда
		Потребности.Колонки.Добавить("НаправлениеДеятельности",
			Новый ОписаниеТипов("СправочникСсылка.НаправленияДеятельности"));
	КонецЕсли;
		
	Если Потребности.Колонки.Найти("СписатьНаРасходы") = Неопределено Тогда
		
		ТипыСтатей = Новый Массив;
		ТипыСтатей.Добавить(Тип("ПланВидовХарактеристикСсылка.СтатьиРасходов"));
		ТипыСтатей.Добавить(Тип("ПланВидовХарактеристикСсылка.СтатьиАктивовПассивов"));
		
		Потребности.Колонки.Добавить("СписатьНаРасходы"         , Новый ОписаниеТипов("Булево"));
		Потребности.Колонки.Добавить("СтатьяРасходов"           , Новый ОписаниеТипов(ТипыСтатей));
		Потребности.Колонки.Добавить("АналитикаРасходов"        , Метаданные.ПланыВидовХарактеристик.СтатьиРасходов.Тип);
		Потребности.Колонки.Добавить("АналитикаАктивовПассивов" , Метаданные.ПланыВидовХарактеристик.СтатьиАктивовПассивов.Тип);
		
	КонецЕсли;
	
	ТипыПолучатель = Новый Массив;
	ТипыПолучатель.Добавить(Тип("СправочникСсылка.СтруктураПредприятия"));
	ТипыПолучатель.Добавить(Тип("СправочникСсылка.Склады"));
	Потребности.Колонки.Добавить("ПодразделениеПолучатель", Новый ОписаниеТипов(ТипыПолучатель));
	Потребности.Колонки.Добавить("НачалоПроизводства", Новый ОписаниеТипов("Дата"));
	
	// Служебные поля
	Потребности.Колонки.Добавить("Родитель", Новый ОписаниеТипов("Null, СтрокаТаблицыЗначений"));
	Потребности.Колонки.Добавить("Уровень", Новый ОписаниеТипов("Число"));
	Потребности.Колонки.Добавить("Свернута", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("Обработана", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("Порядок", Новый ОписаниеТипов("Число"));
	
	Идентификатор = 1;
	
	Для каждого Строка Из Потребности Цикл
		
		Строка.Идентификатор = Идентификатор;
		Строка.ЭтоВходящаяПотребность = Истина;
		Строка.Входы = НовыйСвязиПотребностей();
		Строка.Выходы = НовыйСвязиПотребностей();
		Строка.Обеспечение = НовыйОбеспечениеПотребности();
		Строка.НачалоПроизводства = Строка.ДатаЗапуска;
		Строка.Порядок = Строка.НомерСтроки;
		//++ НЕ УТКА
		Строка.Аналоги = НовыйАналогиПотребности();
		//-- НЕ УТКА
		
		Идентификатор = Идентификатор + 1;
		
	КонецЦикла;
	
	Возврат Потребности;
	
КонецФункции

// Параметры:
// 	Потребности - см. ВыгрузитьВходящиеИзделияДляОбработки
// 	СтрокиДляОбработки - см. ВыгрузитьВходящиеИзделияДляОбработки
// 	ПараметрыРазузлования - см. ПараметрыРазузлования
// 	ПараметрыВыборки - см. Справочники.РесурсныеСпецификации.ПараметрыВыборкиДанных
// 	Идентификатор - Число - идентификатор текущей строки
// 	РезервыПФ - см. НовыйРезервыПолуфабрикатов
//
Процедура РазузловатьПотребностиРекурсивно(Потребности, СтрокиДляОбработки, ПараметрыРазузлования, ПараметрыВыборки, Идентификатор = Неопределено, РезервыПФ = Неопределено)
	
	ДанныеСпецификаций = Справочники.РесурсныеСпецификации.ДанныеСпецификации(
		?(ТипЗнч(СтрокиДляОбработки) = Тип("Массив"), Потребности.Скопировать(СтрокиДляОбработки), СтрокиДляОбработки),
		ПараметрыВыборки);
	
	Если ПараметрыРазузлования.РезервПФСоСклада Тогда
		ЗаменятьПФНаАналоги = Ложь;
		//++ НЕ УТКА
		ЗаменятьПФНаАналоги = ПараметрыРазузлования.ЗаменятьПФНаАналоги;
		//-- НЕ УТКА
		ОчередьПодбораПФ = НовыйОчередьПодбораПолуфабрикатов(ЗаменятьПФНаАналоги);
		
		Если РезервыПФ = Неопределено Тогда
			РезервыПФ = НовыйРезервыПолуфабрикатов();
		КонецЕсли;
	Иначе
		ОчередьПодбораПФ = Неопределено;
	КонецЕсли;
	
	Идентификатор = ?(Идентификатор = Неопределено, Потребности.Количество(), Идентификатор);
	ОчередьРазузлования = Новый Массив;
	
	Для Индекс = 0 По СтрокиДляОбработки.Количество()-1 Цикл
		
		Потребность = СтрокиДляОбработки[Индекс];
		ДанныеСпецификации = ДанныеСпецификаций[Потребность.Идентификатор]; // См. Справочники.РесурсныеСпецификации.ДанныеСпецификацииКонструктор
		
		ДанныеПоНоменклатуре = Справочники.РесурсныеСпецификации.ДанныеПоНоменклатуреРасширенный();
		ЗаполнитьЗначенияСвойств(ДанныеПоНоменклатуре, Потребность);
		ПартияВыпуска = Справочники.РесурсныеСпецификации.РассчитатьПартиюВыпускаПоНоменклатуре(
			ДанныеПоНоменклатуре, ДанныеСпецификации, ПараметрыВыборки);
		
		РассчитатьКоличествоНаПартиюВыпуска(
			ПараметрыРазузлования, ПартияВыпуска, ДанныеСпецификации, ДанныеПоНоменклатуре);
		
		// Поля заполняются при расчете нормативного графика
		ДанныеСпецификации.Этапы.Колонки.Добавить("КодЭтапа", 
			Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		ДанныеСпецификации.Этапы.Колонки.Добавить("ДатаОтгрузки",
			Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
		ДанныеСпецификации.Этапы.Колонки.Добавить("НеОтгружатьЧастями", Новый ОписаниеТипов("Булево"));
		
		Потребность.ДанныеСпецификации = ДанныеСпецификации;
		Потребность.ПартияВыпуска = ПартияВыпуска;
		Потребность.МаксимальныйСрокПролеживания = ДанныеСпецификации.МаксимальныйСрокПролеживанияВДнях * 86400;
		Потребность.ЭтоРазборка =
			ДанныеСпецификации.ТипПроизводственногоПроцесса = Перечисления.ТипыПроизводственныхПроцессов.Разборка;
		Потребность.ЭтоРемонт = 
			ДанныеСпецификации.ТипПроизводственногоПроцесса = Перечисления.ТипыПроизводственныхПроцессов.Ремонт;
		Потребность.ЭтоТолкающаяСхема = Потребность.ЭтоРазборка 
			ИЛИ (Потребность.ЭтоРемонт И Не Потребность.ЭтоВходящаяПотребность);
		
		#Область ДополнениеСвязей
		//++ НЕ УТКА
		Для каждого Вход Из Потребность.Входы Цикл
			Если ДанныеСпецификации.ВходящиеИзделия.Количество() = 1 Тогда
				
				Строка = ДанныеСпецификации.ВходящиеИзделия[0];
				Строка.Обособленно = Истина;
				Строка.Производится = Истина;
				
				Вход.СтрокаРС = Строка;
				Вход.СтрокаРСИмяВладельца = "ВходящиеИзделия";
				
				Если ЗначениеЗаполнено(Вход.Связь) Тогда
					Вход.Связь.СвязьЭтап = Строка.Этап;
				Иначе
					// Связи "один к одному" может не быть если ремонтируемое изделие введено несколькими строками
					СвПотребность = Потребности.Найти(Вход.СвязьИдентификатор, "Идентификатор");
					Для каждого Выход Из СвПотребность.Выходы.НайтиСтроки(
							Новый Структура("СвязьИдентификатор", Потребность.Идентификатор)) Цикл
						Выход.СвязьЭтап = Строка.Этап;
					КонецЦикла;
				КонецЕсли;
				
			Иначе
				
				Если ЗначениеЗаполнено(Вход.Связь) Тогда
					Вход.Связь.Владелец().Удалить(Вход.Связь);
				Иначе
					// Связи "один к одному" может не быть если ремонтируемое изделие введено несколькими строками
					СвПотребность = Потребности.Найти(Вход.СвязьИдентификатор, "Идентификатор");
					Для каждого Выход Из СвПотребность.Выходы.НайтиСтроки(
							Новый Структура("СвязьИдентификатор", Потребность.Идентификатор)) Цикл
						СвПотребность.Выходы.Удалить(Выход);
					КонецЦикла;
				КонецЕсли;
				Потребность.Входы.Удалить(Вход);
				
			КонецЕсли;
		КонецЦикла;
		//-- НЕ УТКА
		
		Для каждого Выход Из Потребность.Выходы Цикл
			НайденныеСтроки = ДанныеСпецификации.ВыходныеИзделия.НайтиСтроки(
				Новый Структура("Номенклатура, Характеристика",
					Выход.Связь.СтрокаРС.Номенклатура, Выход.Связь.СтрокаРС.Характеристика));
			Если НайденныеСтроки.Количество() = 1 Тогда
				Выход.СтрокаРС = НайденныеСтроки[0];
				Выход.СтрокаРСИмяВладельца = "ВыходныеИзделия";
				Выход.Связь.СвязьЭтап = НайденныеСтроки[0].Этап;
			Иначе
				Выход.Связь.Владелец().Удалить(Выход.Связь);
				Потребность.Выходы.Удалить(Выход);
			КонецЕсли;
		КонецЦикла;
		#КонецОбласти
		
		СтрокиДляРазузлования = СтрокиСпецификацииДляРазузлования(ДанныеСпецификации);
		
		Для каждого Данные Из СтрокиДляРазузлования Цикл
			
			// Контроль зацикливания спецификаций
			Родитель = Потребность;
			Пока Родитель <> Неопределено Цикл
				Если Родитель.Спецификация = Данные.Спецификация Тогда
					ВызватьИсключение СтрШаблон(
						НСтр("ru = 'В процессе разузлования изделий обнаружено зацикливание на спецификации ""%1"".';
							|en = 'Loop on the ""%1"" BOM is detected during product explosion.'"),
						Потребность.Спецификация);
				КонецЕсли;
				Родитель = Родитель.Родитель
			КонецЦикла;
			
			// Добавление потребности
			Строка = Данные.Строка;
			
			Если НЕ Данные.ЭтоРазборка Тогда
				ТребуетсяУточнитьМатериал = НЕ ЗначениеЗаполнено(Строка.Номенклатура)
					ИЛИ НЕ ЗначениеЗаполнено(Строка.Характеристика) И Строка.ХарактеристикиИспользуются
					ИЛИ НЕ ЗначениеЗаполнено(Строка.Количество);
				Если ТребуетсяУточнитьМатериал Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			Идентификатор = Идентификатор + 1;
			
			НоваяСтрока = Потребности.Добавить();
			
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Потребность,
				"ПодразделениеДиспетчер,
				|НаправлениеДеятельности,
				|НачалоПроизводства,
				|ДатаЗапуска,
				|ДатаВыпуска,
				|РазмещениеВыпуска"
					+ ?(ПустаяСтрока(ПараметрыРазузлования.ПоляГруппировки), "", "," + ПараметрыРазузлования.ПоляГруппировки)
					+ ?(ПустаяСтрока(ПараметрыРазузлования.ДополнительнаяИнформация), "", "," + ПараметрыРазузлования.ДополнительнаяИнформация)
					+ ?(ПустаяСтрока(ПараметрыРазузлования.РезервПФИмяПоляНазначение), "", "," + ПараметрыРазузлования.РезервПФИмяПоляНазначение));
			
			// Округление штучно-мерных товаров
			Если Не (Данные.ЭтоРазборка ИЛИ Данные.ЭтоРемонт ИЛИ Данные.ЭтоРабота)
					И Строка.Округлить
					И Цел(Строка.Количество) <> Строка.Количество Тогда
				НоваяСтрока.Количество = Цел(Строка.Количество) + 1;
			КонецЕсли;
			
			НоваяСтрока.Спецификация = Данные.Спецификация;
			НоваяСтрока.Идентификатор = Идентификатор;
			НоваяСтрока.Входы = НовыйСвязиПотребностей();
			НоваяСтрока.Выходы = НовыйСвязиПотребностей();
			НоваяСтрока.Обеспечение = НовыйОбеспечениеПотребности();
			НоваяСтрока.Родитель = Потребность;
			НоваяСтрока.Уровень = ?(Данные.ЭтоРазборка, Потребность.Уровень+1, Потребность.Уровень-1);
			НоваяСтрока.Порядок = ?(Данные.ЭтоРазборка ИЛИ Данные.ЭтоРемонт, 200000, 0);
			//++ НЕ УТКА
			НоваяСтрока.Аналоги = НовыйАналогиПотребности();
			//-- НЕ УТКА
			
			#Область ПостроениеСвязей
			Если Данные.ЭтоРазборка Тогда
				
				Связь1 = Потребность.Выходы.Добавить();
				Связь1.СтрокаРС = Строка;
				Связь1.СтрокаРСИмяВладельца = Данные.СтрокаРСИмяВладельца;
				Связь1.СвязьИдентификатор = Идентификатор;
				
				Связь2 = НоваяСтрока.Входы.Добавить();
				Связь2.СвязьЭтап = Строка.Этап;
				Связь2.СвязьИдентификатор = Потребность.Идентификатор;
				Связь2.Родитель = Истина;
				Связь2.Связь = Связь1;
				
				Связь1.Связь = Связь2;
				
			Иначе
				
				// Сборка и Ремонт
				Связь1 = Потребность.Входы.Добавить();
				Связь1.СтрокаРС = Строка;
				Связь1.СтрокаРСИмяВладельца = Данные.СтрокаРСИмяВладельца;
				Связь1.СвязьИдентификатор = Идентификатор;
				
				Связь2 = НоваяСтрока.Выходы.Добавить();
				Связь2.СвязьЭтап = Строка.Этап;
				Связь2.СвязьИдентификатор = Потребность.Идентификатор;
				Связь2.Родитель = Истина;
				Связь2.Связь = Связь1;
				
				Связь1.Связь = Связь2;
				
				Если Данные.ЭтоРемонт Тогда
					
					// ремонтируемое изделие - передача
					СтруктураПоиска = Новый Структура("Номенклатура, Характеристика, Этап",
						Строка.Номенклатура, Строка.Характеристика, Строка.ИсточникПолученияПолуфабриката);
					НайденныеСтроки = ДанныеСпецификации.ВозвратныеОтходы.НайтиСтроки(СтруктураПоиска);
					Связь1 = Неопределено;
					
					Для каждого СтрокаВыпуск Из НайденныеСтроки Цикл
						Связь1 = Потребность.Выходы.Добавить();
						Связь1.СтрокаРС = СтрокаВыпуск;
						Связь1.СтрокаРСИмяВладельца = "ВозвратныеОтходы";
						Связь1.СвязьИдентификатор = Идентификатор;
					КонецЦикла;
					
					// ремонтируемое изделие - получение
					Связь2 = НоваяСтрока.Входы.Добавить();
					Связь2.СвязьЭтап = Строка.ИсточникПолученияПолуфабриката;
					Связь2.СвязьИдентификатор = Потребность.Идентификатор;
					Связь2.Родитель = Истина;
					
					Если НайденныеСтроки.Количество() = 1 Тогда
						Связь2.Связь = Связь1;
						Связь1.Связь = Связь2;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			#КонецОбласти
			
			ОчередьРазузлования.Добавить(НоваяСтрока);
			
			Если ОчередьПодбораПФ <> Неопределено
				И Не (Данные.ЭтоРазборка ИЛИ Данные.ЭтоРемонт ИЛИ Данные.ЭтоРабота) Тогда
				
				СтрокаПодбор = ОчередьПодбораПФ.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаПодбор, Строка);
				СтрокаПодбор.Идентификатор = ОчередьРазузлования.ВГраница();
				СтрокаПодбор.Назначение = ?(ПустаяСтрока(ПараметрыРазузлования.РезервПФИмяПоляНазначение),
					Неопределено,
					Потребность[ПараметрыРазузлования.РезервПФИмяПоляНазначение]);
				СтрокаПодбор.Обособленно = ЗначениеЗаполнено(СтрокаПодбор.Назначение);
				СтрокаПодбор.Необособленно = НЕ ПараметрыРазузлования.РезервПФТолькоОбособленно;
				
				//++ НЕ УТКА
				Если ПараметрыРазузлования.ЗаменятьПФНаАналоги Тогда
					
					СтрокаПодбор.Спецификация = Потребность.Спецификация;
					СтрокаПодбор.Изделие = Потребность.ДанныеСпецификации.ОсновноеИзделие.Номенклатура;
					СтрокаПодбор.ХарактеристикаИзделия = Потребность.ДанныеСпецификации.ОсновноеИзделие.Характеристика;
					СтрокаПодбор.Подразделение = Строка.ПодразделениеЭтапа;
					
					Если Потребности.Колонки.Найти("Распоряжение") <> Неопределено Тогда
						СтрокаПодбор.ЗаказНаПроизводство = Потребность.Распоряжение;
					КонецЕсли;
					Если Потребности.Колонки.Найти("НаправлениеДеятельности") <> Неопределено Тогда
						СтрокаПодбор.НаправлениеДеятельности = Потребность.НаправлениеДеятельности;
					КонецЕсли;
					
				КонецЕсли;
				//-- НЕ УТКА
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Подбор остатков и аналогов ПФ
	Если ЗначениеЗаполнено(ОчередьПодбораПФ) Тогда
		
		ОчередьПодбораПФ.Индексы.Добавить("Идентификатор");
		
		Если ПараметрыРазузлования.РезервПФСоСклада Тогда
			ПодобратьОстаткиПолуфабрикатов(ОчередьРазузлования, ОчередьПодбораПФ, РезервыПФ);
		КонецЕсли;
		
		//++ НЕ УТКА
		Если ПараметрыРазузлования.ЗаменятьПФНаАналоги
				И ЗначениеЗаполнено(ОчередьПодбораПФ) Тогда
			ПодобратьАналогиПолуфабрикатов(ОчередьРазузлования, ОчередьПодбораПФ, РезервыПФ);
		КонецЕсли;
		//-- НЕ УТКА
		
		Для Индекс = -ОчередьРазузлования.ВГраница() По 0 Цикл
			Потребность = ОчередьРазузлования[-Индекс];
			Если Потребность.Количество = 0 Тогда
				Таблица = Потребность.Выходы[0].Связь.Владелец(); // ТаблицаЗначений
				Таблица.Удалить(Потребность.Выходы[0].Связь);
				
				Таблица = Потребность.Владелец(); // ТаблицаЗначений
				Таблица.Удалить(Потребность);
				
				ОчередьРазузлования.Удалить(-Индекс);
			КонецЕсли;
		КонецЦикла;
		
		РезервыПФ.Свернуть("Номенклатура,Характеристика,Склад,Назначение", "Количество");
		
	КонецЕсли;
	
	// Рекурсивное разузлование
	Если ОчередьРазузлования.ВГраница() <> -1 Тогда
		РазузловатьПотребностиРекурсивно(
			Потребности, ОчередьРазузлования, ПараметрыРазузлования, ПараметрыВыборки, Идентификатор, РезервыПФ);
	КонецЕсли;
	
КонецПроцедуры

Функция СтрокиСпецификацииДляРазузлования(ДанныеСпецификации)
	
	Результат = Новый ТаблицаЗначений;
	
	Результат.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Результат.Колонки.Добавить("СтрокаРСИмяВладельца", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки));
	Результат.Колонки.Добавить("Спецификация", Новый ОписаниеТипов("СправочникСсылка.РесурсныеСпецификации"));
	Результат.Колонки.Добавить("ЭтоРазборка", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЭтоРемонт", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЭтоРабота", Новый ОписаниеТипов("Булево"));
	
	// Материалы - сборка и ремонт
	СтруктураПоиска = Новый Структура("ПроизводитсяВПроцессе", Истина);
	
	Для каждого Строка Из ДанныеСпецификации.МатериалыИУслуги.НайтиСтроки(СтруктураПоиска) Цикл
		
		Если Строка.СпособПолученияМатериала = Перечисления.СпособыПолученияМатериаловВСпецификации.ПроизвестиПоСпецификации Тогда
			
			Если Строка.Спецификация.Пустая() Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Не удалось подобрать спецификацию для материала в строке %1 (спецификация ""%2"")';
						|en = 'Cannot pick the specification for the material in the line %1 (specification ""%2"")'"),
					Строка.НомерСтроки,
					ДанныеСпецификации.Спецификация);
			КонецЕсли;
			
			НоваяСтрока = Результат.Добавить();
			НоваяСтрока.Строка = Строка;
			НоваяСтрока.СтрокаРСИмяВладельца = "МатериалыИУслуги";
			НоваяСтрока.Спецификация = Строка.Спецификация;
			НоваяСтрока.ЭтоРабота = Строка.ТипНоменклатуры = Перечисления.ТипыНоменклатуры.Работа;
			
			// Переопределение данных спецификации -
			// производимые полуфабрикаты обеспечиваются обособленно
			Строка.Обособленно = Истина;
			
		ИначеЕсли Строка.СпособПолученияМатериала = Перечисления.СпособыПолученияМатериаловВСпецификации.ПроизводитсяНаЭтапе
			И НЕ Строка.СпецификацияРемонта.Пустая() Тогда
			
			НоваяСтрока = Результат.Добавить();
			НоваяСтрока.Строка = Строка;
			НоваяСтрока.СтрокаРСИмяВладельца = "МатериалыИУслуги";
			НоваяСтрока.Спецификация = Строка.СпецификацияРемонта;
			НоваяСтрока.ЭтоРемонт = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Выходные изделия - разборка
	СтруктураПоиска = Новый Структура("ОбработатьПоСпецификации", Истина);
	
	Для каждого Строка Из ДанныеСпецификации.ВыходныеИзделия.НайтиСтроки(СтруктураПоиска) Цикл
			
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Строка = Строка;
		НоваяСтрока.СтрокаРСИмяВладельца = "ВыходныеИзделия";
		НоваяСтрока.Спецификация = Строка.Спецификация;
		НоваяСтрока.ЭтоРазборка = Истина;
		
	КонецЦикла;
	
	// Возвратные отходы - разборка
	Для каждого Строка Из ДанныеСпецификации.ВозвратныеОтходы.НайтиСтроки(СтруктураПоиска) Цикл
		
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Строка = Строка;
		НоваяСтрока.СтрокаРСИмяВладельца = "ВозвратныеОтходы";
		НоваяСтрока.Спецификация = Строка.Спецификация;
		НоваяСтрока.ЭтоРазборка = Истина;
			
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Уменьшает потребности в полуфабрикатах на величину складских остатков.
// 
// Параметры:
// 	СтрокиПотребности - Массив - строки таблицы потребностей.
// 	Материалы - см. НовыйОчередьПодбораПолуфабрикатов.
// 	Резервы - см. НовыйРезервыПолуфабрикатов.
//
Процедура ПодобратьОстаткиПолуфабрикатов(СтрокиПотребности, Материалы, Резервы)
	
	// Получение данных
	Тексты = Новый Массив();
	
	Тексты.Добавить(
		"ВЫБРАТЬ
		|	Материалы.Идентификатор  КАК Идентификатор,
		|	Материалы.Номенклатура   КАК Номенклатура,
		|	Материалы.Характеристика КАК Характеристика,
		|	Материалы.Склад          КАК Склад,
		|	Материалы.Назначение     КАК Назначение,
		|	Материалы.Количество     КАК Количество,
		|	Материалы.Обособленно    КАК Обособленно,
		|	Материалы.Необособленно  КАК Необособленно
		|ПОМЕСТИТЬ ВТМатериалы
		|ИЗ
		|	&Материалы КАК Материалы
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	Номенклатура,
		|	Характеристика,
		|	Склад,
		|	Назначение
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	Резервы.Номенклатура   КАК Номенклатура,
		|	Резервы.Характеристика КАК Характеристика,
		|	Резервы.Склад          КАК Склад,
		|	Резервы.Назначение     КАК Назначение,
		|	Резервы.Количество     КАК Количество
		|ПОМЕСТИТЬ ВТРезервы
		|ИЗ
		|	&Резервы КАК Резервы
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	Номенклатура,
		|	Характеристика,
		|	Склад,
		|	Назначение
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	Материалы.Номенклатура КАК Номенклатура,
		|	Материалы.Характеристика КАК Характеристика,
		|	Материалы.Склад КАК Склад,
		|	Материалы.Назначение КАК Назначение
		|ПОМЕСТИТЬ ФильтрМатериаловДляПолученияОстатков
		|ИЗ
		|	ВТМатериалы КАК Материалы
		|ГДЕ
		|	Материалы.Обособленно
		|		И Материалы.Назначение <> ЗНАЧЕНИЕ(Справочник.Назначения.ПустаяСсылка)
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	Материалы.Номенклатура КАК Номенклатура,
		|	Материалы.Характеристика КАК Характеристика,
		|	Материалы.Склад КАК Склад,
		|	ЗНАЧЕНИЕ(Справочник.Назначения.ПустаяСсылка) КАК Назначение
		|ИЗ
		|	ВТМатериалы КАК Материалы
		|ГДЕ
		|	Материалы.Необособленно
		|ИНДЕКСИРОВАТЬ ПО
		|	Номенклатура, Характеристика, Склад, Назначение");
	
	Тексты.Добавить(
		ОбеспечениеВДокументахСервер.ВременнаяТаблицаСвободныеОстатки(
			"ФильтрМатериаловДляПолученияОстатков",
			"ТаблицаОстатков"));
	
	Тексты.Добавить(
		"ВЫБРАТЬ
		|	ВТМатериалы.Идентификатор  КАК Идентификатор,
		|	ВТМатериалы.Номенклатура   КАК Номенклатура,
		|	ВТМатериалы.Характеристика КАК Характеристика,
		|	ВТМатериалы.Склад          КАК Склад,
		|	ВТМатериалы.Назначение     КАК Назначение,
		|	ВТМатериалы.Количество     КАК Количество,
		|	ВЫБОР
		|		КОГДА ЕСТЬNULL(ОстаткиОбособленно.Количество, 0) - ЕСТЬNULL(РезервыОбособленно.Количество, 0) > 0
		|			ТОГДА
		|				ЕСТЬNULL(ОстаткиОбособленно.Количество, 0) - ЕСТЬNULL(РезервыОбособленно.Количество, 0)
		|		ИНАЧЕ 0
		|	КОНЕЦ КАК ОстатокОбособленно,
		|	ВЫБОР
		|		КОГДА ЕСТЬNULL(ОстаткиНеобособленно.Количество, 0) - ЕСТЬNULL(РезервыНеобособленно.Количество, 0) > 0
		|			ТОГДА
		|				ЕСТЬNULL(ОстаткиНеобособленно.Количество, 0) - ЕСТЬNULL(РезервыНеобособленно.Количество, 0)
		|		ИНАЧЕ 0
		|	КОНЕЦ КАК ОстатокНеобособленно
		|ИЗ
		|	ВТМатериалы КАК ВТМатериалы
		|
		|		ЛЕВОЕ СОЕДИНЕНИЕ ТаблицаОстатков КАК ОстаткиОбособленно
		|		ПО ВТМатериалы.Номенклатура = ОстаткиОбособленно.Номенклатура
		|			И ВТМатериалы.Характеристика = ОстаткиОбособленно.Характеристика
		|			И ВТМатериалы.Склад = ОстаткиОбособленно.Склад
		|			И ВТМатериалы.Назначение = ОстаткиОбособленно.Назначение
		|			И ВТМатериалы.Обособленно
		|
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТРезервы КАК РезервыОбособленно
		|		ПО ВТМатериалы.Номенклатура = РезервыОбособленно.Номенклатура
		|			И ВТМатериалы.Характеристика = РезервыОбособленно.Характеристика
		|			И ВТМатериалы.Склад = РезервыОбособленно.Склад
		|			И ВТМатериалы.Назначение = РезервыОбособленно.Назначение
		|			И ВТМатериалы.Обособленно
		|
		|		ЛЕВОЕ СОЕДИНЕНИЕ ТаблицаОстатков КАК ОстаткиНеобособленно
		|		ПО ВТМатериалы.Номенклатура = ОстаткиНеобособленно.Номенклатура
		|			И ВТМатериалы.Характеристика = ОстаткиНеобособленно.Характеристика
		|			И ВТМатериалы.Склад = ОстаткиНеобособленно.Склад
		|			И (ОстаткиНеобособленно.Назначение = ЗНАЧЕНИЕ(Справочник.Назначения.ПустаяСсылка))
		|			И ВТМатериалы.Необособленно
		|
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТРезервы КАК РезервыНеобособленно
		|		ПО ВТМатериалы.Номенклатура = РезервыНеобособленно.Номенклатура
		|			И ВТМатериалы.Характеристика = РезервыНеобособленно.Характеристика
		|			И ВТМатериалы.Склад = РезервыНеобособленно.Склад
		|			И (РезервыНеобособленно.Назначение = ЗНАЧЕНИЕ(Справочник.Назначения.ПустаяСсылка))
		|			И ВТМатериалы.Необособленно
		|
		|УПОРЯДОЧИТЬ ПО
		|	Номенклатура,
		|	Характеристика,
		|	Склад,
		|	Назначение,
		|	Идентификатор");
	
	Запрос = Новый Запрос();
	Запрос.Текст = СтрСоединить(Тексты, ОбщегоНазначения.РазделительПакетаЗапросов());
	
	Запрос.УстановитьПараметр("Материалы", Материалы);
	Запрос.УстановитьПараметр("Резервы", Резервы);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	Остатки = РезультатЗапроса.Выгрузить();
	ПредыдущаяСтрока = Остатки[0];
	
	// Обработка данных
	Для Индекс = 0 По Остатки.Количество()-1 Цикл
		
		Строка = Остатки[Индекс];
		
		// Наследование остатков
		Если Строка.Номенклатура = ПредыдущаяСтрока.Номенклатура
			И Строка.Характеристика = ПредыдущаяСтрока.Характеристика
			И Строка.Склад = ПредыдущаяСтрока.Склад Тогда
			
			Строка.ОстатокНеобособленно = ПредыдущаяСтрока.ОстатокНеобособленно;
			
			Если Строка.Назначение = ПредыдущаяСтрока.Назначение Тогда
				Строка.ОстатокОбособленно = ПредыдущаяСтрока.ОстатокОбособленно;
			КонецЕсли;
			
		КонецЕсли;
		
		КоличествоЗачет = 0;
		
		Потребность = СтрокиПотребности[Строка.Идентификатор];
		СтрокаОбеспечение = Потребность.Выходы[0].Связь.СтрокаРС; // СтрокаТаблицыЗначений
		СтрокаОбеспечениеИндекс = СтрокаОбеспечение.Владелец().Индекс(СтрокаОбеспечение);
		
		// Обособленный остаток
		Если Строка.ОстатокОбособленно <> 0 Тогда
			
			Количество = Мин(Строка.Количество, Строка.ОстатокОбособленно);
			
			Строка.Количество = Строка.Количество - Количество;
			Строка.ОстатокОбособленно = Строка.ОстатокОбособленно - Количество;
			КоличествоЗачет = КоличествоЗачет + Количество;
			
			// Добавление сведений об обеспечении в родительскую потребность
			ТаблицаОбеспечение = Потребность.Родитель.Обеспечение; // ТаблицаЗначений
			НоваяСтрока = ТаблицаОбеспечение.Добавить();
			НоваяСтрока.СтрокаИндекс = СтрокаОбеспечениеИндекс;
			НоваяСтрока.Количество = Количество;
			НоваяСтрока.Обособленно = Истина;
			
			// Добавление резервов - они учитываются при следующих вызовах
			НоваяСтрока = Резервы.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка,, "Количество");
			НоваяСтрока.Количество = Количество;
			
		КонецЕсли;
		
		// Необособленный остаток
		Если Строка.ОстатокНеобособленно <> 0 И Строка.Количество <> 0 Тогда
			
			Количество = Мин(Строка.Количество, Строка.ОстатокНеобособленно);
			
			Строка.Количество = Строка.Количество - Количество;
			Строка.ОстатокНеобособленно = Строка.ОстатокНеобособленно - Количество;
			КоличествоЗачет = КоличествоЗачет + Количество;
			
			// Добавление сведений об обеспечении в родительскую потребность
			ТаблицаОбеспечение = Потребность.Родитель.Обеспечение; // ТаблицаЗначений
			НоваяСтрока = ТаблицаОбеспечение.Добавить();
			НоваяСтрока.СтрокаИндекс = СтрокаОбеспечениеИндекс;
			НоваяСтрока.Количество = Количество;
			НоваяСтрока.Обособленно = Ложь;
			
			// Добавление резервов - они учитываются при следующих вызовах
			НоваяСтрока = Резервы.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка,, "Количество, Назначение");
			НоваяСтрока.Количество = Количество;
			
		КонецЕсли;
		
		// Уменьшение потребности
		Потребность.Количество = Потребность.Количество - КоличествоЗачет;
		
		СтрокаМатериал = Материалы.Найти(Строка.Идентификатор, "Идентификатор");
		Если СтрокаМатериал.Количество = КоличествоЗачет Тогда
			Материалы.Удалить(СтрокаМатериал);
		Иначе
			СтрокаМатериал.Количество = СтрокаМатериал.Количество - КоличествоЗачет;
		КонецЕсли;
		
		ПредыдущаяСтрока = Строка;
		
	КонецЦикла;
	
КонецПроцедуры

//++ НЕ УТКА

Процедура ПодобратьАналогиПолуфабрикатов(СтрокиПотребности, ТаблицаМатериалов, РезервыПФ)
	
	Аналоги = АналогиМатериалов.ПолучитьТаблицуЗаменыДляФормированияЭтапов(
		ТаблицаМатериалов.Скопировать(,
			"Идентификатор, Номенклатура, Характеристика, Подразделение,
			|НаправлениеДеятельности, ЗаказНаПроизводство, Спецификация,
			|Изделие, ХарактеристикаИзделия, Количество"),
		РезервыПФ);
	Аналоги.Сортировать("Идентификатор, Разрешение", Новый СравнениеЗначений());
	
	ТаблицаМатериалов.Индексы.Добавить("Идентификатор");
	
	Если Аналоги.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияЗаполнения = Аналоги[0];
	Для Индекс = 0 По Аналоги.Количество()-1 Цикл
		
		Аналог = Аналоги[Индекс];
		
		// Добавление резервов - они учитываются при следующих вызовах
		НоваяСтрока = РезервыПФ.Добавить();
		ЗаполнитьЗначенияСвойств(
			НоваяСтрока,
			ТаблицаМатериалов.Найти(Аналог.Идентификатор, "Идентификатор"),
			,
			"Номенклатура,Характеристика,Склад,Назначение,Количество");
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Аналог, "Номенклатура,Характеристика,Склад,Количество");
		
		Потребность = СтрокиПотребности[Аналог.Идентификатор];
		СтрокаОбеспечение = Потребность.Выходы[0].Связь.СтрокаРС; // СтрокаТаблицыЗначений
		СтрокаОбеспечениеИндекс = СтрокаОбеспечение.Владелец().Индекс(СтрокаОбеспечение);
		
		// Добавление сведений об обеспечении в родительскую потребность
		ТаблицаАналоги = Потребность.Родитель.Аналоги; // ТаблицаЗначений
		НоваяСтрока = ТаблицаАналоги.Добавить();
		НоваяСтрока.СтрокаИндекс = СтрокаОбеспечениеИндекс;
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Аналог, "Разрешение, Номенклатура, Характеристика, Склад, Количество");
		
		Если Индекс = 0
			ИЛИ ЗначенияЗаполнения.Идентификатор <> Аналог.Идентификатор
			ИЛИ ЗначенияЗаполнения.Разрешение <> Аналог.Разрешение Тогда
			
			ЗначенияЗаполнения = Аналог;
			
			ТаблицаОбеспечение = Потребность.Родитель.Обеспечение; // ТаблицаЗначений
			НоваяСтрока = ТаблицаОбеспечение.Добавить();
			НоваяСтрока.СтрокаИндекс   = СтрокаОбеспечениеИндекс;
			НоваяСтрока.Количество     = Аналог.КоличествоЗамены;
			НоваяСтрока.Обособленно    = Ложь; // Аналоги подбираются только в необособленном остатке
			НоваяСтрока.Разрешение     = Аналог.Разрешение;
			НоваяСтрока.ЗаменаНаАналог = Истина;
			
			// Уменьшение потребности
			Потребность.Количество = Потребность.Количество - Аналог.КоличествоЗамены;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры
//-- НЕ УТКА

Функция РазделитьПотребностиНаПартии(Потребности, ПараметрыРазузлования)
	
	Результат = Новый Массив;
	
	Входы = Новый ТаблицаЗначений;
	Входы.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Входы.Колонки.Добавить("Этап", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	Входы.Колонки.Добавить("СтрокаРС", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Входы.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Входы.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Входы.Колонки.Добавить("КодЭтапа", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Входы.Колонки.Добавить("ДанныеСпецификации", Новый ОписаниеТипов("Структура"));
	
	Выходы = Новый ТаблицаЗначений;
	Выходы.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Выходы.Колонки.Добавить("Этап", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	Выходы.Колонки.Добавить("СтрокаРС", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Выходы.Колонки.Добавить("СтрокаРСИмяВладельца", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки));
	Выходы.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Выходы.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Выходы.Колонки.Добавить("ДанныеСпецификации", Новый ОписаниеТипов("Структура"));
	Выходы.Колонки.Добавить("Потребность", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	
	СтПоискаПФНаЭтапе = Новый Структура("СпособПолученияМатериала, СпецификацияРемонта",
		Перечисления.СпособыПолученияМатериаловВСпецификации.ПроизводитсяНаЭтапе,
		Справочники.РесурсныеСпецификации.ПустаяСсылка());
	СтПоискаНХЭтап = Новый Структура("Номенклатура, Характеристика, Этап");
	//++ НЕ УТКА
	СтПоискаАналоги = Новый Структура("СтрокаИндекс, Разрешение");
	//-- НЕ УТКА
	
	Потребности.Сортировать("Порядок, Начало, Окончание, Уровень, Номенклатура, Характеристика, Спецификация, Назначение, Получатель, Отправитель");
	
	КодЭтапа = 10000000;
	ИдентификаторВыпускаНаЭтапе = 10000000;
	Для ИндексПотребность = 0 По Потребности.Количество()-1 Цикл
		
		Потребность = Потребности[ИндексПотребность];
		Если Потребность.Свернута Тогда
			Продолжить;
		КонецЕсли;
		
		ВсегоПартий = 1;
		Если ПараметрыРазузлования.РазделятьНаОптимальныеПартии
				И Потребность.ПартияВыпуска.Расшифровка <> Неопределено Тогда
			ВсегоПартий = Потребность.ПартияВыпуска.Расшифровка.Количество();
		КонецЕсли;
		
		Для СчПартий = 1 По ВсегоПартий Цикл
			
			// Заполнение партии
			Если ВсегоПартий = 1 Тогда
				ДанныеСпецификации = Потребность.ДанныеСпецификации;
				ПартияВыпуска = Потребность.ПартияВыпуска;
			Иначе
				ДанныеСпецификации = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(Потребность.ДанныеСпецификации);
				
				ПартияВыпуска = Потребность.ПартияВыпуска.Расшифровка[СчПартий-1];
				ДанныеПоНоменклатуре = Справочники.РесурсныеСпецификации.ДанныеПоНоменклатуреРасширенный();
				ЗаполнитьЗначенияСвойств(ДанныеПоНоменклатуре, Потребность);
				Справочники.РесурсныеСпецификации.РассчитатьКоличествоНаПартиюВыпуска(ПартияВыпуска, ДанныеСпецификации, ДанныеПоНоменклатуре);
				
				Для каждого Этап Из ДанныеСпецификации.Этапы Цикл
					Этап.КодЭтапа = КодЭтапа;
					КодЭтапа = КодЭтапа + 1;
				КонецЦикла;
			КонецЕсли;
			
			ДобавитьПоляВДанныеСпецификации(ДанныеСпецификации, ПараметрыРазузлования);
			
			ЗаполнитьЗначенияСвойств(
				ДанныеСпецификации,
				Потребность,
				"ДатаЗапуска, ДатаВыпуска, Начало, Окончание, РазмещениеВыпуска"
				+ ?(ПустаяСтрока(ПараметрыРазузлования.ПоляГруппировки), "", "," + ПараметрыРазузлования.ПоляГруппировки)
				+ ?(ПустаяСтрока(ПараметрыРазузлования.ДополнительнаяИнформация), "", "," + ПараметрыРазузлования.ДополнительнаяИнформация));
			
			ДанныеСпецификации.ПартияВыпуска = ПартияВыпуска;
			
			Если ДанныеСпецификации.ВыходныеИзделия.Количество() <> 0 Тогда
				ДанныеСпецификации.ВыходныеИзделия.ЗагрузитьКолонку(
					ДанныеСпецификации.ВыходныеИзделия.ВыгрузитьКолонку("Склад"), "Получатель");
			КонецЕсли;
			Если ДанныеСпецификации.ВозвратныеОтходы.Количество() <> 0 Тогда
				ДанныеСпецификации.ВозвратныеОтходы.ЗагрузитьКолонку(
					ДанныеСпецификации.ВозвратныеОтходы.ВыгрузитьКолонку("Склад"), "Получатель");
			КонецЕсли;
			
			// Заполнение реквизитов по входящим данным
			Для Индекс = 0 По Потребность.СвернутыеВходящиеПотребности.Количество() Цикл
				ВхПотребность = ?(Индекс = 0,
					?(Потребность.ЭтоВходящаяПотребность, Потребность, Неопределено),
					Потребность.СвернутыеВходящиеПотребности[Индекс - 1]);
				Если ВхПотребность = Неопределено ИЛИ ВхПотребность.Количество = 0 Тогда
					Продолжить;
				КонецЕсли;
				
				//++ НЕ УТКА
				Если ВхПотребность.ЭтоРазборка Тогда
					
					Для каждого Строка Из ДанныеСпецификации.ВходящиеИзделия Цикл
						
						Если Строка.Распределено = Строка.Количество
							ИЛИ Строка.Номенклатура <> ВхПотребность.Номенклатура
							ИЛИ Строка.Характеристика <> ВхПотребность.Характеристика
								И ЗначениеЗаполнено(Строка.Характеристика)
								И НЕ Строка.ЛюбаяХарактеристика Тогда
							Продолжить;
						КонецЕсли;
						
						Если ВхПотребность.Количество >= Строка.Количество Тогда
							СтрокаЗаполнить = Строка;
						Иначе
							НоваяСтрока = ДанныеСпецификации.ВходящиеИзделия.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
							НоваяСтрока.Количество = ВхПотребность.Количество;
							НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество
								* НоваяСтрока.ДанныеУпаковки.Знаменатель / НоваяСтрока.ДанныеУпаковки.Числитель;
							СтрокаЗаполнить = НоваяСтрока;
								
							Строка.Количество = Строка.Количество - ВхПотребность.Количество;
							Строка.КоличествоУпаковок = Строка.Количество
								* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
						КонецЕсли;
						
						Если ЗначениеЗаполнено(ВхПотребность.Отправитель) Тогда
							СтрокаЗаполнить.Склад = ВхПотребность.Отправитель;
						КонецЕсли;
						СтрокаЗаполнить.Характеристика = ВхПотребность.Характеристика;
						Если ЗначениеЗаполнено(ВхПотребность.ЭтапИсточник) Тогда
							СтрокаЗаполнить.ЭтапОтправитель = ВхПотребность.ЭтапИсточник;
							СтрокаЗаполнить.Обособленно = Истина;
							СтрокаЗаполнить.Производится = Истина;
						КонецЕсли;
						СтрокаЗаполнить.Распределено = СтрокаЗаполнить.Количество;
						
						ВхПотребность.Количество = ВхПотребность.Количество - СтрокаЗаполнить.Количество;
						Если ВхПотребность.Количество = 0 Тогда
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
				Иначе // Сборка и ремонт

				//-- НЕ УТКА
					
					Для Сч = 1 По 2 Цикл
						Для каждого Строка Из ДанныеСпецификации[?(Сч = 1, "ВыходныеИзделия", "ВозвратныеОтходы")] Цикл
							Если Строка.Распределено = Строка.Количество
								ИЛИ Строка.Номенклатура <> ВхПотребность.Номенклатура
								ИЛИ Строка.Характеристика <> ВхПотребность.Характеристика
									И ЗначениеЗаполнено(Строка.Характеристика)
									И НЕ Строка.ЛюбаяХарактеристика Тогда
								Продолжить;
							КонецЕсли;
							
							Распределено = Мин(Строка.Количество-Строка.Распределено, ВхПотребность.Количество);
							
							Если (Строка.Распределено = 0
									И ВхПотребность.Количество >= Строка.Количество)
								ИЛИ (СтрокиИдентичны(Строка, ВхПотребность,
										"Характеристика,Получатель,Назначение,СписатьНаРасходы,СтатьяРасходов,АналитикаРасходов,АналитикаАктивовПассивов")
									И Строка.ЭтапПотребитель = ВхПотребность.ЭтапИсточник) Тогда
								
								// Разделять строку не нужно
								СтрокаЗаполнить = Строка;
								
							ИначеЕсли Строка.Округлить
								И НЕ Строка.ЭтоЦеховаяКладовая
								И Окр(Строка.Количество - Распределено) <> (Строка.Количество - Распределено) Тогда
								
								// При разделении строки будут нарушены правила округления
								Если Строка.Распределено = 0 Тогда
									Строка.Округлить = Ложь;
									СтрокаЗаполнить = Строка;
								Иначе
									ВладелецСтроки = Строка.Владелец(); // ТаблицаЗначений
									НоваяСтрока = ВладелецСтроки.Добавить();
									ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
									НоваяСтрока.Количество = Строка.Количество - Строка.Распределено;
									НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество
										* НоваяСтрока.ДанныеУпаковки.Знаменатель / НоваяСтрока.ДанныеУпаковки.Числитель;
									НоваяСтрока.Распределено = 0;
									НоваяСтрока.Округлить = Ложь;
									СтрокаЗаполнить = НоваяСтрока;
									
									Строка.Количество = Строка.Распределено;
									Строка.КоличествоУпаковок = Строка.Количество
										* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
									Если Сч = 1 Тогда
										ПроизводствоКлиентСервер.ПересчитатьДолюСтоимостиПриРазбиенииСтроки(
											НоваяСтрока, Строка, ДанныеСпецификации.СпособРаспределенияЗатратНаВыходныеИзделия);
									КонецЕсли;
								КонецЕсли;
								
							Иначе
								
								// Разделение строки
								ВладелецСтроки = Строка.Владелец(); // ТаблицаЗначений
								НоваяСтрока = ВладелецСтроки.Добавить();
								ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
								НоваяСтрока.Количество = Распределено;
								НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество
									* НоваяСтрока.ДанныеУпаковки.Знаменатель / НоваяСтрока.ДанныеУпаковки.Числитель;
								НоваяСтрока.Распределено = 0;
								СтрокаЗаполнить = НоваяСтрока;
								
								Строка.Количество = Строка.Количество - Распределено;
								Строка.КоличествоУпаковок = Строка.Количество
									* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
								Если Сч = 1 Тогда
									ПроизводствоКлиентСервер.ПересчитатьДолюСтоимостиПриРазбиенииСтроки(
										НоваяСтрока, Строка, ДанныеСпецификации.СпособРаспределенияЗатратНаВыходныеИзделия);
								КонецЕсли;
								
							КонецЕсли;
							
							ЗаполнитьЗначенияСвойств(СтрокаЗаполнить, ВхПотребность,
								"Характеристика,Получатель,Назначение,СписатьНаРасходы,СтатьяРасходов,АналитикаРасходов,АналитикаАктивовПассивов");
							СтрокаЗаполнить.ЭтапПотребитель = ВхПотребность.ЭтапИсточник;
							СтрокаЗаполнить.Распределено = СтрокаЗаполнить.Распределено + Распределено;
							
							ВхПотребность.Количество = ВхПотребность.Количество - Распределено;
							Если ВхПотребность.Количество = 0 Тогда
								Прервать;
							КонецЕсли;
							
						КонецЦикла;
						Если ВхПотребность.Количество = 0 Тогда
							Прервать;
						КонецЕсли;
					КонецЦикла;
				
				//++ НЕ УТКА	
				КонецЕсли;
				//-- НЕ УТКА
				
			КонецЦикла;
			
			// Зачет данных обеспечения
			Свертка = Новый Соответствие;
			МатериалыУдалить = Новый Массив;
			Для каждого Обеспечение Из Потребность.Обеспечение Цикл
				Строка = ДанныеСпецификации.МатериалыИУслуги[Обеспечение.СтрокаИндекс];
				Если Обеспечение.Количество = 0 ИЛИ Строка.Количество = 0 ИЛИ НЕ Строка.Производится Тогда
					Продолжить;
				КонецЕсли;
				
				КоличествоЗачет = Мин(Строка.Количество, Обеспечение.Количество);
				
			//++ НЕ УТКА
				Если Обеспечение.ЗаменаНаАналог Тогда
					
					// Обеспечение через замену на аналоги
					ЗаполнитьЗначенияСвойств(СтПоискаАналоги, Обеспечение);
					Для каждого Аналог Из Потребность.Аналоги.НайтиСтроки(СтПоискаАналоги) Цикл
						НоваяСтрока = ДанныеСпецификации.МатериалыИУслуги.Добавить();
						ЗаполнитьЗначенияСвойств(НоваяСтрока, Аналог, "Номенклатура,Характеристика,Склад");
						ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка, "Этап,ПодразделениеЭтапа");
						Если Обеспечение.Количество = КоличествоЗачет Тогда
							НоваяСтрока.Количество = Аналог.Количество;
						Иначе
							НоваяСтрока.Количество = ОКР(Аналог.Количество * КоличествоЗачет / Обеспечение.Количество, 3);
							Аналог.Количество = Аналог.Количество - НоваяСтрока.Количество;
						КонецЕсли;
						НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество;
						НоваяСтрока.Обособленно = Обеспечение.Обособленно;
						НоваяСтрока.ВариантОбеспечения = Перечисления.ВариантыОбеспечения.СоСклада;
						НоваяСтрока.Производится = Ложь;
					КонецЦикла;
					
					Строка.Количество = Строка.Количество - КоличествоЗачет;
					Если Строка.Количество = 0 Тогда
						Строка.Производится = Ложь;
						Строка.ПроизводитсяВПроцессе = Ложь;
						МатериалыУдалить.Добавить(Строка);
					Иначе
						// При замене на аналоги исходная строка переводится в базовую ед. изм.
						Строка.КоличествоУпаковок = Строка.Количество;
						Строка.Упаковка = Справочники.УпаковкиЕдиницыИзмерения.ПустаяСсылка();
					КонецЕсли;
					
				Иначе
			//-- НЕ УТКА
					
					// Обеспечение из остатков на складе
					СтрокаЗаполнить = Неопределено;
					Если Строка.Количество = КоличествоЗачет Тогда
						СтрокаЗаполнить = Строка;
					Иначе
						НоваяСтрока = ДанныеСпецификации.МатериалыИУслуги.Добавить();
						ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
						НоваяСтрока.Количество = КоличествоЗачет;
						НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество
							* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
						
						СтрокаЗаполнить = НоваяСтрока;
						
						Строка.Количество = Строка.Количество - КоличествоЗачет;
						Строка.КоличествоУпаковок = Строка.Количество
							* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
					КонецЕсли;
					
					СтрокаЗаполнить.Производится = Ложь;
					СтрокаЗаполнить.ПроизводитсяВПроцессе = Ложь;
					СтрокаЗаполнить.ИсточникПолученияПолуфабриката = Справочники.РесурсныеСпецификации.ПустаяСсылка();
					//++ Устарело_Производство21
					СтрокаЗаполнить.СпособПолученияПолуфабриката = Перечисления.СпособыПолученияМатериаловВСпецификации.ПустаяСсылка();
					//-- Устарело_Производство21
					СтрокаЗаполнить.Спецификация = Справочники.РесурсныеСпецификации.ПустаяСсылка();
					СтрокаЗаполнить.Обособленно = Обеспечение.Обособленно;
					СтрокаЗаполнить.ВариантОбеспечения = Перечисления.ВариантыОбеспечения.СоСклада;
					
			//++ НЕ УТКА	
				КонецЕсли;
			//-- НЕ УТКА
				
				Обеспечение.Количество = Обеспечение.Количество - КоличествоЗачет;
			КонецЦикла;
			
			// Добавление выходов
			Для каждого Связь Из Потребность.Выходы Цикл
				Связь.Связь = Неопределено; // Разрыв циклических ссылок
				
				Если ВсегоПартий = 1 Тогда
					СтрокаРС = Связь.СтрокаРС;
				Иначе
					ТаблицаРС = Связь.СтрокаРС.Владелец(); // ТаблицаЗначений
					СтрокаРС = ДанныеСпецификации[Связь.СтрокаРСИмяВладельца][ТаблицаРС.Индекс(Связь.СтрокаРС)];
				КонецЕсли;
				
				Выход = Выходы.Добавить();
				Выход.Идентификатор = Связь.СвязьИдентификатор;
				Выход.Этап = Связь.СвязьЭтап;
				Выход.СтрокаРС = СтрокаРС;
				Выход.СтрокаРСИмяВладельца = Связь.СтрокаРСИмяВладельца;
				Выход.Номенклатура = Связь.СтрокаРС.Номенклатура;
				Выход.Характеристика = Связь.СтрокаРС.Характеристика;
				Выход.ДанныеСпецификации = ДанныеСпецификации;
				Выход.Потребность = Потребность;
			КонецЦикла;
			
			// Добавление входов
			Для каждого Связь Из Потребность.Входы Цикл
				Связь.Связь = Неопределено; // Разрыв циклических ссылок
				
				Если ВсегоПартий = 1 Тогда
					СтрокаРС = Связь.СтрокаРС;
				Иначе
					ТаблицаРС = Связь.СтрокаРС.Владелец(); // ТаблицаЗначений
					СтрокаРС = ДанныеСпецификации[Связь.СтрокаРСИмяВладельца][ТаблицаРС.Индекс(Связь.СтрокаРС)];
				КонецЕсли;
				Если Связь.Родитель                  // Связи с родительскими потребностями добавляются через входящие изделия
					ИЛИ НЕ СтрокаРС.Производится Тогда // Потребность закрыта обеспечением
					Продолжить; 
				КонецЕсли;
				
				Вход = Входы.Добавить();
				Вход.Идентификатор = Потребность.Идентификатор;
				Вход.Этап = СтрокаРС.Этап;
				Вход.СтрокаРС = СтрокаРС;
				Вход.Номенклатура = Связь.СтрокаРС.Номенклатура;
				Вход.Характеристика = Связь.СтрокаРС.Характеристика;
				Вход.КодЭтапа = ДанныеСпецификации.Этапы.Найти(Вход.СтрокаРС.Этап, "Этап").КодЭтапа;
				Вход.ДанныеСпецификации = ДанныеСпецификации;
			КонецЦикла;
			//++ НЕ УТКА
			Для каждого Строка Из ДанныеСпецификации.ВходящиеИзделия Цикл
				Если Строка.Распределено = Строка.Количество Тогда
					Продолжить;
				КонецЕсли;
				Вход = Входы.Добавить();
				Вход.Идентификатор = Потребность.Идентификатор;
				Вход.Этап = Строка.Этап;
				Вход.СтрокаРС = Строка;
				Вход.Номенклатура = Строка.Номенклатура;
				Вход.Характеристика = Строка.Характеристика;
				Вход.КодЭтапа = ДанныеСпецификации.Этапы.Найти(Строка.Этап, "Этап").КодЭтапа;
				Вход.ДанныеСпецификации = ДанныеСпецификации;
			КонецЦикла;
			//-- НЕ УТКА
			
			// Добавление связей по ПФ, производимым на этапе
			Для каждого Строка Из ДанныеСпецификации.МатериалыИУслуги.НайтиСтроки(СтПоискаПФНаЭтапе) Цикл
				Вход = Входы.Добавить();
				Вход.Идентификатор = ИдентификаторВыпускаНаЭтапе;
				Вход.Этап = Строка.Этап;
				Вход.СтрокаРС = Строка;
				Вход.Номенклатура = Строка.Номенклатура;
				Вход.Характеристика = Строка.Характеристика;
				Вход.КодЭтапа = ДанныеСпецификации.Этапы.Найти(Строка.Этап, "Этап").КодЭтапа;
				Вход.ДанныеСпецификации = ДанныеСпецификации;
				
				СтПоискаНХЭтап.Номенклатура = Строка.Номенклатура;
				СтПоискаНХЭтап.Характеристика = Строка.Характеристика;
				СтПоискаНХЭтап.Этап = Строка.ИсточникПолученияПолуфабриката;
				
				Для каждого СтрокаВыход Из ДанныеСпецификации.ВозвратныеОтходы.НайтиСтроки(СтПоискаНХЭтап) Цикл
					Выход = Выходы.Добавить();
					Выход.Идентификатор = ИдентификаторВыпускаНаЭтапе;
					Выход.Этап = Строка.Этап;
					Выход.СтрокаРС = СтрокаВыход;
					Выход.СтрокаРСИмяВладельца = "ВозвратныеОтходы";
					Выход.Номенклатура = СтрокаВыход.Номенклатура;
					Выход.Характеристика = СтрокаВыход.Характеристика;
					Выход.ДанныеСпецификации = ДанныеСпецификации;
					Выход.Потребность = Потребность;
				КонецЦикла;
				
				ИдентификаторВыпускаНаЭтапе = ИдентификаторВыпускаНаЭтапе + 1;
			КонецЦикла;
			
			Для каждого Строка Из МатериалыУдалить Цикл
				ДанныеСпецификации.МатериалыИУслуги.Удалить(Строка);
			КонецЦикла;
			
			Результат.Добавить(ДанныеСпецификации);
		КонецЦикла;
	КонецЦикла;
	
	// Построение связей
	Входы.Сортировать("Идентификатор, Этап, Номенклатура, Характеристика", Новый СравнениеЗначений());
	Выходы.Сортировать("Идентификатор, Этап, Номенклатура, Характеристика", Новый СравнениеЗначений());
	ИндВыход = 0;
	ИндВыходМакс = Выходы.Количество()-1;
	
	Для ИндВход = 0 По Входы.Количество()-1 Цикл
		Вход = Входы[ИндВход];
		Остаток = Вход.СтрокаРС.Количество;
		ИндВыход = ?(ИндВыход <= ИндВыходМакс, ИндВыход, 0);
		Пока ИндВыход <= ИндВыходМакс Цикл
			Выход = Выходы[ИндВыход];
			
			Если Выход.СтрокаРС.Распределено = Выход.СтрокаРС.Количество
				ИЛИ Выход.СтрокаРС.Количество = 0
				ИЛИ Выход.Идентификатор <> Вход.Идентификатор
				ИЛИ Выход.Этап <> Вход.Этап
				ИЛИ Выход.Номенклатура <> Вход.Номенклатура
				ИЛИ Выход.Характеристика <> Вход.Характеристика
					И ЗначениеЗаполнено(Выход.Характеристика) Тогда
				ИндВыход = ИндВыход + 1;
				Продолжить;
			КонецЕсли;
			
			Если Не Выход.Потребность.ПланироватьНеРанее.Пустая() Тогда // Привязка к этапу ПланироватьНеРанее
				Выход.ДанныеСпецификации.ПланироватьНеРанееКодЭтапа =
					Вход.ДанныеСпецификации.Этапы.Найти(Выход.Потребность.ПланироватьНеРанее, "Этап").КодЭтапа;
			КонецЕсли;
			
			Если Выход.СтрокаРС.Распределено <> 0 
				ИЛИ Выход.СтрокаРС.Количество > Остаток Тогда
				СтрокаВыход = Выход.СтрокаРС.Владелец().Вставить(0);
				ЗаполнитьЗначенияСвойств(СтрокаВыход, Выход.СтрокаРС);
				СтрокаВыход.Количество = Мин((Выход.СтрокаРС.Количество-Выход.СтрокаРС.Распределено), Остаток);
				СтрокаВыход.КоличествоУпаковок = СтрокаВыход.Количество * СтрокаВыход.ДанныеУпаковки.Знаменатель / СтрокаВыход.ДанныеУпаковки.Числитель;
				
				Выход.СтрокаРС.Количество = Выход.СтрокаРС.Количество - СтрокаВыход.Количество;
				Выход.СтрокаРС.КоличествоУпаковок = Выход.СтрокаРС.Количество * Выход.СтрокаРС.ДанныеУпаковки.Знаменатель / Выход.СтрокаРС.ДанныеУпаковки.Числитель;
				
				Если Выход.СтрокаРСИмяВладельца = "ВыходныеИзделия" Тогда
					ПроизводствоКлиентСервер.ПересчитатьДолюСтоимостиПриРазбиенииСтроки(
						СтрокаВыход, Выход.СтрокаРС, ДанныеСпецификации.СпособРаспределенияЗатратНаВыходныеИзделия);
				КонецЕсли;
				
				// Контроль соблюдения правил округления
				Если Выход.СтрокаРС.Округлить
					И Окр(Выход.СтрокаРС.Количество) <> Выход.СтрокаРС.Количество Тогда
					
					Если Выход.СтрокаРС.Распределено = 0 Тогда
						Выход.СтрокаРС.Получатель = Вход.СтрокаРС.Склад;
						Выход.СтрокаРС.Округлить = Ложь;
					ИначеЕсли Выход.СтрокаРС.Количество > Выход.СтрокаРС.Распределено Тогда
						НоваяСтрока = Выход.СтрокаРС.Владелец().Вставить(0);
						ЗаполнитьЗначенияСвойств(НоваяСтрока, Выход.СтрокаРС);
						НоваяСтрока.Количество = Выход.СтрокаРС.Количество - Выход.СтрокаРС.Распределено;
						НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество * НоваяСтрока.ДанныеУпаковки.Знаменатель / НоваяСтрока.ДанныеУпаковки.Числитель;
						НоваяСтрока.Распределено = 0;
						НоваяСтрока.Получатель = Вход.СтрокаРС.Склад;
						НоваяСтрока.Округлить = Ложь;
						
						Выход.СтрокаРС.Количество = Выход.СтрокаРС.Распределено;
						Выход.СтрокаРС.КоличествоУпаковок = Выход.СтрокаРС.Количество * Выход.СтрокаРС.ДанныеУпаковки.Знаменатель / Выход.СтрокаРС.ДанныеУпаковки.Числитель;
						
						Если Выход.СтрокаРСИмяВладельца = "ВыходныеИзделия" Тогда
							ПроизводствоКлиентСервер.ПересчитатьДолюСтоимостиПриРазбиенииСтроки(
								НоваяСтрока, Выход.СтрокаРС, ДанныеСпецификации.СпособРаспределенияЗатратНаВыходныеИзделия);
						КонецЕсли;
					КонецЕсли;	
				КонецЕсли;
			Иначе
				СтрокаВыход = Выход.СтрокаРС;
				ИндВыход = ИндВыход + 1;
			КонецЕсли;
			
			СтрокаВыход.Получатель = ?(Вход.СтрокаРС.ТипНоменклатуры = Перечисления.ТипыНоменклатуры.Работа,
				Вход.СтрокаРС.ПодразделениеЭтапа,
				Вход.СтрокаРС.Склад);
			СтрокаВыход.КодЭтапаПолучателя = Вход.КодЭтапа;
			СтрокаВыход.Распределено = СтрокаВыход.Количество;
			
			Если Выход.СтрокаРС.ЛюбаяХарактеристика
				И Не ЗначениеЗаполнено(Выход.Характеристика) Тогда
				СтрокаВыход.Характеристика = Вход.СтрокаРС.Характеристика;
			КонецЕсли;
			
			Остаток = Остаток - СтрокаВыход.Количество;
			Если Остаток = 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ДобавитьПоляВДанныеСпецификации(ДанныеСпецификации, ПараметрыРазузлования)
	
	ДанныеСпецификации.Вставить("ДатаЗапуска");
	ДанныеСпецификации.Вставить("ДатаВыпуска");
	ДанныеСпецификации.Вставить("Начало");
	ДанныеСпецификации.Вставить("Окончание");
	ДанныеСпецификации.Вставить("РазмещениеВыпуска");
	ДанныеСпецификации.Вставить("ПартияВыпуска");
	ДанныеСпецификации.Вставить("ПланироватьНеРанееКодЭтапа");
	
	Если ПараметрыРазузлования.ГруппироватьДанные Тогда
		Для каждого Поле Из СтрРазделить(ПараметрыРазузлования.ПоляГруппировки, ",", Ложь) Цикл
			ДанныеСпецификации.Вставить(Поле);
		КонецЦикла;
		Для каждого Поле Из СтрРазделить(ПараметрыРазузлования.ДополнительнаяИнформация, ",", Ложь) Цикл
			ДанныеСпецификации.Вставить(Поле);
		КонецЦикла;
	КонецЕсли;
	
	ТипыПолучатель = Новый Массив;
	ТипыПолучатель.Добавить(Тип("СправочникСсылка.СтруктураПредприятия"));
	ТипыПолучатель.Добавить(Тип("СправочникСсылка.Склады"));
	ОТПолучатель = Новый ОписаниеТипов(ТипыПолучатель);
		
	ОТЭтап = Новый ОписаниеТипов("Неопределено");
	//++ НЕ УТКА
	ОТЭтап = Новый ОписаниеТипов("ДокументСсылка.ЭтапПроизводства2_2");
	//-- НЕ УТКА
	
	ТипыСтатей = Новый Массив;
	ТипыСтатей.Добавить(Тип("ПланВидовХарактеристикСсылка.СтатьиРасходов"));
	ТипыСтатей.Добавить(Тип("ПланВидовХарактеристикСсылка.СтатьиАктивовПассивов"));
	ОТСтатьяРасходов = Новый ОписаниеТипов(ТипыСтатей);
	
	// Выходные изделия и возвратные отходы
	Для Сч = 1 По 2 Цикл
		
		Таблица = ДанныеСпецификации[?(Сч = 1, "ВыходныеИзделия", "ВозвратныеОтходы")]; // ТаблицаЗначений
		Таблица.Колонки.Добавить("Назначение", Новый ОписаниеТипов("СправочникСсылка.Назначения"));
		Таблица.Колонки.Добавить("ЭтапПотребитель", ОТЭтап);
		Таблица.Колонки.Добавить("Получатель", ОТПолучатель);
		Таблица.Колонки.Добавить("Распределено", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		Таблица.Колонки.Добавить("КодЭтапаПолучателя", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		Таблица.Колонки.Добавить("СписатьНаРасходы", Новый ОписаниеТипов("Булево"));
		Таблица.Колонки.Добавить("СтатьяРасходов", ОТСтатьяРасходов);
		Таблица.Колонки.Добавить("АналитикаРасходов", Метаданные.ПланыВидовХарактеристик.СтатьиРасходов.Тип);
		Таблица.Колонки.Добавить("АналитикаАктивовПассивов",
			Метаданные.ПланыВидовХарактеристик.СтатьиАктивовПассивов.Тип);
		
	КонецЦикла;
	
	//++ НЕ УТКА

	// Входящие изделия
	Таблица = ДанныеСпецификации.ВходящиеИзделия; // ТаблицаЗначений
	Таблица.Колонки.Добавить("ЭтапОтправитель", ОТЭтап);
	Таблица.Колонки.Добавить("Распределено", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	//-- НЕ УТКА
	
КонецПроцедуры

Процедура ПроверитьКорректностьСпецификаций(Спецификации, ОписаниеОшибки)
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ЭтапыПроизводства.Владелец               КАК Спецификация,
		|	ЭтапыПроизводства.Владелец.Представление КАК СпецификацияПредставление,
		|	ИСТИНА                                   КАК НесколькоВыпускающихЭтапов,
		|	ЛОЖЬ                                     КАК Недействует
		|ИЗ
		|	Справочник.ЭтапыПроизводства КАК ЭтапыПроизводства
		|ГДЕ
		|	ЭтапыПроизводства.Владелец В(&Спецификации)
		|	И ЭтапыПроизводства.ПометкаУдаления = ЛОЖЬ
		|	И ЭтапыПроизводства.НомерСледующегоЭтапа = 0
		|	И ЭтапыПроизводства.Владелец.ТипПроизводственногоПроцесса <> ЗНАЧЕНИЕ(Перечисление.ТипыПроизводственныхПроцессов.Разборка)
		|
		|СГРУППИРОВАТЬ ПО
		|	ЭтапыПроизводства.Владелец,
		|	ЭтапыПроизводства.Владелец.Представление
		|
		|ИМЕЮЩИЕ
		|	КОЛИЧЕСТВО(ЭтапыПроизводства.Ссылка) > 1
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	РесурсныеСпецификации.Ссылка               КАК Спецификация,
		|	РесурсныеСпецификации.Ссылка.Представление КАК СпецификацияПредставление,
		|	ЛОЖЬ                                       КАК НесколькоВыпускающихЭтапов,
		|	ИСТИНА                                     КАК Недействует
		|ИЗ
		|	Справочник.РесурсныеСпецификации КАК РесурсныеСпецификации
		|ГДЕ
		|	РесурсныеСпецификации.Ссылка В(&Спецификации)
		|	И РесурсныеСпецификации.Статус <> ЗНАЧЕНИЕ(Перечисление.СтатусыСпецификаций.Действует)");
	
	Запрос.УстановитьПараметр("Спецификации", Спецификации);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		
		ОписаниеОшибки.ЕстьОшибка = Истина;
		ОписаниеОшибки.ОшибкаСсылка = Выборка.Спецификация;
		
		Если Выборка.НесколькоВыпускающихЭтапов Тогда
			ОписаниеОшибки.ОшибкаТекст = СтрШаблон(
					НСтр("ru = 'Спецификация ""%1"" содержит несколько выпускающих этапов';
						|en = 'The ""%1"" BOM contains several release stages'"),
					Выборка.СпецификацияПредставление);
		ИначеЕсли Выборка.Недействует Тогда
			ОписаниеОшибки.ОшибкаТекст = СтрШаблон(
					НСтр("ru = 'Спецификация ""%1"" не находится в статусе ""Действует""';
						|en = 'The bill of materials ""%1"" is not ""Valid""'"),
					Выборка.СпецификацияПредставление);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура РассчитатьКоличествоНаПартиюВыпуска(ПараметрыРазузлования, ПартияВыпуска, ДанныеСпецификации, ДанныеПоНоменклатуре)
	
	Справочники.РесурсныеСпецификации.РассчитатьКоличествоНаПартиюВыпуска(
		ПартияВыпуска,
		ДанныеСпецификации,
		ДанныеПоНоменклатуре);
	
	// Пересчет ТЧ в которых количество номенклатуры округляется
	Если ПараметрыРазузлования.РазделятьНаОптимальныеПартии
		И ПартияВыпуска.Расшифровка <> Неопределено
		И ПартияВыпуска.Расшифровка.Количество() > 1 Тогда
		
		ДанныеСпецификацииКопия = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ДанныеСпецификации);
		
		Таблицы = СтрРазделить("ВыходныеИзделия,ВозвратныеОтходы,ВходящиеИзделия,МатериалыИУслуги", ",");
		Для каждого Таблица Из Таблицы Цикл
			ДанныеСпецификации[Таблица].ЗаполнитьЗначения(0, "Количество,КоличествоУпаковок");
		КонецЦикла;
		
		Для каждого ПартияВыпускаРасшифровка Из ПартияВыпуска.Расшифровка Цикл
			
			Справочники.РесурсныеСпецификации.РассчитатьКоличествоНаПартиюВыпуска(
				ПартияВыпускаРасшифровка,
				ДанныеСпецификацииКопия,
				ДанныеПоНоменклатуре);
			
			Для каждого Таблица Из Таблицы Цикл
				Для Индекс = 0 По ДанныеСпецификации[Таблица].Количество()-1 Цикл
					ДанныеСпецификации[Таблица][Индекс].Количество = ДанныеСпецификации[Таблица][Индекс].Количество
						+ ДанныеСпецификацииКопия[Таблица][Индекс].Количество;
					ДанныеСпецификации[Таблица][Индекс].КоличествоУпаковок = ДанныеСпецификации[Таблица][Индекс].КоличествоУпаковок
						+ ДанныеСпецификацииКопия[Таблица][Индекс].КоличествоУпаковок;
				КонецЦикла;
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Функция СтрокиИдентичны(Строка1, Строка2, ИменаКолонок)
	
	Для каждого Колонка Из СтрРазделить(ИменаКолонок, ",") Цикл
		Если Строка1[Колонка] <> Строка2[Колонка] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#Область Конструкторы

// Возвращаемое значение:
// 	ТаблицаЗначений:
// * Строка - СтрокаТаблицыЗначений -
// * СтрокаРСИмяВладельца - Строка -
// * Связь - СтрокаТаблицыЗначений из см. НовыйСвязиПотребностей
// * СвязьИдентификатор - Число -
// * СвязьЭтап - СправочникСсылка.ЭтапыПроизводства -
// * Родитель - Булево -
Функция НовыйСвязиПотребностей()
	
	Результат = Новый ТаблицаЗначений;
	
	// Строка таблицы данных спецификации - источник/приемник связи
	Результат.Колонки.Добавить("СтрокаРС", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	
	// Имя табличной части, которой принадлежит строка
	Результат.Колонки.Добавить("СтрокаРСИмяВладельца", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки));
	
	// Строка таблицы связей, противоположная данной строке
	// Пример: если данная строка - это выход, то поле ссылается на строку-вход
	// Так же связи являются перекрестными - в примере выше строка-вход в содержит ссылку на данную строку
	Результат.Колонки.Добавить("Связь", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	
	// Идентификатор связанной потребности
	Результат.Колонки.Добавить("СвязьИдентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	// Этап связанной потребности - приемник/источник связи
	Результат.Колонки.Добавить("СвязьЭтап", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	
	// Если Истина то связь ссылается на родительскую потребность
	Результат.Колонки.Добавить("Родитель", Новый ОписаниеТипов("Булево"));
	
	Возврат Результат;
	
КонецФункции

Функция НовыйОбеспечениеПотребности()
	
	Результат = Новый ТаблицаЗначений;
	
	// Индекс строки тч МатериалыИУслуги к которой относятся данные обеспечения
	Результат.Колонки.Добавить("СтрокаИндекс", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	// Данные обеспечения
	Результат.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	// При обеспечении из остатков на складе
	Результат.Колонки.Добавить("Обособленно", Новый ОписаниеТипов("Булево"));
	
	//++ НЕ УТКА

	// При обеспечении посредством замены на аналоги
	Результат.Колонки.Добавить("Разрешение", Новый ОписаниеТипов("ДокументСсылка.РазрешениеНаЗаменуМатериалов"));
	Результат.Колонки.Добавить("ЗаменаНаАналог", Новый ОписаниеТипов("Булево"));
	//-- НЕ УТКА
	
	Возврат Результат;
	
КонецФункции

// Возвращаемое значение:
// 	ТаблицаЗначений - Описание:
// * Номенклатура - СправочникСсылка.Номенклатура -
// * Характеристика - СправочникСсылка.ХарактеристикиНоменклатуры -
// * Склад - СправочникСсылка.Склады -
// * Подразделение - СправочникСсылка.СтруктураПредприятия -
// * Назначение - СправочникСсылка.Назначения -
// * ТипНоменклатуры - ПеречислениеСсылка.ТипыНоменклатуры -
// * ВариантОбеспечения - ПеречислениеСсылка.ВариантыОбеспечения -
// * ДатаОтгрузки - Дата -
// * ДатаОтгрузкиРабот - Дата -
// * Количество - Число -
Функция НовыйРезервыПолуфабрикатов()
	
	Результат = Новый ТаблицаЗначений;
	
	Результат.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Результат.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Результат.Колонки.Добавить("Склад", Новый ОписаниеТипов("СправочникСсылка.Склады"));
	Результат.Колонки.Добавить("Назначение", Новый ОписаниеТипов("СправочникСсылка.Назначения"));
	Результат.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 3)));
	
	Возврат Результат;
	
КонецФункции

// Возвращаемое значение:
// 	ТаблицаЗначений:
// * Идентификатор - Число
Функция НовыйОчередьПодбораПолуфабрикатов(ЗаменятьПФНаАналоги)
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Результат.Колонки.Добавить("Обособленно", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("Необособленно", Новый ОписаниеТипов("Булево"));
	
	Результат.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Результат.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Результат.Колонки.Добавить("Склад", Новый ОписаниеТипов("СправочникСсылка.Склады"));
	Результат.Колонки.Добавить("Назначение", Новый ОписаниеТипов("СправочникСсылка.Назначения"));
	Результат.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 3)));
	
	//++ НЕ УТКА
	Если ЗаменятьПФНаАналоги Тогда
		Результат.Колонки.Добавить("Подразделение", Новый ОписаниеТипов("СправочникСсылка.СтруктураПредприятия"));
		Результат.Колонки.Добавить("НаправлениеДеятельности", Новый ОписаниеТипов("СправочникСсылка.НаправленияДеятельности"));
		Результат.Колонки.Добавить("ЗаказНаПроизводство", Новый ОписаниеТипов("ДокументСсылка.ЗаказНаПроизводство2_2"));
		Результат.Колонки.Добавить("Спецификация", Новый ОписаниеТипов("СправочникСсылка.РесурсныеСпецификации"));
		Результат.Колонки.Добавить("Изделие", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Результат.Колонки.Добавить("ХарактеристикаИзделия", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	КонецЕсли;
	//-- НЕ УТКА
	
	Возврат Результат;
	
КонецФункции

//++ НЕ УТКА

// Возвращаемое значение:
// 	ТаблицаЗначений
Функция НовыйАналогиПотребности()
	
	Результат = Новый ТаблицаЗначений;
	
	// Индекс строки тч МатериалыИУслуги к которой относятся данные обеспечения
	Результат.Колонки.Добавить("СтрокаИндекс", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Результат.Колонки.Добавить("Разрешение", Новый ОписаниеТипов("ДокументСсылка.РазрешениеНаЗаменуМатериалов"));
	Результат.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Результат.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Результат.Колонки.Добавить("Склад", Новый ОписаниеТипов("СправочникСсылка.Склады"));
	Результат.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	Возврат Результат;
	
КонецФункции

//-- НЕ УТКА

#КонецОбласти

//++ НЕ УТКА
#Область НормативныйГрафик

Процедура ЗаполнитьСрокиОбеспеченияПролеживанияПотребностей(Потребности)
	
	НормативныйГрафик = НормативныйГрафикПоТаблицеПотребностей(Потребности); // ТаблицаЗначений
	НормативныйГрафик.Индексы.Добавить("Идентификатор, ЭтапПроизводства");
	НормативныйГрафик.Индексы.Добавить("Идентификатор, Этап");
	
	СтПоискаКлюч = Новый Структура("Идентификатор, ЭтапПроизводства");
	СтПоискаСсылка = Новый Структура("Идентификатор, Этап");
	
	Для каждого Потребность Из Потребности Цикл
		
		ГраницаКНачалу = ?(Потребность.ДатаЗапуска >= ТекущаяДатаСеанса(),
			Потребность.ДатаЗапуска,
			ТекущаяДатаСеанса());
	    ГраницаКОкончанию = Потребность.ДатаВыпуска;
		
		Начало = '39991231';
		Окончание = '00010101';
		
		СтПоискаКлюч.Идентификатор = Потребность.Идентификатор;
		
		Для каждого Этап Из Потребность.ДанныеСпецификации.Этапы Цикл
			
			СтПоискаКлюч.ЭтапПроизводства = Этап.КодЭтапа;
			ЗаписьГрафика = НормативныйГрафик.НайтиСтроки(СтПоискаКлюч)[0];
			
			Этап.ДатаОтгрузки = ГраницаКНачалу + ЗаписьГрафика.ДлительностьДоЗапуска;
			Этап.НеОтгружатьЧастями = Истина;
			
			Если Этап.НомерЭтапа = 1 Тогда
				Если Потребность.РазмещениеВыпуска = Перечисления.СпособыПривязкиОперацийПроизводства.КНачалу Тогда
					Начало = Мин(Начало, ГраницаКНачалу + ЗаписьГрафика.ДлительностьДоЗапуска);
				Иначе
					Если ЗаписьГрафика.Ресурсоемкость > 0 Тогда
						Начало = Мин(Начало, ГраницаКОкончанию - Цел(ЗаписьГрафика.ДлительностьДоВыпуска) - ЗаписьГрафика.Ресурсоемкость);
					Иначе
						Начало = Мин(Начало, ГраницаКОкончанию - ЗаписьГрафика.ДлительностьДоВыпуска);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Если Этап.НомерСледующегоЭтапа = 0 Тогда
				Если Потребность.РазмещениеВыпуска = Перечисления.СпособыПривязкиОперацийПроизводства.КНачалу Тогда
					Если ЗаписьГрафика.Ресурсоемкость > 0 Тогда
						Окончание = Макс(Окончание, ГраницаКНачалу + Цел(ЗаписьГрафика.ДлительностьДоЗапуска) + ЗаписьГрафика.Ресурсоемкость);
					Иначе
						Окончание = Макс(Окончание, ГраницаКНачалу + ЗаписьГрафика.ДлительностьДоЗапуска);
					КонецЕсли;
				Иначе
					Окончание = Макс(Окончание, ГраницаКОкончанию - ЗаписьГрафика.ДлительностьДоВыпуска);
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
		Потребность.Начало = Начало;
		Потребность.Окончание = Окончание;
		
		// Срок пролеживания
		Если Потребность.ЭтоРемонт Тогда
			
			Если Не Потребность.ЭтоВходящаяПотребность Тогда
				СвязьРодитель = Потребность.Выходы.Найти(Истина, "Родитель");
				СтПоискаСсылка.Идентификатор = СвязьРодитель.СвязьИдентификатор;
				СтПоискаСсылка.Этап = СвязьРодитель.СвязьЭтап;
				ЭтапПолучатель = НормативныйГрафик.НайтиСтроки(СтПоискаСсылка)[0];
				Если Потребность.РазмещениеВыпуска = Перечисления.СпособыПривязкиОперацийПроизводства.КНачалу Тогда
					Потребность.СрокПролеживания = ГраницаКНачалу + ЭтапПолучатель.ДлительностьДоЗапуска;
				Иначе
					Потребность.СрокПролеживания = ГраницаКОкончанию - ЭтапПолучатель.ДлительностьДоВыпуска - ЭтапПолучатель.Ресурсоемкость;
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли Потребность.ДанныеСпецификации.ОграниченСрокПролеживания Тогда
			
			Если Потребность.ЭтоРазборка Тогда
				Потребность.СрокПролеживания = Начало + Потребность.МаксимальныйСрокПролеживания;
			Иначе
				Потребность.СрокПролеживания = Окончание - Потребность.МаксимальныйСрокПролеживания;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция НормативныйГрафикПоТаблицеПотребностей(Потребности)
	
	ЭтапыИЗависимости = ТаблицыДляРасчетаНормативногоГрафикаПроизводства(
		ОбщегоНазначенияУТ.ВыгрузитьЗначенияКолонки(Потребности, "Распоряжение"));
	Этапы       = ЭтапыИЗависимости.Этапы;
	Зависимости = ЭтапыИЗависимости.Зависимости;
	
	ЗаполнитьЭтапыПоТаблицеПотребностей(Потребности, Этапы);
	
	Индекс1 = Потребности.Индексы.Добавить("Идентификатор");
	Индекс2 = Этапы.Индексы.Добавить("ЭтапПроизводства");
	Индекс3 = Этапы.Индексы.Добавить("СвязанСЭтапомПроизводства");
	
	Для каждого Потребность Из Потребности Цикл
		
		ЗаполнитьВнутренниеЗависимостиЭтапов(Потребность.ДанныеСпецификации.Этапы, Зависимости);
		ЗаполнитьВнешниеЗависимостиПоТаблицеПотребностей(Потребности, Потребность, Зависимости);
		ЗаполнитьЗависимостиСоздаваемыхИСуществующихЭтапов(Этапы, Зависимости);
		
	КонецЦикла;
	
	Потребности.Индексы.Удалить(Индекс1);
	Этапы.Индексы.Удалить(Индекс2);
	Этапы.Индексы.Удалить(Индекс3);
	
	РегистрыСведений.НормативныйГрафикЭтаповПроизводства.РассчитатьГрафик(Этапы, Зависимости);
	
	Возврат Этапы;
	
КонецФункции

Функция ТаблицыДляРасчетаНормативногоГрафикаПроизводства(Распоряжения)
	
	Типы = Новый Массив;
	Типы.Добавить(Тип("ДокументСсылка.ЭтапПроизводства2_2"));
	Типы.Добавить(Тип("Число"));
	ОписаниеТиповЭтап = Новый ОписаниеТипов(Типы, Новый КвалификаторыЧисла);
	
	Этапы = Новый ТаблицаЗначений;
	Этапы.Колонки.Добавить("ЭтапПроизводства", ОписаниеТиповЭтап);
	Этапы.Колонки.Добавить("ЭтапИсточник", Новый ОписаниеТипов("ДокументСсылка.ЭтапПроизводства2_2"));
	Этапы.Колонки.Добавить("Этап", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	Этапы.Колонки.Добавить("Распоряжение", Новый ОписаниеТипов("ДокументСсылка.ЗаказНаПроизводство2_2"));
	Этапы.Колонки.Добавить("Ресурсоемкость", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Этапы.Колонки.Добавить("ЭтоРазборка", Новый ОписаниеТипов("Булево"));
	Этапы.Колонки.Добавить("ПервыйЭтап", Новый ОписаниеТипов("Булево"));
	Этапы.Колонки.Добавить("ПоследнийЭтап", Новый ОписаниеТипов("Булево"));
	Этапы.Колонки.Добавить("ДлительностьДоЗапуска", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(14, 4)));
	Этапы.Колонки.Добавить("ДлительностьДоВыпуска", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(14, 4)));
	Этапы.Колонки.Добавить("СвязанСЭтапомПроизводства", Новый ОписаниеТипов("Булево"));
	Этапы.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Этапы.Колонки.Добавить("НомерЭтапа", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Этапы.Колонки.Добавить("НомерСледующегоЭтапа", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	Зависимости = Новый ТаблицаЗначений;
	Зависимости.Колонки.Добавить("Этап", ОписаниеТиповЭтап);
	Зависимости.Колонки.Добавить("СледующийЭтап", ОписаниеТиповЭтап);
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	ЭтапПроизводства2_2.Ссылка                                        КАК ЭтапПроизводства,
		|	ВЫБОР ЭтапПроизводства2_2.ЕдиницаИзмеренияДлительностиЭтапа
		|		КОГДА ЗНАЧЕНИЕ(Перечисление.ЕдиницыИзмеренияВремени.Минута)
		|			ТОГДА 60
		|		КОГДА ЗНАЧЕНИЕ(Перечисление.ЕдиницыИзмеренияВремени.Час)
		|			ТОГДА 3600
		|		КОГДА ЗНАЧЕНИЕ(Перечисление.ЕдиницыИзмеренияВремени.День)
		|			ТОГДА 86400
		|		КОГДА ЗНАЧЕНИЕ(Перечисление.ЕдиницыИзмеренияВремени.Сутки)
		|			ТОГДА 86400
		|		ИНАЧЕ 1
		|	КОНЕЦ * ЭтапПроизводства2_2.ДлительностьЭтапа                     КАК Ресурсоемкость,
		|	НЕ ИСТИНА В
		|				(ВЫБРАТЬ 
		|					ИСТИНА
		|				ИЗ
		|					ВТСвязиЭтапов КАК Связи
		|				ГДЕ                       
		|					Связи.СледующийЭтап = ЭтапПроизводства2_2.Ссылка) КАК ПервыйЭтап,
		|	НЕ ИСТИНА В
		|				(ВЫБРАТЬ 
		|					ИСТИНА
		|				ИЗ
		|					ВТСвязиЭтапов КАК Связи
		|				ГДЕ                       
		|					Связи.Этап = ЭтапПроизводства2_2.Ссылка)          КАК ПоследнийЭтап
		|ИЗ
		|	Документ.ЭтапПроизводства2_2 КАК ЭтапПроизводства2_2
		|ГДЕ
		|	ЭтапПроизводства2_2.Распоряжение В (&Распоряжения)
		|	И ЭтапПроизводства2_2.Проведен
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВТСвязиЭтапов.Этап          КАК Этап,
		|	ВТСвязиЭтапов.СледующийЭтап КАК СледующийЭтап
		|ИЗ
		|	ВТСвязиЭтапов КАК ВТСвязиЭтапов");
	
	Запрос.УстановитьПараметр("Распоряжения", Распоряжения);
	
	МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Документы.ЭтапПроизводства2_2.СоздатьВТСвязиЭтаповПоРаспоряжению(
		МенеджерВременныхТаблиц,
		Распоряжения,
		Истина);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	МассивРезультатов = Запрос.ВыполнитьПакет();
	
	Выборка = МассивРезультатов[0].Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(Этапы.Добавить(), Выборка);
	КонецЦикла;
	
	Выборка = МассивРезультатов[1].Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(Зависимости.Добавить(), Выборка);
	КонецЦикла;
	
	Результат = Новый Структура("Этапы, Зависимости", Этапы, Зависимости);
	
	Возврат Результат;
	
КонецФункции

// Параметры:
// 	Потребности - ТаблицаЗначений
// 	Этапы - ТаблицаЗначений
//
Процедура ЗаполнитьЭтапыПоТаблицеПотребностей(Потребности, Этапы)
	
	КодЭтапа = 1;
	
	Для каждого Потребность Из Потребности Цикл
		
		Для каждого Этап Из Потребность.ДанныеСпецификации.Этапы Цикл
			
			Этап.КодЭтапа = КодЭтапа;
			КодЭтапа = КодЭтапа + 1;
			
			НоваяСтрока = Этапы.Добавить();
			
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Потребность, "Распоряжение, Идентификатор, ЭтоРазборка");
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Этап, "НомерЭтапа, НомерСледующегоЭтапа, Этап");
			
			НоваяСтрока.ЭтапПроизводства = Этап.КодЭтапа;
			НоваяСтрока.Ресурсоемкость = Этап.ДлительностьЭтапаВСекундах;
			
			Если Этап.НомерЭтапа = 1 ИЛИ Потребность.ДанныеСпецификации.Этапы.Найти(Этап.НомерЭтапа, "НомерСледующегоЭтапа") = Неопределено Тогда
				
				ЕстьВходы = Ложь;
				Для каждого Вход Из Потребность.Входы Цикл
					Если Вход.СтрокаРС.Этап = Этап.Этап Тогда
						ЕстьВходы = Истина;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				РазборкаПодЭтап = Потребность.ЭтоРазборка И ЗначениеЗаполнено(Потребность.ЭтапИсточник);
				
				НоваяСтрока.ПервыйЭтап = Не ЕстьВходы
					И Не РазборкаПодЭтап
					И Потребность.ПланироватьНеРанее.Пустая();
				
				Если РазборкаПодЭтап Тогда
					НоваяСтрока.СвязанСЭтапомПроизводства = Истина;
					НоваяСтрока.ЭтапИсточник = Потребность.ЭтапИсточник;
				КонецЕсли;
				
			КонецЕсли;
			
			Если Этап.НомерСледующегоЭтапа = 0 Тогда
				
				ЕстьВыходы = Ложь;
				Для каждого Выход Из Потребность.Выходы Цикл
					Если Выход.СтрокаРС.Этап = Этап.Этап Тогда
						ЕстьВыходы = Истина;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				ВыпускПодЭтап = Не Потребность.ЭтоРазборка И ЗначениеЗаполнено(Потребность.ЭтапИсточник);
				
				НоваяСтрока.ПоследнийЭтап = Не ЕстьВыходы И Не ВыпускПодЭтап;
				
				Если ВыпускПодЭтап Тогда
					НоваяСтрока.СвязанСЭтапомПроизводства = Истина;
					НоваяСтрока.ЭтапИсточник = Потребность.ЭтапИсточник;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
// 	Этапы - ТаблицаЗначений
// 	Зависимости - ТаблицаЗначений
//
Процедура ЗаполнитьВнутренниеЗависимостиЭтапов(Этапы, Зависимости)
	
	СтруктураПоиска = Новый Структура("НомерЭтапа");
	
	Для каждого Этап Из Этапы Цикл
		
		Если ЗначениеЗаполнено(Этап.НомерСледующегоЭтапа) Тогда
			
			СтруктураПоиска.НомерЭтапа = Этап.НомерСледующегоЭтапа;
			НайденныеСтроки = Этапы.НайтиСтроки(СтруктураПоиска);
			
			Для каждого Строка Из НайденныеСтроки Цикл
				
				НоваяСтрока = Зависимости.Добавить();
				НоваяСтрока.Этап = Этап.КодЭтапа;
				НоваяСтрока.СледующийЭтап = Строка.КодЭтапа;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
// 	Потребности - ТаблицаЗначений
// 	Потребность - СтрокаТаблицыЗначений
// 	Зависимости - ТаблицаЗначений
//
Процедура ЗаполнитьВнешниеЗависимостиПоТаблицеПотребностей(Потребности, Потребность, Зависимости)
	
	Для каждого Выход Из Потребность.Выходы Цикл
		
		СвПотребность = Потребности.Найти(Выход.СвязьИдентификатор, "Идентификатор");
		
		СтрокаОтправитель = Потребность.ДанныеСпецификации.Этапы.Найти(Выход.СтрокаРС.Этап, "Этап");
		СтрокаПолучатель = СвПотребность.ДанныеСпецификации.Этапы.Найти(Выход.СвязьЭтап, "Этап");
		
		Если СтрокаОтправитель <> Неопределено И СтрокаПолучатель <> Неопределено Тогда
					
			НоваяСтрока = Зависимости.Добавить();
			НоваяСтрока.Этап = СтрокаОтправитель.КодЭтапа;
			НоваяСтрока.СледующийЭтап = СтрокаПолучатель.КодЭтапа;
				
		КонецЕсли;
		
		Если НЕ Потребность.ПланироватьНеРанее.Пустая() Тогда
					
			СтрокаОтправитель = СвПотребность.ДанныеСпецификации.Этапы.Найти(Потребность.ПланироватьНеРанее);
			СтрокиПолучатели = Потребность.ДанныеСпецификации.Этапы.НайтиСтроки(Новый Структура("НомерЭтапа", 1));
					
			Если СтрокаОтправитель <> Неопределено И СтрокиПолучатели.ВГраница() <> -1 Тогда
						
				Для каждого СтрокаПолучатель Из СтрокиПолучатели Цикл
							
					НоваяСтрока = Зависимости.Добавить();
					НоваяСтрока.Этап = СтрокаОтправитель.КодЭтапа;
					НоваяСтрока.СледующийЭтап = СтрокаПолучатель.КодЭтапа;
							
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Параметры:
// 	Этапы - ТаблицаЗначений
// 	Зависимости - ТаблицаЗначений
//
Процедура ЗаполнитьЗависимостиСоздаваемыхИСуществующихЭтапов(Этапы, Зависимости)
	
	СтруктураПоиска = Новый Структура("СвязанСЭтапомПроизводства", Истина);
	НайденныеСтроки = Этапы.НайтиСтроки(СтруктураПоиска);
	
	Для каждого Строка Из НайденныеСтроки Цикл
		
		Если Строка.ЭтоРазборка Тогда
			
			НоваяСтрока = Зависимости.Добавить();
			НоваяСтрока.Этап = Строка.ЭтапИсточник;
			НоваяСтрока.СледующийЭтап = Строка.ЭтапПроизводства;
			
			СтрокаЭтап = Этапы.Найти(Строка.ЭтапИсточник, "ЭтапПроизводства");
			Если СтрокаЭтап <> Неопределено Тогда
				СтрокаЭтап.ПоследнийЭтап = Ложь;
			КонецЕсли;
			
		Иначе
			
			НоваяСтрока = Зависимости.Добавить();
			НоваяСтрока.Этап = Строка.ЭтапПроизводства;
			НоваяСтрока.СледующийЭтап = Строка.ЭтапИсточник;
		
			СтрокаЭтап = Этапы.Найти(Строка.ЭтапИсточник, "ЭтапПроизводства");
			Если СтрокаЭтап <> Неопределено Тогда
				СтрокаЭтап.ПервыйЭтап = Ложь;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СверткаПотребностей

Процедура СвернутьПотребности(Потребности, ПараметрыРазузлования, ПараметрыВыборки)
	
	Индекс1 = Потребности.Индексы.Добавить("Идентификатор");
	ПоляПодбора = "Спецификация"
		+ ?(ПустаяСтрока(ПараметрыРазузлования.ПоляГруппировки), "", "," + ПараметрыРазузлования.ПоляГруппировки);
	Индекс2 = Потребности.Индексы.Добавить(ПоляПодбора);
	СтруктураПодбора = Новый Структура(ПоляПодбора);
	
	Потомки = Новый ТаблицаЗначений; // Перенос Обеспечения и Аналогов из свернутых потребностей в укрупненные
	Потомки.Колонки.Добавить("Спецификация", Новый ОписаниеТипов("СправочникСсылка.РесурсныеСпецификации"));
	Потомки.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Потомки.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Потомки.Колонки.Добавить("Обеспечение", Новый ОписаниеТипов("Массив"));
	Потомки.Колонки.Добавить("Аналоги", Новый ОписаниеТипов("Массив"));
	
	СтруктураПоискаПотомки = Новый Структура("Спецификация, Номенклатура, Характеристика");
	
	Очередь = Новый Массив;
	
	Для Сч = 1 По 2 Цикл
		
		ТолкающаяСхема = (Сч = 1);
		
		Если Потребности.Найти(ТолкающаяСхема, "ЭтоТолкающаяСхема") = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Потребности.Сортировать(?(ТолкающаяСхема,
			"Начало Возр, Идентификатор Убыв",
			"Окончание Убыв, Идентификатор Убыв"));
		
		Для ИндексПотребность = 0 По Потребности.Количество()-1 Цикл
			
			ТекПотребность = Потребности[ИндексПотребность];
			
			Если ТекПотребность.Обработана
				ИЛИ ТекПотребность.ЭтоТолкающаяСхема <> ТолкающаяСхема
				ИЛИ Не ТекПотребность.ПланироватьНеРанее.Пустая() Тогда
				Продолжить;
			КонецЕсли;
			
			МассивПотребностей = ПодобратьПотребностиДляСвертки(Потребности, ТекПотребность, СтруктураПодбора);
			Если МассивПотребностей.ВГраница() = -1 Тогда
				ТекПотребность.Обработана = Истина;
				Продолжить;
			КонецЕсли;
			
			Потомки.Очистить();
			
			// Выбор сводной потребности
			СводнаяПотребность = ТекПотребность;
			Для каждого Потребность Из МассивПотребностей Цикл
				Если Потребность.Начало = СводнаяПотребность.Начало Тогда
					
					Если Не СводнаяПотребность.ДанныеСпецификации.ОсновноеИзделие.ЭтоОсновноеИзделие
						И Потребность.ДанныеСпецификации.ОсновноеИзделие.ЭтоОсновноеИзделие Тогда
						СводнаяПотребность = Потребность;
					КонецЕсли;
					
				ИначеЕсли ТекПотребность.ЭтоРазборка ИЛИ ТекПотребность.ЭтоРемонт Тогда
					
					Если Потребность.Начало > СводнаяПотребность.Начало Тогда
						СводнаяПотребность = Потребность;
					КонецЕсли;
					
				Иначе // Сборка
					
					Если Потребность.Начало < СводнаяПотребность.Начало Тогда
						СводнаяПотребность = Потребность;
					КонецЕсли;
					
				КонецЕсли;
			КонецЦикла;
			МассивПотребностей.Добавить(ТекПотребность);
			
			// Заполнение сводной потребности
			СводнаяПотребность.Обработана = Истина;
			СводнаяПотребность.ДнейОтПотребности = ДнейОтПотребностиПоГруппеПотребностей(МассивПотребностей);
			ПотребностьОсновноеИзделие = Неопределено;
			
			СвернутыеПотребности = Потребности.СкопироватьКолонки(
				"Спецификация, Номенклатура, Характеристика, Количество, ДанныеСпецификации");
			Для каждого Потребность Из МассивПотребностей Цикл
				
				// Подготовка данных для расчета партии выпуска
				ДобавитьНовуюСтроку = Истина;
				Для каждого СвернутаяСтрока Из СвернутыеПотребности Цикл
					Если СвернутаяСтрока.Номенклатура = Потребность.Номенклатура
						И (СвернутаяСтрока.Характеристика = Потребность.Характеристика
							ИЛИ СвернутаяСтрока.ДанныеСпецификации.ОсновноеИзделие.ЛюбаяХарактеристика
							И Потребность.ДанныеСпецификации.ОсновноеИзделие.ЛюбаяХарактеристика) Тогда
						
						СвернутаяСтрока.Количество = СвернутаяСтрока.Количество + Потребность.Количество;
						ДобавитьНовуюСтроку = Ложь;
						Прервать;
				
					КонецЕсли;
				КонецЦикла;
				Если ДобавитьНовуюСтроку Тогда
					ЗаполнитьЗначенияСвойств(СвернутыеПотребности.Добавить(), Потребность);
				КонецЕсли;
				
				// Контроль наличия основного изделия в Сводной потребности
				Если Не СводнаяПотребность.ДанныеСпецификации.ОсновноеИзделие.ЭтоОсновноеИзделие
						И Потребность.ДанныеСпецификации.ОсновноеИзделие.ЭтоОсновноеИзделие Тогда
					ПотребностьОсновноеИзделие = Потребность;
				КонецЕсли;
				
				// Перенос данных в сводную потребность
				Если Потребность <> СводнаяПотребность Тогда
					Если Потребность.ЭтоВходящаяПотребность Тогда
						СводнаяПотребность.СвернутыеВходящиеПотребности.Добавить(Потребность);
					КонецЕсли;
					Для каждого Обеспечение Из Потребность.Обеспечение Цикл
						ЗаполнитьЗначенияСвойств(СводнаяПотребность.Обеспечение.Добавить(), Обеспечение);
					КонецЦикла;
					Для каждого Аналог Из Потребность.Аналоги Цикл
						ЗаполнитьЗначенияСвойств(СводнаяПотребность.Аналоги.Добавить(), Аналог);
					КонецЦикла;
					СводнаяПотребность.Порядок = Мин(СводнаяПотребность.Порядок, Потребность.Порядок);
					
					// Фиксация потомков для последующего наследования Обеспечения и Аналогов
					// при пересчете потомков сводной потребности
					Очередь.Очистить();
					Для каждого Связь Из ?(Потребность.ЭтоРазборка, Потребность.Выходы, Потребность.Входы) Цикл
						Если Не Связь.Родитель Тогда
							Очередь.Добавить(Связь);
						КонецЕсли;
					КонецЦикла;
					Пока Очередь.ВГраница() <> -1 Цикл
						Связь = Очередь[0];
						
						Потомок = Потребности.Найти(Связь.СвязьИдентификатор, "Идентификатор");
						Если Потомок.Обеспечение.Количество() > 0
							Или Потомок.Аналоги.Количество() > 0 Тогда
							ЗаполнитьЗначенияСвойств(СтруктураПоискаПотомки, Потомок);
							НайденныеСтроки = Потомки.НайтиСтроки(СтруктураПоискаПотомки);
							Если НайденныеСтроки.Количество() = 0 Тогда
								СтрокаПотомки = Потомки.Добавить();
								ЗаполнитьЗначенияСвойств(СтрокаПотомки, Потомок, "Спецификация, Номенклатура, Характеристика");
							Иначе
								СтрокаПотомки = НайденныеСтроки[0];
							КонецЕсли;
							Если Потомок.Обеспечение.Количество() > 0 Тогда
								СтрокаПотомки.Обеспечение.Добавить(Потомок.Обеспечение);
							КонецЕсли;
							Если Потомок.Аналоги.Количество() > 0 Тогда
								СтрокаПотомки.Аналоги.Добавить(Потомок.Аналоги);
							КонецЕсли;
						КонецЕсли;
						
						Для каждого СвязьПотомок Из ?(Потомок.ЭтоРазборка, Потомок.Выходы, Потомок.Входы) Цикл
							Если Не СвязьПотомок.Родитель Тогда
								Очередь.Добавить(СвязьПотомок);
							КонецЕсли;
						КонецЦикла;
						
						Очередь.Удалить(0);
					КонецЦикла;
				КонецЕсли;
				
				// Количество входов в сводной потребности должно быть >= количеству в сворачиваемых потребностях.
				// Если это условие не соблюдено, то это означает, что в сводной потребности был выполнен резерв
				// ПФ на складе (в графике). В этом случае необходимо перенести связи в сводную потребность.
				Если Потребность <> СводнаяПотребность
					И Потребность.Входы.Количество() > СводнаяПотребность.Входы.Количество() Тогда
					Для Индекс = -Потребность.Входы.Количество()+1 По 0 Цикл
						Связь = Потребность.Входы[-Индекс];
						Если Связь.Родитель Тогда
							Продолжить;
						КонецЕсли;
						ПеренестиСвязь = Истина;
						Для каждого СвязьСвод Из СводнаяПотребность.Входы Цикл
							Если Не СвязьСвод.Родитель
								И Связь.СтрокаРС.КлючСвязи = СвязьСвод.СтрокаРС.КлючСвязи Тогда
								ПеренестиСвязь = Ложь;
								Прервать;
							КонецЕсли;
						КонецЦикла;
						
						Если ПеренестиСвязь Тогда
							НоваяСвязь = СводнаяПотребность.Входы.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяСвязь, Связь);
							НоваяСвязь.СтрокаРС = СводнаяПотребность.ДанныеСпецификации[Связь.СтрокаРСИмяВладельца].Найти(
								Связь.СтрокаРС.КлючСвязи, "КлючСвязи");
							НоваяСвязь.Связь.СвязьИдентификатор = СводнаяПотребность.Идентификатор;
							НоваяСвязь.Связь.Связь = НоваяСвязь;
							
							Потребность.Входы.Удалить(Связь);
							
							// Смещение нижележащих потребностей
							Если СводнаяПотребность.Начало < Потребность.Начало Тогда
								Отклонение = Потребность.Начало - СводнаяПотребность.Начало;
								Очередь.Очистить();
								Очередь.Добавить(НоваяСвязь.СвязьИдентификатор);
								Пока Очередь.ВГраница() <> -1 Цикл
									Потомок = Потребности.Найти(Очередь[0], "Идентификатор");
									Потомок.Начало = Потомок.Начало - Отклонение;
									Потомок.Окончание = Потомок.Окончание - Отклонение;
									Если ЗначениеЗаполнено(Потомок.СрокПролеживания) Тогда
										Потомок.СрокПролеживания = Потомок.СрокПролеживания - Отклонение;
									КонецЕсли;
									Очередь.Удалить(0);
									Для каждого ПотомокСвязь Из Потомок.Входы Цикл
										Очередь.Добавить(ПотомокСвязь.СвязьИдентификатор);
									КонецЦикла;
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
			
			Если СводнаяПотребность.Обеспечение.Количество() > 1 Тогда
				СводнаяПотребность.Обеспечение.Свернуть("СтрокаИндекс,Обособленно,Разрешение,ЗаменаНаАналог", "Количество");
			КонецЕсли;
			Если СводнаяПотребность.Аналоги.Количество() > 1 Тогда
				СводнаяПотребность.Аналоги.Свернуть("СтрокаИндекс,Разрешение,Номенклатура,Характеристика,Склад", "Количество");
			КонецЕсли;
			
			// Расчет партии выпуска
			ПартияВыпуска = Справочники.РесурсныеСпецификации.ПартияВыпуска(0,1);
			Для каждого Строка Из СвернутыеПотребности Цикл
				ПартияВыпускаНов = Справочники.РесурсныеСпецификации.РассчитатьПартиюВыпускаПоНоменклатуре(
					Строка, Строка.ДанныеСпецификации, ПараметрыВыборки);
				Если Справочники.РесурсныеСпецификации.СравнитьПартииВыпуска(ПартияВыпускаНов, ПартияВыпуска) > 0 Тогда
					ПартияВыпуска = ПартияВыпускаНов;
				КонецЕсли;
			КонецЦикла;
			СводнаяПотребность.ПартияВыпуска = ПартияВыпуска;
			
			// Копирование основного изделия в Сводную потребность
			Если ПотребностьОсновноеИзделие <> Неопределено Тогда
				СводнаяПотребность.ДанныеСпецификации.ОсновноеИзделие = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(
					ПотребностьОсновноеИзделие.ДанныеСпецификации.ОсновноеИзделие);
			КонецЕсли;
			
			// Пересчет количества
			ДанныеПоНоменклатуре = Справочники.РесурсныеСпецификации.ДанныеПоНоменклатуреРасширенный();
			
			ЗаполнитьЗначенияСвойств(ДанныеПоНоменклатуре, СводнаяПотребность);
			
			РассчитатьКоличествоНаПартиюВыпуска(
				ПараметрыРазузлования,
				ПартияВыпуска,
				СводнаяПотребность.ДанныеСпецификации,
				ДанныеПоНоменклатуре);
			
			// Пересчет количества в потомках
			Очередь.Очистить();
			Очередь.Добавить(СводнаяПотребность);
			Пока Очередь.ВГраница() <> -1 Цикл
				
				Потребность = Очередь[0];
				Для каждого Связь Из ?(Потребность.ЭтоРазборка, Потребность.Выходы, Потребность.Входы) Цикл
					Если Связь.Родитель Тогда
						Продолжить;
					КонецЕсли;
					
					Количество = Связь.СтрокаРС.Количество;
					
					// Зачет данных обеспечения
					Если Связь.СтрокаРСИмяВладельца = "МатериалыИУслуги" И Потребность.Обеспечение.Количество() > 0 Тогда
						Таблица = Потребность.ДанныеСпецификации.МатериалыИУслуги; // ТаблицаЗначений
						СтПоискаОбеспечение = Новый Структура("СтрокаИндекс", Таблица.Индекс(Связь.СтрокаРС));
						Для каждого СтрокаОбеспечение Из Потребность.Обеспечение.НайтиСтроки(СтПоискаОбеспечение) Цикл
							Количество = Количество - СтрокаОбеспечение.Количество;
						КонецЦикла;
					КонецЕсли;
					
					Потомок = Потребности.Найти(Связь.СвязьИдентификатор, "Идентификатор");
					Если Количество > 0 Тогда
						// Пересчет количества
						Потомок.Количество = Количество;
						Потомок.ПартияВыпуска = Справочники.РесурсныеСпецификации.РассчитатьПартиюВыпускаПоНоменклатуре(
							Потомок, Потомок.ДанныеСпецификации, ПараметрыВыборки);
						
						ЗаполнитьЗначенияСвойств(ДанныеПоНоменклатуре, Потомок);
						
						РассчитатьКоличествоНаПартиюВыпуска(
							ПараметрыРазузлования,
							Потомок.ПартияВыпуска,
							Потомок.ДанныеСпецификации,
							ДанныеПоНоменклатуре);
							
						// Наследование Обеспечения и Аналогов
						ЗаполнитьЗначенияСвойств(СтруктураПоискаПотомки, Потомок);
						НайденныеСтроки = Потомки.НайтиСтроки(СтруктураПоискаПотомки);
						Если НайденныеСтроки.Количество() <> 0 Тогда
							Для каждого Таблица Из НайденныеСтроки[0].Обеспечение Цикл
								Для каждого Строка Из Таблица Цикл
									ЗаполнитьЗначенияСвойств(Потомок.Обеспечение.Добавить(), Строка);
								КонецЦикла;
							КонецЦикла;
							Если Потомок.Обеспечение.Количество() > 1 Тогда
								Потомок.Обеспечение.Свернуть("СтрокаИндекс,Обособленно,Разрешение,ЗаменаНаАналог", "Количество");
							КонецЕсли;
							
							Для каждого Таблица Из НайденныеСтроки[0].Аналоги Цикл
								Для каждого Строка Из Таблица Цикл
									ЗаполнитьЗначенияСвойств(Потомок.Аналоги.Добавить(), Строка);
								КонецЦикла;
							КонецЦикла;
							Если Потомок.Аналоги.Количество() > 1 Тогда
								Потомок.Аналоги.Свернуть("СтрокаИндекс,Разрешение,Номенклатура,Характеристика,Склад", "Количество");
							КонецЕсли;
						КонецЕсли;
							
						Очередь.Добавить(Потомок);
					Иначе
						// Обеспечение перекрывает потребность, необходимо отменить всех потомков
						ОчередьОтменить = Новый Массив;
						ОчередьОтменить.Добавить(Потомок);
						Пока ОчередьОтменить.ВГраница() <> -1 Цикл
							ПотомокОтменить = ОчередьОтменить[0];
							ПотомокОтменить.Свернута = Истина;
							ПотомокОтменить.Обработана = Истина;
							
							Для каждого СвязьОтменить Из ПотомокОтменить.Входы Цикл
								Если Не СвязьОтменить.Родитель Тогда
									ОчередьОтменить.Добавить(Потребности.Найти(СвязьОтменить.СвязьИдентификатор, "Идентификатор"));
								КонецЕсли;
							КонецЦикла;
							ОчередьОтменить.Удалить(0);
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;
				Очередь.Удалить(0);
				
			КонецЦикла;
			
			Для каждого Потребность Из МассивПотребностей Цикл
				
				Если Потребность = СводнаяПотребность Тогда
					Продолжить;
				КонецЕсли;
				
				// Перестроение связей
				Если Потребность.ЭтоРазборка ИЛИ Потребность.ЭтоРемонт Тогда
					Для каждого Связь Из Потребность.Входы Цикл
						Если Не Связь.Родитель Тогда
							Продолжить;
						КонецЕсли;
						
						СводнаяПотребностьВходы = СводнаяПотребность.Входы; // ТаблицаЗначений
						НоваяСвязь = СводнаяПотребностьВходы.Добавить();
						ЗаполнитьЗначенияСвойств(НоваяСвязь, Связь);
						НоваяСвязь.СтрокаРС = СводнаяПотребность.ДанныеСпецификации.ВходящиеИзделия[0];
						
						Если ЗначениеЗаполнено(Связь.Связь) Тогда
							Связь.Связь.СвязьИдентификатор = СводнаяПотребность.Идентификатор;
							Связь.Связь.Связь = НоваяСвязь;
						Иначе
							// Связи "один к одному" может не быть если ремонтируемое изделие введено несколькими строками
							СвПотребность = Потребности.Найти(Связь.СвязьИдентификатор, "Идентификатор");
							Для каждого Выход Из СвПотребность.Выходы.НайтиСтроки(
									Новый Структура("СвязьИдентификатор", Потребность.Идентификатор)) Цикл
								Выход.СвязьИдентификатор = СводнаяПотребность.Идентификатор;
							КонецЦикла;
						КонецЕсли;
						
					КонецЦикла;
				КонецЕсли;
				
				Если Не Потребность.ЭтоРазборка Тогда // Сборка и ремонт
					Для каждого Связь Из Потребность.Выходы Цикл
						Если Не Связь.Родитель Тогда
							Продолжить;
						КонецЕсли;
						
						СводнаяПотребностьВыходы = СводнаяПотребность.Выходы; // ТаблицаЗначений
						НоваяСвязь = СводнаяПотребностьВыходы.Добавить();
						ЗаполнитьЗначенияСвойств(НоваяСвязь, Связь);
						Таблица = Потребность.ДанныеСпецификации.ВыходныеИзделия; // ТаблицаЗначений
						НоваяСвязь.СтрокаРС = СводнаяПотребность.ДанныеСпецификации.ВыходныеИзделия[
							Таблица.Индекс(Связь.СтрокаРС)];
						
						Связь.Связь.СвязьИдентификатор = СводнаяПотребность.Идентификатор;
						Связь.Связь.Связь = НоваяСвязь;
					КонецЦикла;
				КонецЕсли;
				
				Потребность.Свернута = Истина;
				Потребность.Обработана = Истина;
				
				// Установка пометки Свернута в потомках
				Очередь.Очистить();
				Для каждого Связь Из ?(Потребность.ЭтоРазборка, Потребность.Выходы, Потребность.Входы) Цикл
					Если Не Связь.Родитель Тогда
						Очередь.Добавить(Связь);
					КонецЕсли;
				КонецЦикла;
				Пока Очередь.ВГраница() <> -1 Цикл
					Связь = Очередь[0];
					
					Потомок = Потребности.Найти(Связь.СвязьИдентификатор, "Идентификатор");
					Потомок.Свернута = Истина;
					Потомок.Обработана = Истина;
					
					Для каждого СвязьПотомок Из ?(Потомок.ЭтоРазборка, Потомок.Выходы, Потомок.Входы) Цикл
						Если Не СвязьПотомок.Родитель Тогда
							Очередь.Добавить(СвязьПотомок);
						КонецЕсли;
					КонецЦикла;
					
					Очередь.Удалить(0);
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
	КонецЦикла;
	
	Потребности.Индексы.Удалить(Индекс1);
	Потребности.Индексы.Удалить(Индекс2);
	
КонецПроцедуры

// Возвращаемое значение:
// Массив из СтрокаТаблицыЗначений:
// * Начало - Дата
// * Идентификатор - Число
//
Функция ПодобратьПотребностиДляСвертки(Потребности, Потребность, СтруктураПодбора)
	
	Результат = Новый Массив;
	
	Если Потребность.ДанныеСпецификации.ОсновноеИзделие.ЭтоОсновноеИзделие Тогда
		Номенклатура = Потребность.Номенклатура;
		Характеристика = Потребность.Характеристика;
	Иначе
		Номенклатура = Неопределено;
		Характеристика = Неопределено;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(СтруктураПодбора, Потребность);
	НайденныеСтроки = Потребности.НайтиСтроки(СтруктураПодбора);
	
	Для каждого СледующаяПотребность Из НайденныеСтроки Цикл
		
		Если Потребности.Индекс(СледующаяПотребность) <= Потребности.Индекс(Потребность)
			ИЛИ СледующаяПотребность.Обработана
			ИЛИ Не СледующаяПотребность.ПланироватьНеРанее.Пустая() Тогда
			Продолжить;
		КонецЕсли;
		
		// Ограничение по номенклатуре и характеристике
		Если Потребность.ДанныеСпецификации.ЕстьУточняемоеОсновноеИзделие
			И СледующаяПотребность.ДанныеСпецификации.ОсновноеИзделие.ЭтоОсновноеИзделие Тогда
			
			Если Номенклатура = Неопределено Тогда
				Номенклатура = СледующаяПотребность.Номенклатура;
				Характеристика = СледующаяПотребность.Характеристика;
			ИначеЕсли Номенклатура <> СледующаяПотребность.Номенклатура
				ИЛИ Характеристика <> СледующаяПотребность.Характеристика Тогда
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
		// Ограничение по сроку пролеживания
		ВнутриСрокаПролеживания = Истина;
		Если Потребность.ЭтоРемонт Тогда
			Если НЕ Потребность.ЭтоВходящаяПотребность Тогда
				Если СледующаяПотребность.Окончание <= Потребность.СрокПролеживания Тогда
					ВнутриСрокаПролеживания = Истина;
					Потребность.СрокПролеживания = Мин(Потребность.СрокПролеживания, СледующаяПотребность.СрокПролеживания);
				Иначе
					ВнутриСрокаПролеживания = Ложь;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли Потребность.ДанныеСпецификации.ОграниченСрокПролеживания Тогда
			Если Потребность.ЭтоРазборка Тогда
				ВнутриСрокаПролеживания = СледующаяПотребность.Начало <= Потребность.СрокПролеживания;
			Иначе // Сборка
				Если СледующаяПотребность.Окончание <= Потребность.Окончание Тогда
					ВнутриСрокаПролеживания = СледующаяПотребность.Окончание >= Потребность.СрокПролеживания;
				Иначе
					ВнутриСрокаПролеживания = Потребность.Окончание >= СледующаяПотребность.СрокПролеживания;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если ВнутриСрокаПролеживания Тогда
			Результат.Добавить(СледующаяПотребность);
		Иначе
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДнейОтПотребностиПоГруппеПотребностей(МассивПотребностей)
	
	Результат = Неопределено;
	
	Для каждого Потребность Из МассивПотребностей Цикл
		
		Если Результат = Неопределено Тогда
			Результат = Потребность.ДнейОтПотребности;
		Иначе
			Если Потребность.ЭтоРазборка
				ИЛИ (Потребность.ЭтоРемонт И Не Потребность.ЭтоВходящаяПотребность) Тогда
				
				Результат = Макс(Результат, Потребность.ДнейОтПотребности);
				
			Иначе
				
				Результат = Мин(Результат, Потребность.ДнейОтПотребности);
				
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
//-- НЕ УТКА

#КонецОбласти
