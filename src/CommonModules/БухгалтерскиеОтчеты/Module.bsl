////////////////////////////////////////////////////////////////////////////////
// Функции и процедуры обеспечения формирования бухгалтерских отчетов.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ПредопределенныеСпискиЭлементов

//++ НЕ УТ

// Возвращает список счетов учета товаров.
//
// Параметры:
// ИсключаемыеСчета - Массив - Счета, которые нужно исключить из итогового списка.
//
// Возвращаемое значение:
// Массив - счета и субсчета учета товаров.
//
Функция СчетаУчетаТоваров(ИсключаемыеСчета = Неопределено) Экспорт
	
	Если ИсключаемыеСчета = Неопределено Тогда
		
		ИсключаемыеСчета = ИсключаемыеСчетаУчетаТоваров();
		
	КонецЕсли;
	
	СчетаУчетаТоваровПредопределенные = Новый Массив;
	СчетаУчетаТоваровПредопределенные.Добавить(ПланыСчетов.Хозрасчетный.Материалы);         // 10
	СчетаУчетаТоваровПредопределенные.Добавить(ПланыСчетов.Хозрасчетный.Полуфабрикаты);     // 21
	СчетаУчетаТоваровПредопределенные.Добавить(ПланыСчетов.Хозрасчетный.Товары);            // 41
	СчетаУчетаТоваровПредопределенные.Добавить(ПланыСчетов.Хозрасчетный.ГотоваяПродукция);  // 43
	СчетаУчетаТоваровПредопределенные.Добавить(ПланыСчетов.Хозрасчетный.ТоварыОтгруженные); // 45
	СчетаУчетаТоваров = БухгалтерскийУчет.СформироватьМассивСубсчетов(СчетаУчетаТоваровПредопределенные);
	СчетаУчетаТоваров = ОбщегоНазначенияКлиентСервер.РазностьМассивов(СчетаУчетаТоваров, ИсключаемыеСчета);
	
	БухгалтерскиеОтчетыПереопределяемый.СчетаУчетаТоваров(СчетаУчетаТоваров);
	
	Возврат СчетаУчетаТоваров;
	
КонецФункции

//-- НЕ УТ

// Определяет значения по умолчанию, общие для всех отчетов.
//
// Возвращаемое значение:
//  Структура - базовые значения: НачалоПериода, КонецПериода, Организация.
//
Функция БазовыеРеквизитыЗначенияПоУмолчанию() Экспорт
	
	ЗначенияПоУмолчанию = Новый Структура;
	ЗначенияПоУмолчанию.Вставить("НачалоПериода", '0001-01-01');
	ЗначенияПоУмолчанию.Вставить("КонецПериода",  '0001-01-01');
	ЗначенияПоУмолчанию.Вставить("Организация",   Справочники.Организации.ПустаяСсылка());
	
	ЗначенияПоУмолчанию.НачалоПериода = НачалоМесяца(ОбщегоНазначения.ТекущаяДатаПользователя());
	ЗначенияПоУмолчанию.КонецПериода  = КонецМесяца(ЗначенияПоУмолчанию.НачалоПериода);
	ЗначенияПоУмолчанию.Организация   = БухгалтерскийУчетПереопределяемый.ПолучитьЗначениеПоУмолчанию("ОсновнаяОрганизация");
	
	Возврат ЗначенияПоУмолчанию;
	
КонецФункции

// Получает из менеджера отчета сведения о свойствах отчета - манифест, декларирующий поддержанные в нем возможности подсистемы,
// включая реализованный программный интерфейс.
// Для проверки свойств рекомендуется использовать ЗначениеПараметраИсполненияОтчета.
//
// Параметры:
//  ИмяОтчета	 - Строка - имя отчета.
// 
// Возвращаемое значение:
//  Структура - может содержать свойства, значения которых проверяются в подсистеме.
//  Неопределено - отчет не поддерживает программный интерфейс подсистемы.
//
Функция ПараметрыИсполненияОтчета(ИмяОтчета) Экспорт
	
	Попытка
		Возврат Отчеты[ИмяОтчета].ПолучитьПараметрыИсполненияОтчета();
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

// Позволяет проверить наличие в программном интерфейсе отчета наличие поддержки того или иного элемента.
//
// Параметры:
//  ОписаниеОтчета		 - Строка - Имя отчета.
//                       - Структура - Параметры исполнения (манифест) отчета.
//  ИмяСвойства			 - Строка - имя проверямой возможности.
//  ЗначениеПоУмолчанию	 - Булево - значение по-умолчанию; будет возвращено, если манифест отчета не содержит запрошенного свойства.
// 
// Возвращаемое значение:
//  Булево - значение свойства.
//
Функция ЗначениеПараметраИсполненияОтчета(ОписаниеОтчета, ИмяСвойства, ЗначениеПоУмолчанию = Ложь) Экспорт
	
	Если ТипЗнч(ОписаниеОтчета) = Тип("Строка") Тогда
		Манифест = ПараметрыИсполненияОтчета(ОписаниеОтчета);
	Иначе
		Манифест = ОписаниеОтчета;
	КонецЕсли;
	
	Значение = ЗначениеПоУмолчанию;
	
	Если Манифест <> Неопределено И Манифест.Свойство(ИмяСвойства) Тогда
		Значение = Манифест[ИмяСвойства];
	КонецЕсли;
	
	Возврат Значение;
		
КонецФункции

// Проверяет нужен ли для переданного типа сложный подбор.
//
// Параметры:
//	ТипЭлемента - Тип - Тип, который нужно проверить.
// Возвращаемое значение:
//	Булево - Истина если нужна сложная обработка подбора, ложь - в противном случае.
//
Функция ЭтоТипЭлементаСоСложнымПодбором(ТипЭлемента) Экспорт
	
	СложныйПодбор = Ложь;
	//++ НЕ УТ
	БухгалтерскиеОтчетыКлиентСерверПереопределяемый.ЭтоТипЭлементаСоСложнымПодбором(ТипЭлемента, СложныйПодбор);
	//-- НЕ УТ
	Возврат СложныйПодбор;
	
КонецФункции

// В отчете "Карточка счета" группировки не задаются пользователем, а явно заданы в коде.
//
// Возвращаемое значение:
//   ТаблицаЗначений - содержит колонку "Поле", где перечислены группировки отчета.
//
Функция ГруппировкиКарточкиСчета() Экспорт
	
	ГруппировкиОтчета = Новый ТаблицаЗначений;
	ГруппировкиОтчета.Колонки.Добавить("Поле", Новый ОписаниеТипов("Строка"));
	ГруппировкаОтчета = ГруппировкиОтчета.Добавить();
	ГруппировкаОтчета.Поле = "СубконтоДт1";
	ГруппировкаОтчета = ГруппировкиОтчета.Добавить();
	ГруппировкаОтчета.Поле = "СубконтоДт2";
	ГруппировкаОтчета = ГруппировкиОтчета.Добавить();
	ГруппировкаОтчета.Поле = "СубконтоДт3";
	ГруппировкаОтчета = ГруппировкиОтчета.Добавить();
	ГруппировкаОтчета.Поле = "СубконтоКт1";
	ГруппировкаОтчета = ГруппировкиОтчета.Добавить();
	ГруппировкаОтчета.Поле = "СубконтоКт2";
	ГруппировкаОтчета = ГруппировкиОтчета.Добавить();
	ГруппировкаОтчета.Поле = "СубконтоКт3";
	Если БухгалтерскийУчетПереопределяемый.ВестиУчетПоПодразделениям() Тогда
		ГруппировкаОтчета = ГруппировкиОтчета.Добавить();
		ГруппировкаОтчета.Поле = "ПодразделениеДт";
		ГруппировкаОтчета = ГруппировкиОтчета.Добавить();
		ГруппировкаОтчета.Поле = "ПодразделениеКт";
	КонецЕсли;
	
	Возврат ГруппировкиОтчета;
	
КонецФункции

#КонецОбласти

#Область ПреобразованиеТекстаСКД

// Возвращает строковое представление уникального идентификатора ссылки. Используется при выводе УИДа ссылки в СКД.
//
// Параметры:
//   Ссылка - СправочникСсылка.* - Ссылка на элемент справочника.
//
// Возвращаемое значение:
//	Строка - Строковое представление уникального идентификатора.
//
Функция ПолучитьУИДСсылкиСтрокой(Ссылка) Экспорт
	Возврат Строка(Ссылка.УникальныйИдентификатор());
КонецФункции

// Устанавливает свойства связанных наборов данных для стандартных бухгалтерских отчетов.
//
// Параметры:
//	Схема - СхемаКомпоновкиДанных - Схема отчета.
//	ИмяНабора - Строка - Имя связанного набора.
//	ПараметрыПоляВладельца - Структура - Содержит ключ:
//		* ИндексСубконто - Число - Номер субконто.
//		* ЗаголовокСубконто - Строка - Название вида субконто.
//	ИмяПоляПрефикс - Строка - Префикс для имени поля.
//
Процедура ОбработатьНаборДанныхСвязаннойИнформации(Схема, ИмяНабора, ПараметрыПоляВладельца, ИмяПоляПрефикс = "Субконто") Экспорт
	
	Если ПараметрыПоляВладельца.ИндексСубконто > 0 Тогда
		ПутьКДаннымОсновногоПоля = ИмяПоляПрефикс + "1";
		ЗаголовокОсновногоПоля   = "";
		Для Каждого ПолеНабора Из Схема.НаборыДанных[ИмяНабора].Поля Цикл
			Если СтрНайти(ПолеНабора.Поле, "СвязанноеПолеСсылка") = 1 Тогда
				ПутьКДаннымОсновногоПоля = ПолеНабора.ПутьКДанным;
				ЗаголовокОсновногоПоля   = СтрЗаменить(ПолеНабора.Заголовок, ".Ссылка", "");
			КонецЕсли;
		КонецЦикла;
		Для Каждого ПолеНабора Из Схема.НаборыДанных[ИмяНабора].Поля Цикл
			Если СтрНайти(ПолеНабора.Поле, "СвязанноеПоле") = 1 Тогда
				ПолеНабора.ПутьКДанным = СтрЗаменить(ПолеНабора.ПутьКДанным, ПутьКДаннымОсновногоПоля, ИмяПоляПрефикс + ПараметрыПоляВладельца.ИндексСубконто);
				ПолеНабора.Заголовок   = СтрЗаменить(ПолеНабора.Заголовок, ЗаголовокОсновногоПоля, ПараметрыПоляВладельца.ЗаголовокСубконто);
				ПолеНабора.ОграничениеИспользования.Группировка = Истина;
				ПолеНабора.ОграничениеИспользования.Поле        = Ложь;
				ПолеНабора.ОграничениеИспользования.Условие     = Истина;
				ПолеНабора.ОграничениеИспользования.Порядок     = Ложь;

				ПолеНабора.ОграничениеИспользованияРеквизитов.Группировка = Истина;
				ПолеНабора.ОграничениеИспользованияРеквизитов.Поле        = Ложь;
				ПолеНабора.ОграничениеИспользованияРеквизитов.Условие     = Истина;
				ПолеНабора.ОграничениеИспользованияРеквизитов.Порядок     = Ложь;
				
				БухгалтерскиеОтчетыПереопределяемый.ОбработатьПолеНабораДанныхСвязаннойИнформации(ПолеНабора,
							Схема, ИмяНабора, ПараметрыПоляВладельца, ИмяПоляПрефикс);
				
			КонецЕсли;
		КонецЦикла;
		Для Каждого Связь Из Схема.СвязиНаборовДанных Цикл
			Если Связь.НаборДанныхПриемник = ИмяНабора Тогда
				Связь.ВыражениеИсточник = ИмяПоляПрефикс + ПараметрыПоляВладельца.ИндексСубконто;
				Связь.ВыражениеПриемник = ИмяПоляПрефикс + ПараметрыПоляВладельца.ИндексСубконто;
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для Каждого ПолеНабора Из Схема.НаборыДанных[ИмяНабора].Поля Цикл
			Если СтрНайти(ПолеНабора.Поле, "СвязанноеПоле") = 1 Тогда
				ПолеНабора.ОграничениеИспользования.Группировка = Истина;
				ПолеНабора.ОграничениеИспользования.Поле        = Истина;
				ПолеНабора.ОграничениеИспользования.Условие     = Истина;
				ПолеНабора.ОграничениеИспользования.Порядок     = Истина;
				
				ПолеНабора.ОграничениеИспользованияРеквизитов.Группировка = Истина;
				ПолеНабора.ОграничениеИспользованияРеквизитов.Поле        = Истина;
				ПолеНабора.ОграничениеИспользованияРеквизитов.Условие     = Истина;
				ПолеНабора.ОграничениеИспользованияРеквизитов.Порядок     = Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

//++ НЕ УТ

// Анализирует, используется ли корреспондирующие поля в условиях отборов.
//
// Параметры:
//  Отбор        - КоллекцияЭлементовОтбораКомпоновкиДанных - анализируемые условия.
//  ИменаИскомыхПолей - Массив из Строка - имена полей, которые (сами поля или с реквизитами) будут искаться.
//
// Возвращаемое значение:
//   Булево      - Истина, если отбор по кор.полю используется в одном из условий; иначе Ложь.
//
Функция ЕстьОтборПоКорПолю(Отбор, ИменаИскомыхПолей = Неопределено) Экспорт
	
	УсловиеПодбораВыполняется = Ложь;
	
	Если ИменаИскомыхПолей = Неопределено Тогда
		ИменаИскомыхПолей = Новый Массив;
		ИменаИскомыхПолей.Добавить("КорСчет");
		ИменаИскомыхПолей.Добавить("КорВалюта");
		ИменаИскомыхПолей.Добавить("КорПодразделение");
	КонецЕсли;
	
	Для каждого ИмяИскомогоПоля Из ИменаИскомыхПолей Цикл
	
		ДлинаИскомогоПоля = СтрДлина(ИмяИскомогоПоля);
		Для каждого ЭлементОтбора Из Отбор Цикл
			
			Если Не ЭлементОтбора.Использование Тогда
				Продолжить;
			КонецЕсли;
			
			Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
				
				Если ЕстьОтборПоКорполю(ЭлементОтбора.Элементы) Тогда

					УсловиеПодбораВыполняется = Истина;
					Прервать;

				КонецЕсли;
				
			Иначе
				
				ИмяПоля = Строка(ЭлементОтбора.ЛевоеЗначение);
				Если СтрНачинаетсяС(ИмяПоля, ИмяИскомогоПоля)
				   И (СтрДлина(ИмяПоля) = ДлинаИскомогоПоля Или Сред(ИмяПоля, ДлинаИскомогоПоля + 1, 1) = ".") Тогда
					
					УсловиеПодбораВыполняется = Истина;
					Прервать;

				КонецЕсли;
				
				ИмяПоля = Строка(ЭлементОтбора.ПравоеЗначение);
				Если СтрНачинаетсяС(ИмяПоля, ИмяИскомогоПоля)
				   И (СтрДлина(ИмяПоля) = ДлинаИскомогоПоля Или Сред(ИмяПоля, ДлинаИскомогоПоля + 1, 1) = ".") Тогда
					
					УсловиеПодбораВыполняется = Истина;
					Прервать;

				КонецЕсли;

			КонецЕсли;
		
		КонецЦикла;
		
		Если УсловиеПодбораВыполняется Тогда
			Возврат УсловиеПодбораВыполняется;
		КонецЕсли;
	
	КонецЦикла; 

	Возврат УсловиеПодбораВыполняется;
	
КонецФункции

// Получает список номеров субконто, которые используются в условиях отборов.
//
// Параметры:
//  Отбор        - КоллекцияЭлементовОтбораКомпоновкиДанных - анализируемые условия.
//  ОтбираемыеСубконто - Массив - заполняемый список номеров субконто.
//  СпособПодбора - Строка - "ТолькоДопСвойства" - учитывать только отборы по доп.свойствам;
//                           "РеквизитыСубконто" - учитывать только отборы через точку от субконто;
//                           "ВсеСубконто" - учитывать любые отборы по субконто.
//  КорСубконто  - Булево - если Ложь, то ищем в отборах "Субконто"; если Истина, то ищем "КорСубконто".
//
Процедура СписокОтборовПоСубконто(Отбор, ОтбираемыеСубконто, СпособПодбора = "ВсеСубконто", КорСубконто = Ложь) Экспорт

	ИмяИскомогоПоля = ?(КорСубконто, "КорСубконто", "Субконто");
	ДлинаИскомогоПоля = СтрДлина(ИмяИскомогоПоля);
	
	Для каждого ЭлементОтбора Из Отбор Цикл
		
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			
			СписокОтборовПоСубконто(ЭлементОтбора.Элементы, ОтбираемыеСубконто, СпособПодбора, КорСубконто);
			
		Иначе
			
			ИмяПоля = Строка(ЭлементОтбора.ЛевоеЗначение);
			Если СтрНачинаетсяС(ИмяПоля, ИмяИскомогоПоля) Тогда
				
				Если СпособПодбора = "ТолькоДопСвойства" Тогда
					// Дополнительные свойства могут быть назначены не только для самого объекта субконто,
					// но и для справочника, которые используется как реквизит в объектах субконто.
					// Поэтому ищем на любом уровне в пути к данным.
					УсловиеПодбораВыполняется = СтрНайти(Сред(ИмяПоля, ДлинаИскомогоПоля + 2), ".[") > 0;
				ИначеЕсли СпособПодбора = "РеквизитыСубконто" Тогда
					УсловиеПодбораВыполняется = Сред(ИмяПоля, ДлинаИскомогоПоля + 2, 1) = ".";
				Иначе
					УсловиеПодбораВыполняется = (СтрДлина(ИмяПоля) = ДлинаИскомогоПоля + 1
						Или Сред(ИмяПоля, ДлинаИскомогоПоля + 2, 1) = ".");
				КонецЕсли;
				Если УсловиеПодбораВыполняется Тогда
			   
					НомерСубконто = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(Сред(ИмяПоля, ДлинаИскомогоПоля + 1, 1));
					Если ОтбираемыеСубконто.Найти(НомерСубконто) = Неопределено Тогда
						ОтбираемыеСубконто.Добавить(НомерСубконто);
					КонецЕсли;
					
				КонецЕсли;
			   
			КонецЕсли;
			
			ИмяПоля = Строка(ЭлементОтбора.ПравоеЗначение);
			Если СтрНачинаетсяС(ИмяПоля, ИмяИскомогоПоля) Тогда
				
				Если СпособПодбора = "ТолькоДопСвойства" Тогда
					// Дополнительные свойства могут быть назначены не только для самого объекта субконто,
					// но и для справочника, которые используется как реквизит в объектах субконто.
					// Поэтому ищем на любом уровне в пути к данным.
					УсловиеПодбораВыполняется = СтрНайти(Сред(ИмяПоля, ДлинаИскомогоПоля + 2), ".[") > 0;
				ИначеЕсли СпособПодбора = "РеквизитыСубконто" Тогда
					УсловиеПодбораВыполняется = Сред(ИмяПоля, ДлинаИскомогоПоля + 2, 1) = ".";
				Иначе
					УсловиеПодбораВыполняется = (СтрДлина(ИмяПоля) = ДлинаИскомогоПоля + 1
						Или Сред(ИмяПоля, ДлинаИскомогоПоля + 2, 1) = ".");
				КонецЕсли;
				Если УсловиеПодбораВыполняется Тогда
			   
					НомерСубконто = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(Сред(ИмяПоля, ДлинаИскомогоПоля + 1, 1));
					Если ОтбираемыеСубконто.Найти(НомерСубконто) = Неопределено Тогда
						ОтбираемыеСубконто.Добавить(НомерСубконто);
					КонецЕсли;
					
				КонецЕсли;
			   
			КонецЕсли;

		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

// Преобразует текст запроса остатков в объединение подзапросов: основного и сторнирующего Контроль по счетам без НУ.
// Простое добавление условия "Счет.НалоговыйУчет" не даст корректного результата, т.к. приводит получению остатков
// в разрезе счетов, а не сводного остатка по группе счетов.
//
// Параметры:
//  ПараметрыОтчета - см. модуль формы отчета, функция ПодготовитьПараметрыОтчета() .
//  ОписаниеТекстаЗапроса - ЗапросВыбораСхемыЗапроса - описание запроса, который нужно дополнить.
//
Процедура ДобавитьСторноДляПоказателяКонтроль(ПараметрыОтчета, ОписаниеТекстаЗапроса) Экспорт

	ЭталонныйОператор = ОписаниеТекстаЗапроса.Операторы[0];
	ЭталонныйПсевдоним = ЭталонныйОператор.Источники[0].Источник.Псевдоним;
	
	СводныйОператор = ОписаниеТекстаЗапроса.Операторы.Добавить();
	СводныйВложенный = СводныйОператор.Источники.Добавить(Тип("ВложенныйЗапросСхемыЗапроса"), "Сводный");
	СводныйЗапрос = СводныйВложенный.Источник.Запрос;
	
	ОсновнойОператор = СводныйЗапрос.Операторы.Добавить(ЭталонныйОператор);
	СторнирующийОператор = СводныйЗапрос.Операторы.Добавить(ОсновнойОператор);
	Если СводныйЗапрос.Операторы.Количество() > 2 Тогда // удаляем оператор по-умолчанию
		СводныйЗапрос.Операторы.Удалить(0);
	КонецЕсли;
	
	// Устанавливаем отбор по счетам, на которых не ведется налоговый учет.
	ВыражениеПараметр = СторнирующийОператор.Источники[0].Источник.Параметры[1];
	ТекстВыражения = Строка(ВыражениеПараметр.Выражение);
	ВыражениеПараметр.Выражение = Новый ВыражениеСхемыЗапроса(ТекстВыражения
		+ ?(ПустаяСтрока(ТекстВыражения) , "", " И ") + "НЕ Счет.НалоговыйУчет");
	
	// Устанавливаем представления полей сводного запроса как в эталонном запросе.
	КоличествоКолонок = ОписаниеТекстаЗапроса.Колонки.Количество();
	ЭталонныйПоля = ЭталонныйОператор.ВыбираемыеПоля;
	ОсновнойПоля = ОсновнойОператор.ВыбираемыеПоля;
	СторнирующийПоля = СторнирующийОператор.ВыбираемыеПоля;
	Для ИндексПоля = 0 По КоличествоКолонок - 1 Цикл

		ПсевдонимПоля = ОписаниеТекстаЗапроса.Колонки[ИндексПоля].Псевдоним;

		// Обработка основного запроса.
		Если ОсновнойПоля[ИндексПоля].СодержитАгрегатнуюФункцию() Тогда
			
			ТекстВыражения = Строка(ОсновнойПоля[ИндексПоля]);
			ПозицияВТексте = СтрНайти(ТекстВыражения, "(");
			ТекстВыражения = Сред(ТекстВыражения, ПозицияВТексте + 1, СтрДлина(ТекстВыражения) - ПозицияВТексте - 1);
			ОсновнойПоля.Установить(ИндексПоля, Новый ВыражениеСхемыЗапроса(ТекстВыражения));
			
		КонецЕсли;
		
		// Обработка сторнирующего запроса.
		Если Лев(ПсевдонимПоля, 8) = "Контроль" Тогда
			
			ТекстВыражения = Строка(СторнирующийПоля[ИндексПоля]);
			Если СторнирующийПоля[ИндексПоля].СодержитАгрегатнуюФункцию() Тогда
				
				ПозицияВТексте = СтрНайти(ТекстВыражения, "(");
				ТекстВыражения = Сред(ТекстВыражения, ПозицияВТексте + 1, СтрДлина(ТекстВыражения) - ПозицияВТексте - 1);
				
			КонецЕсли;
			ТекстВыражения = "-(" + ТекстВыражения + ")";
			
		Иначе
			
			ТекстВыражения = "0";
			
		КонецЕсли;
		СторнирующийПоля.Установить(ИндексПоля, Новый ВыражениеСхемыЗапроса(ТекстВыражения));
		
		// Обработка объединения запросов.
		СводныйЗапрос.Колонки[ИндексПоля].Псевдоним = ПсевдонимПоля;
		Если ЭталонныйПоля[ИндексПоля].СодержитАгрегатнуюФункцию() Тогда
			ТекстВыражения = "СУММА(Сводный." + ПсевдонимПоля + ")";
		Иначе
			ТекстВыражения = Строка(ЭталонныйПоля[ИндексПоля]);
			ТекстВыражения = СтрЗаменить(ТекстВыражения, ЭталонныйПсевдоним + ".", "Сводный.");
		КонецЕсли;
		СводныйОператор.ВыбираемыеПоля.Добавить(ТекстВыражения, ИндексПоля);
		
	КонецЦикла;	
	
	ОписаниеТекстаЗапроса.Операторы.Удалить(0);	// удаляем исходный запрос
	
КонецПроцедуры

// Для случая, когда установлены отборы по доп.свойствам субконто, будет произведена замена в тексте схемы
// компоновки данных. Отборы по дополнительным свойствам невозможны в параметрах виртуальной таблицы.
// Поэтому в текст набора данных Проводки в СКД к запросам по остаткам добавляется секция ГДЕ.
//
// Параметры:
//  ПараметрыОтчета - Структура - см. ПодготовитьПараметрыОтчета() в ФормаОтчета.
//  Схема        - СхемаКомпоновкиДанных - описание получаемых данных.
//  КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - связь настроек компоновки данных и схемы компоновки.
//
Процедура ИзменитьСхемуДляОтборовПоДопСвойствамСубконто(ПараметрыОтчета, Схема, КомпоновщикНастроек) Экспорт
	
	ОтбираемыеВидыСубконто = Новый Массив;
	СписокОтборовПоСубконто(КомпоновщикНастроек.Настройки.Отбор.Элементы, ОтбираемыеВидыСубконто, "ТолькоДопСвойства");
	Если ОтбираемыеВидыСубконто.Количество() = 0 Тогда // нет отборов по доп.свойствам субконто
		Возврат;
	КонецЕсли;
	
	Если Не КомпоновщикНастроек.Настройки.ДополнительныеСвойства.Свойство("ИзмененТекстЗапросаСКД") Тогда
		ИмяСхемы = ИмяСхемыКомпоновкиДанныхОтчета(ПараметрыОтчета, ПараметрыОтчета.ИдентификаторОтчета);
		Схема = Отчеты[ПараметрыОтчета.ИдентификаторОтчета].ПолучитьМакет(ИмяСхемы);
	КонецЕсли;		
	
	ОписаниеЗапроса = Новый СхемаЗапроса;
	ОписаниеЗапроса.УстановитьТекстЗапроса(Схема.НаборыДанных.Проводки.Запрос);
	ПакетЗапросов = ОписаниеЗапроса.ПакетЗапросов;
	
	ТекстыЗапросов = Новый Массив;	
	Для каждого ЗапросПакета Из ПакетЗапросов Цикл

		// При отборе по оборотному субконто, используя секцию ГДЕ, возможно появление строк, где есть только остатки
		// и строк, где есть только обороты (период/регистратор/номер одинаковые). Требуется сгруппировать такие строки.
		Если ЗапросПакета.ТаблицаДляПомещения = "ХозрасчетныйОстаткиИОбороты" Тогда
			
			ВыбираемыеПоля = ЗапросПакета.Операторы[0].ВыбираемыеПоля;
			Группировка = ЗапросПакета.Операторы[0].Группировка;
			Для каждого ВыбираемоеПоле Из ВыбираемыеПоля Цикл
				
				ИмяРесурса = Сред(ВыбираемоеПоле, 29); // убираем имя таблицы
				Если СтрНачинаетсяС(ИмяРесурса, "Сумма")
				 Или СтрНачинаетсяС(ИмяРесурса, "ВалютнаяСумма")
				 Или СтрНачинаетсяС(ИмяРесурса, "Количество") Тогда
				 
					ИмяРесурса = "СУММА(" + ИмяРесурса + ")";
					ВыбираемыеПоля.Установить(ВыбираемыеПоля.Индекс(ВыбираемоеПоле), Новый ВыражениеСхемыЗапроса(ИмяРесурса));
					
				Иначе
					
					Группировка.Добавить(Новый ВыражениеСхемыЗапроса(ИмяРесурса));
				 
			 	КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
		ТекстЗапроса = ЗапросПакета.ПолучитьТекстЗапроса();
		
		Если ЗапросПакета.ТаблицаДляПомещения = "ОстаткиНаНачало"
		 Или ЗапросПакета.ТаблицаДляПомещения = "ОстаткиНаКонец"
		 Или ЗапросПакета.ТаблицаДляПомещения = "ХозрасчетныйОстаткиИОбороты" Тогда

			ПозицияСимвола = СтрНайти(ТекстЗапроса, "{ГДЕ", НаправлениеПоиска.СКонца);
			Если ПозицияСимвола = 0 Тогда // добавляем секцию {ГДЕ
				
				ТекстЗапроса = ТекстЗапроса
					+ СтрЗаменить("
					|{ГДЕ
					|	#ТаблицаОстатков.Субконто1.* КАК Субконто1,
					|	#ТаблицаОстатков.Субконто2.* КАК Субконто2,
					|	#ТаблицаОстатков.Субконто3.* КАК Субконто3}",
					"#ТаблицаОстатков",
					ЗапросПакета.ТаблицаДляПомещения);
				
			Иначе // добавляем поля в секцию {ГДЕ
				
				ПозицияСимвола = СтрНайти(ТекстЗапроса, "}", НаправлениеПоиска.СКонца);
				ТекстЗапроса = Лев(ТекстЗапроса, ПозицияСимвола - 1)
					+ СтрЗаменить(",
					|	#ТаблицаОстатков.Субконто1.* КАК Субконто1,
					|	#ТаблицаОстатков.Субконто2.* КАК Субконто2,
					|	#ТаблицаОстатков.Субконто3.* КАК Субконто3",
					"#ТаблицаОстатков",
					ЗапросПакета.ТаблицаДляПомещения)
					+ Сред(ТекстЗапроса, ПозицияСимвола);
				
			КонецЕсли;
			
		КонецЕсли;
		
		ТекстыЗапросов.Добавить(ТекстЗапроса);
	
	КонецЦикла;
	Для Индекс = 0 По ПакетЗапросов.Количество() - 1 Цикл
		ПакетЗапросов[Индекс].УстановитьТекстЗапроса(ТекстыЗапросов[Индекс]);
	КонецЦикла;
	
	Схема.НаборыДанных.Проводки.Запрос = ОписаниеЗапроса.ПолучитьТекстЗапроса();
	КомпоновщикНастроек.Настройки.ДополнительныеСвойства.Вставить("ИзмененТекстЗапросаСКД", Истина);
	
КонецПроцедуры

// Получим расстановку субконто по результатам запросов к субсчетам, исходя из принципа:
// - если у субсчета есть вид субконто такой же как у счета-группы, то он должен быть на той же позиции;
//   "1 номенклатура" -> "2 номенклатура" , если у счета-группы "2 номенклатура"
// - если у субсчета такого вида субконто нет, то подставляем другой из имеющихся у субсчета;
//   "1 номенклатура 2 контрагент" -> "1 контрагент 2 номенклатура", если у счета-группы "1 склад 2 номенклатура"
// - если между видами субконто субсчета имеется дырка, то заполняем ее значениями Неопределено.
//   "1 склад 2 номенклатура" -> "1 Неопределено 2 номенклатура", если у субсчета нет других субконто.
//   "1 номенклатура 2 склад" -> "1 номенклатура 2 Неопределено"
//
// Параметры:
//  СчетГруппа   - ПланСчетовСсылка.Хозрасчетный - счет, задающий эталонный порядок субконто.
//  НомераИспользуемыхСубконтоСчетаГруппы - Массив - те из номеров субконто, которые требуются для отчета.
//  Субсчета     - СписокЗначений - список субсчетов, для которых надо построить карту.
//
// Возвращаемое значение:
//   ТаблицаЗначений - наборы видов субконто и списки счетов, им соответствующие.
//          * СубконтоВиртуальнойТаблицыВПозиции1/2/3 = номер псевдонима для поля субконто из результата виртуальной таблицы;
//          * ВидыСубконто = виды субконто, которые передаются в параметр &ВидыСубконто виртуальной таблицы;
//          * Счета = субсчета с данным набором субконто.
//
Функция КартаСубконто(СчетГруппа, НомераИспользуемыхСубконтоСчетаГруппы, Субсчета) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Субсчета",   Субсчета);

	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Хозрасчетный.Ссылка КАК Счет,
	|	ЕСТЬNULL(ВидыСубконто1.ВидСубконто, НЕОПРЕДЕЛЕНО) КАК ВидСубконто1,
	|	ЕСТЬNULL(ВидыСубконто2.ВидСубконто, НЕОПРЕДЕЛЕНО) КАК ВидСубконто2,
	|	ЕСТЬNULL(ВидыСубконто3.ВидСубконто, НЕОПРЕДЕЛЕНО) КАК ВидСубконто3
	|ИЗ
	|	ПланСчетов.Хозрасчетный КАК Хозрасчетный
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный.ВидыСубконто КАК ВидыСубконто1
	|		ПО Хозрасчетный.Ссылка = ВидыСубконто1.Ссылка
	|			И (ВидыСубконто1.НомерСтроки = 1)
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный.ВидыСубконто КАК ВидыСубконто2
	|		ПО Хозрасчетный.Ссылка = ВидыСубконто2.Ссылка
	|			И (ВидыСубконто2.НомерСтроки = 2)
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный.ВидыСубконто КАК ВидыСубконто3
	|		ПО Хозрасчетный.Ссылка = ВидыСубконто3.Ссылка
	|			И (ВидыСубконто3.НомерСтроки = 3)
	|ГДЕ
	|	Хозрасчетный.Ссылка В (&Субсчета)";
	
	СвойстваСчетов = Запрос.Выполнить().Выгрузить();

	// Определим позиции поля субконто в запросе к виртуальной таблице для субконто каждого субсчета.
	// Например, в оборотах счета по 76 выбрана группировка только по договорам, номер субконто Договоры на счете 76 = 2.
	// В параметре &ВидыСубконто виртуальной таблицы ОстаткиИОбороты() нужно передать только один элемент ПВХ.ВидыСубконтоХозрасчетные.Договоры.
	// Поэтому в запросе договор будет доступно как поле Субконто1.
	// Чтобы оно правильно сопоставилось с полем договоры в настройках СКД, в запросе потребуется заменить его псевдоним:
	//      Субконто1 КАК Субконто2

	ОписаниеТиповЧисло       = ОбщегоНазначения.ОписаниеТипаЧисло(2);
	ОписаниеТиповВидСубконто = Новый ОписаниеТипов("ПланВидовХарактеристикСсылка.ВидыСубконтоХозрасчетные");
	
	ДетальнаяКартаСубконто = Новый ТаблицаЗначений;
	ДетальнаяКартаСубконто.Колонки.Добавить("Счет",         Новый ОписаниеТипов("ПланСчетовСсылка.Хозрасчетный"));
	// Виды субконто, которые передаются в параметр &ВидыСубконто виртуальной таблицы.
	ДетальнаяКартаСубконто.Колонки.Добавить("ВидСубконто1", ОписаниеТиповВидСубконто);
	ДетальнаяКартаСубконто.Колонки.Добавить("ВидСубконто2", ОписаниеТиповВидСубконто);
	ДетальнаяКартаСубконто.Колонки.Добавить("ВидСубконто3", ОписаниеТиповВидСубконто);
	// Содержат номер псевдонима (КАК Субконто1, КАК Субконто2, КАК Субконто3) для поля субконто из результата виртуальной таблицы.
	ДетальнаяКартаСубконто.Колонки.Добавить("СубконтоВиртуальнойТаблицыВПозиции1", ОписаниеТиповЧисло);
	ДетальнаяКартаСубконто.Колонки.Добавить("СубконтоВиртуальнойТаблицыВПозиции2", ОписаниеТиповЧисло);
	ДетальнаяКартаСубконто.Колонки.Добавить("СубконтоВиртуальнойТаблицыВПозиции3", ОписаниеТиповЧисло);

	// Для субконто счета группы номера на счете в плане счетов совпадают с позициями псевдонимов в запросе.
	СвойстваСчетаГруппы = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетГруппа);
	
	ПозицииСубконтоСчетаГруппы = Новый Соответствие;
	Для Счетчик = 0 По НомераИспользуемыхСубконтоСчетаГруппы.ВГраница() Цикл
		НомерСубконтоСчетаГруппы = НомераИспользуемыхСубконтоСчетаГруппы[Счетчик];
		ПозицииСубконтоСчетаГруппы.Вставить(СвойстваСчетаГруппы["ВидСубконто" + НомерСубконтоСчетаГруппы], НомерСубконтоСчетаГруппы);
	КонецЦикла;

	// Расставляем субконто субсчетов в запросе.
	Для каждого СвойстваСубсчета Из СвойстваСчетов Цикл
	
		СтрокаКарты      = ДетальнаяКартаСубконто.Добавить();
		СтрокаКарты.Счет = СвойстваСубсчета.Счет;
	
		НомерСубконтоВиртуальнойТаблицы = 0;
	
		// Сначала виды субконто, совпадающие со счетом группой, на соответствующие позиции.
		Для НомерСубконтоСубсчета = 1 По БухгалтерскийУчет.МаксимальноеКоличествоСубконто() Цикл

			ВидСубконтоСубсчета = СвойстваСубсчета["ВидСубконто" + НомерСубконтоСубсчета];
			Если НЕ ЗначениеЗаполнено(ВидСубконтоСубсчета) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСубконтоСчетаГруппы = ПозицииСубконтоСчетаГруппы[ВидСубконтоСубсчета];
			Если НЕ ЗначениеЗаполнено(НомерСубконтоСчетаГруппы) Тогда
				// У счета группы нет такого вида субконто, либо оно не выбрано в отчете.
				Продолжить;
			КонецЕсли;
			
			НомерСубконтоВиртуальнойТаблицы = НомерСубконтоВиртуальнойТаблицы + 1;
			СтрокаКарты["ВидСубконто" + НомерСубконтоВиртуальнойТаблицы]                 = ВидСубконтоСубсчета;
			СтрокаКарты["СубконтоВиртуальнойТаблицыВПозиции" + НомерСубконтоСчетаГруппы] = НомерСубконтоВиртуальнойТаблицы;
			
			// Очистим вид субконто в таблице выборки из плана счетов, чтобы в дальнейшем его не учитывать.
			СвойстваСубсчета["ВидСубконто" + НомерСубконтоСубсчета] = Неопределено;
			
		КонецЦикла;
		
		// Подставляем субконто субсчета с иным видом, но с тем же номером, что и у счета-группы.
		Для каждого НомерСубконто из НомераИспользуемыхСубконтоСчетаГруппы Цикл

			Если НомерСубконтоВиртуальнойТаблицы >= НомераИспользуемыхСубконтоСчетаГруппы.Количество() Тогда
				// Все субконто разместили.
				Прервать;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(СтрокаКарты["СубконтоВиртуальнойТаблицыВПозиции" + НомерСубконто]) Тогда
				// Позиция уже занята.
				Продолжить;
			КонецЕсли;
			
			ВидСубконтоСубсчета = СвойстваСубсчета["ВидСубконто" + НомерСубконто];
			Если Не ЗначениеЗаполнено(ВидСубконтоСубсчета) Тогда
				// У субсчета нет субконто с таким номером.
				Продолжить;
			КонецЕсли;
			
			НомерСубконтоВиртуальнойТаблицы = НомерСубконтоВиртуальнойТаблицы + 1;
			СтрокаКарты["ВидСубконто" + НомерСубконтоВиртуальнойТаблицы] = ВидСубконтоСубсчета;
			СтрокаКарты["СубконтоВиртуальнойТаблицыВПозиции" + НомерСубконто] = НомерСубконтоВиртуальнойТаблицы;
			
			// Очистим вид субконто в таблице выборки из плана счетов, чтобы в дальнейшем его не учитывать.
			СвойстваСубсчета["ВидСубконто" + НомерСубконто] = Неопределено;
			
		КонецЦикла;
		
		// В остальные позиции в запросе подставляем оставшиеся субконто субсчета.
		Для каждого НомерСубконто из НомераИспользуемыхСубконтоСчетаГруппы Цикл

			Если ЗначениеЗаполнено(СтрокаКарты["СубконтоВиртуальнойТаблицыВПозиции" + НомерСубконто]) Тогда
				Продолжить;
			КонецЕсли;
			Если НомерСубконтоВиртуальнойТаблицы >= НомераИспользуемыхСубконтоСчетаГруппы.Количество() Тогда
				// Все субконто разместили.
				Прервать;
			КонецЕсли;
			
			Для НомерСубконтоСубсчета = 1 По БухгалтерскийУчет.МаксимальноеКоличествоСубконто() Цикл
				
				ВидСубконтоСубсчета = СвойстваСубсчета["ВидСубконто" + НомерСубконтоСубсчета];
				Если ЗначениеЗаполнено(ВидСубконтоСубсчета) Тогда
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			Если Не ЗначениеЗаполнено(ВидСубконтоСубсчета) Тогда
				// У субсчета нет других субконто.
				Прервать;
			КонецЕсли; 
			
			НомерСубконтоВиртуальнойТаблицы = НомерСубконтоВиртуальнойТаблицы + 1;
			СтрокаКарты["ВидСубконто" + НомерСубконтоВиртуальнойТаблицы] = ВидСубконтоСубсчета;
			СтрокаКарты["СубконтоВиртуальнойТаблицыВПозиции" + НомерСубконто] = НомерСубконтоВиртуальнойТаблицы;
			
			// Очистим вид субконто в таблице выборки из плана счетов, чтобы в дальнейшем его не учитывать.
			СвойстваСубсчета["ВидСубконто" + НомерСубконтоСубсчета] = Неопределено;
			
		КонецЦикла;
	
	КонецЦикла;
	
	// Упорядочиваем для объединения счетов с одинаковыми комбинациями субконто в один запрос к виртуальной таблице.
	ИменаГруппируемыхКолонок = "ВидСубконто1, ВидСубконто2, ВидСубконто3,
		|СубконтоВиртуальнойТаблицыВПозиции1, СубконтоВиртуальнойТаблицыВПозиции2, СубконтоВиртуальнойТаблицыВПозиции3";
	
	ДетальнаяКартаСубконто.Сортировать(ИменаГруппируемыхКолонок, Новый СравнениеЗначений);

	СвернутаяКартаСубконто = ДетальнаяКартаСубконто.СкопироватьКолонки(
		"СубконтоВиртуальнойТаблицыВПозиции1, СубконтоВиртуальнойТаблицыВПозиции2, СубконтоВиртуальнойТаблицыВПозиции3");
	СвернутаяКартаСубконто.Колонки.Добавить("Счета",        Новый ОписаниеТипов("СписокЗначений"));
	СвернутаяКартаСубконто.Колонки.Добавить("ВидыСубконто", Новый ОписаниеТипов("СписокЗначений"));
	
	СтрокаСвернутойКарты = Неопределено;
	
	Для Индекс = 0 По ДетальнаяКартаСубконто.Количество() - 1 Цикл
		
		СтрокаДетальнойКарты = ДетальнаяКартаСубконто[Индекс];
		Если Индекс > 0 Тогда
			ПредыдущаяСтрокаДетальнойКарты = ДетальнаяКартаСубконто[Индекс - 1];
		КонецЕсли;
	                                                                       
		Если Индекс = 0
			ИЛИ СтрокаДетальнойКарты.ВидСубконто1 <> ПредыдущаяСтрокаДетальнойКарты.ВидСубконто1
			ИЛИ СтрокаДетальнойКарты.ВидСубконто2 <> ПредыдущаяСтрокаДетальнойКарты.ВидСубконто2
			ИЛИ СтрокаДетальнойКарты.ВидСубконто3 <> ПредыдущаяСтрокаДетальнойКарты.ВидСубконто3
			ИЛИ СтрокаДетальнойКарты.СубконтоВиртуальнойТаблицыВПозиции1 <> ПредыдущаяСтрокаДетальнойКарты.СубконтоВиртуальнойТаблицыВПозиции1
			ИЛИ СтрокаДетальнойКарты.СубконтоВиртуальнойТаблицыВПозиции2 <> ПредыдущаяСтрокаДетальнойКарты.СубконтоВиртуальнойТаблицыВПозиции2
			ИЛИ СтрокаДетальнойКарты.СубконтоВиртуальнойТаблицыВПозиции3 <> ПредыдущаяСтрокаДетальнойКарты.СубконтоВиртуальнойТаблицыВПозиции3 Тогда
			
			СтрокаСвернутойКарты = СвернутаяКартаСубконто.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаСвернутойКарты, СтрокаДетальнойКарты);
			
			Для НомерСубконто = 1 По 3 Цикл
				ВидСубконто = СтрокаДетальнойКарты["ВидСубконто" + НомерСубконто];
				Если ЗначениеЗаполнено(ВидСубконто) Тогда
					СтрокаСвернутойКарты.ВидыСубконто.Добавить(ВидСубконто);
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
		// Накапливаем список счетов.
		СтрокаСвернутойКарты.Счета.Добавить(СтрокаДетальнойКарты.Счет);
	
	КонецЦикла;
	
	Возврат СвернутаяКартаСубконто;

КонецФункции

// Дополняет текст наборов данных подзапросами, учитывающими отбор по субконто с несовпадающими номерами.
//
// Параметры:
//  ПараметрыОтчета - Структура - см. ПодготовитьПараметрыОтчета() в ФормаОтчета.
//  КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - связь настроек компоновки данных и схемы компоновки.
//  Схема        - СхемаКомпоновкиДанных - описание получаемых данных.
//  ИмяОсновногоНабора - Строка - название набора с схеме СКД, который содержит наборы данных остатков и оборотов.
//
Процедура ИзменитьСхемуДляОтборовПоСубконтоСубсчетов(ПараметрыОтчета, КомпоновщикНастроек, Схема, ИмяОсновногоНабора) Экспорт
	
	НомераОтбираемыхСубконто = Новый Массив;
  	Для каждого Группировка Из ПараметрыОтчета.Группировка Цикл
		                                                           
  		Если НЕ Группировка.Использование Тогда
  			Продолжить;
  		КонецЕсли;
  	
		Если НЕ СтрНачинаетсяС(Группировка.Поле, "Субконто") Тогда
			Продолжить;
		КонецЕсли;
		
		НомерСубконто = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(Сред(Группировка.Поле, 9, 1));
		Если НомераОтбираемыхСубконто.Найти(НомерСубконто) = Неопределено Тогда
			НомераОтбираемыхСубконто.Добавить(НомерСубконто);
		КонецЕсли;

	КонецЦикла;	
	
	СписокОтборовПоСубконто(КомпоновщикНастроек.Настройки.Отбор.Элементы, НомераОтбираемыхСубконто);
	
	Если НомераОтбираемыхСубконто.Количество() = 0 Тогда // Группировка и отборы по субконто не используются.
		Возврат;
	КонецЕсли;

	// Упорядочим и свернем массив номеров субконто.
	НомераИспользуемыхСубконтоСчетаГруппы = Новый Массив;
	Для НомерСубконто = 1 По БухгалтерскийУчет.МаксимальноеКоличествоСубконто() Цикл
		Если НомераОтбираемыхСубконто.Найти(НомерСубконто) <> Неопределено Тогда
			НомераИспользуемыхСубконтоСчетаГруппы.Добавить(НомерСубконто);
		КонецЕсли;
	КонецЦикла;

	ПараметрСчет = БухгалтерскиеОтчетыКлиентСервер.ПолучитьПараметр(КомпоновщикНастроек, "Счет");
	
	// Проверяем наличие видов субконто субсчетов, которые не совпадают с видами субконто счета-группы.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СчетГруппа",     ПараметрыОтчета.Счет);
	Запрос.УстановитьПараметр("Субсчета",       ПараметрСчет.Значение);
	Запрос.УстановитьПараметр("НомераИспользуемыхСубконтоСчетаГруппы", НомераИспользуемыхСубконтоСчетаГруппы);
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ХозрасчетныйВидыСубконто_СчетГруппа.НомерСтроки КАК НомерСубконто,
	|	ХозрасчетныйВидыСубконто_Субсчета.НомерСтроки КАК НомерСубконтоСубсчета,
	|	Хозрасчетный_Субсчета.Ссылка КАК Субсчет
	|ИЗ
	|	ПланСчетов.Хозрасчетный.ВидыСубконто КАК ХозрасчетныйВидыСубконто_СчетГруппа
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный КАК Хозрасчетный_Субсчета
	|		ПО (Хозрасчетный_Субсчета.Ссылка В (&Субсчета))
	|			И (Хозрасчетный_Субсчета.Ссылка <> &СчетГруппа)
	|		ЛЕВОЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный.ВидыСубконто КАК ХозрасчетныйВидыСубконто_Субсчета
	|		ПО (Хозрасчетный_Субсчета.Ссылка = ХозрасчетныйВидыСубконто_Субсчета.Ссылка)
	|			И ХозрасчетныйВидыСубконто_СчетГруппа.ВидСубконто = ХозрасчетныйВидыСубконто_Субсчета.ВидСубконто
	|ГДЕ
	|	ХозрасчетныйВидыСубконто_СчетГруппа.Ссылка = &СчетГруппа
	|	И ХозрасчетныйВидыСубконто_СчетГруппа.НомерСтроки В(&НомераИспользуемыхСубконтоСчетаГруппы)
	|	И ХозрасчетныйВидыСубконто_СчетГруппа.НомерСтроки <> ЕСТЬNULL(ХозрасчетныйВидыСубконто_Субсчета.НомерСтроки, 0)
	|
	|УПОРЯДОЧИТЬ ПО
	|	Субсчет";
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда // нет несовпадающих видов субконто среди субсчетов
		Возврат;
	КонецЕсли;
	
	КартаСубконто = КартаСубконто(ПараметрыОтчета.Счет, НомераИспользуемыхСубконтоСчетаГруппы, ПараметрСчет.Значение);

	// Структура "Анализа счета" такова, что данные по кор.счетам выводятся на самом нижнем уровне (после всех субконто
	// основного счета). При этом, если у каких-то субсчетов нет всех субконто, которые есть у счета-группы, выбранного в
	// отчете, то строку с пустым значением субконто вывести необходимо, чтобы вывести лежащие под ней строки с кор.счетами.
	// В отчетах, где кор.счета выводятся в колонках (например, "Обороты счета") такого не требуется, поэтому
	// отсутствующее субконто не выводится.
	ВыводитьОтсутствующиеВидыСубконто = (ПараметрыОтчета.ИдентификаторОтчета = "АнализСчета");
	Если ВыводитьОтсутствующиеВидыСубконто Тогда
		// Если у субсчета N01 есть Субконто1 и Субконто2, а у субсчета N02 только Субконто1,
		// то у N02 строки группировки по Субконто2 выводим как пустое значение.
		МаксНомерЗаполненногоСубконто = 0;
		Для Каждого СтрокаКарты Из КартаСубконто Цикл
			Для НомерСубконто = 1 По БухгалтерскийУчет.МаксимальноеКоличествоСубконто() Цикл
				НомерСубконтоВиртуальнойТаблицы = СтрокаКарты["СубконтоВиртуальнойТаблицыВПозиции" + НомерСубконто];
				Если ЗначениеЗаполнено(НомерСубконтоВиртуальнойТаблицы) И МаксНомерЗаполненногоСубконто < НомерСубконто Тогда
					МаксНомерЗаполненногоСубконто = НомерСубконто;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
	КонецЕсли;

	ПодготовитьСхемуКомпоновкиДанныхДляИзменения(ПараметрыОтчета, Схема, КомпоновщикНастроек);
	
	ТекстОсновнойНаборДанных = Схема.НаборыДанных[ИмяОсновногоНабора].Элементы.ОсновнойНаборДанных.Запрос;
	ТекстОбороты = Схема.НаборыДанных[ИмяОсновногоНабора].Элементы.Обороты.Запрос;

	Для НомерКомбинацииСубконто = 1 По КартаСубконто.Количество() Цикл

		СтрокаКарты = КартаСубконто[НомерКомбинацииСубконто - 1];

		Если Не ВыводитьОтсутствующиеВидыСубконто Тогда
			// Если у субсчета N01 есть Субконто1 и Субконто2, а у субсчета N02 только Субконто1,
			// то у N02 строки группировки по Субконто2 в отчет не выводим.
			МаксНомерЗаполненногоСубконто = БухгалтерскийУчет.МаксимальноеКоличествоСубконто();
			Пока МаксНомерЗаполненногоСубконто > 0
			   И Не ЗначениеЗаполнено(СтрокаКарты["СубконтоВиртуальнойТаблицыВПозиции" + МаксНомерЗаполненногоСубконто]) Цикл
				
				МаксНомерЗаполненногоСубконто = МаксНомерЗаполненногоСубконто - 1;
				
			КонецЦикла;
			
		КонецЕсли;

		ТекстЗапроса = ЗаменитьНомераСубконтоВТексте(ТекстОсновнойНаборДанных, СтрокаКарты, МаксНомерЗаполненногоСубконто);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Счет", "&Счет" + НомерКомбинацииСубконто);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВидыСубконто", "&ВидыСубконто" + НомерКомбинацииСубконто);
		ОсновнойНаборДанныхСводный = ?(НомерКомбинацииСубконто > 1, ОсновнойНаборДанныхСводный + "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|", "") + ТекстЗапроса;
		
		ТекстЗапроса = ЗаменитьНомераСубконтоВТексте(ТекстОбороты, СтрокаКарты, МаксНомерЗаполненногоСубконто);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Счет", "&Счет" + НомерКомбинацииСубконто);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВидыСубконто",
			?(СтрокаКарты.ВидыСубконто.Количество() = 0, "", "&ВидыСубконто" + НомерКомбинацииСубконто));
		ОборотыСводный = ?(НомерКомбинацииСубконто > 1, ОборотыСводный + "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|", "") + ТекстЗапроса;
		
		Если НомерКомбинацииСубконто = 1 Тогда

			// Для подзапросов, начиная со второго, исключим из текста шаблона недопустимые 
			// конструкции языка запросов (РАЗРЕШЕННЫЕ и др.).
			УдалитьОднократноИспользуемыеКонструкцииЗапроса(ТекстОсновнойНаборДанных);
			УдалитьОднократноИспользуемыеКонструкцииЗапроса(ТекстОбороты);
			
		КонецЕсли;
		
	КонецЦикла; 

	// Заново инициализируем СКД, чтобы стали доступны параметры-списки счетов и видов субконто для подзапросов.
	Схема.НаборыДанных[ИмяОсновногоНабора].Элементы.ОсновнойНаборДанных.Запрос = ОсновнойНаборДанныхСводный;
	Схема.НаборыДанных[ИмяОсновногоНабора].Элементы.Обороты.Запрос = ОборотыСводный;
	Для НомерКомбинацииСубконто = 1 По КартаСубконто.Количество() Цикл
	
		СтрокаКарты = КартаСубконто[НомерКомбинацииСубконто - 1];

		ПараметрСхемы = Схема.Параметры.Добавить();
		ПараметрСхемы.Имя                      = "Счет" + НомерКомбинацииСубконто;
		ПараметрСхемы.Заголовок                = ПараметрСхемы.Имя;
		ПараметрСхемы.ТипЗначения              = Новый ОписаниеТипов("ПланСчетовСсылка.Хозрасчетный");
		ПараметрСхемы.ДоступенСписокЗначений   = Истина;
		ПараметрСхемы.ВключатьВДоступныеПоля   = Истина;
		ПараметрСхемы.ОграничениеИспользования = Истина;
	
		
		ПараметрСхемы = Схема.Параметры.Добавить();
		ПараметрСхемы.Имя                      = "ВидыСубконто" + НомерКомбинацииСубконто;
		ПараметрСхемы.Заголовок                = ПараметрСхемы.Имя;
		ПараметрСхемы.ТипЗначения              = Новый ОписаниеТипов("ПланВидовХарактеристикСсылка.ВидыСубконтоХозрасчетные");
		ПараметрСхемы.ДоступенСписокЗначений   = Истина;
		ПараметрСхемы.ВключатьВДоступныеПоля   = Истина;
		ПараметрСхемы.ОграничениеИспользования = Истина;
	
	КонецЦикла;

	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(Схема));
	Для НомерКомбинацииСубконто = 1 По КартаСубконто.Количество() Цикл

		СтрокаКарты = КартаСубконто[НомерКомбинацииСубконто - 1];

		БухгалтерскиеОтчетыКлиентСервер.УстановитьПараметр(
			КомпоновщикНастроек,
			"Счет" + НомерКомбинацииСубконто,
			СтрокаКарты.Счета);
			
		БухгалтерскиеОтчетыКлиентСервер.УстановитьПараметр(
			КомпоновщикНастроек,
			"ВидыСубконто" + НомерКомбинацииСубконто,
			СтрокаКарты.ВидыСубконто);
	
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает свойства поля связанного набора данных для стандартных бухгалтерских отчетов.
//
// Параметры:
//	ПолеНабора - ПолеНабораДанныхСхемыКомпоновкиДанных  - Поле набора данных.
//	Схема - СхемаКомпоновкиДанных - Схема отчета.
//	ИмяНабора - Строка - Имя связанного набора.
//	ПараметрыПоляВладельца - Структура - Содержит ключ:
//		* ИндексСубконто - Число - Номер субконто.
//		* ЗаголовокСубконто - Строка - Название вида субконто.
//	ИмяПоляПрефикс - Строка - Префикс для имени поля.
//
Процедура ОбработатьПолеНабораДанныхСвязаннойИнформации(ПолеНабора, Схема, ИмяНабора, ПараметрыПоляВладельца, ИмяПоляПрефикс = "Субконто") Экспорт

	Если СтрНайти(ПолеНабора.Поле, "ОС_Владелец") Тогда
			
		ПолеНабора.ОграничениеИспользования.Группировка = Ложь;
		ПолеНабора.ОграничениеИспользования.Условие     = Ложь;
		
	КонецЕсли;

КонецПроцедуры

//-- НЕ УТ

#КонецОбласти

#Область НастройкиОтчета

//++ НЕ УТ

// Вызывается в одноименной процедуре модуля объекта отчета. Является обработчиком события подсистемы ВариантыОтчетов из БСП.
//
// Параметры:
//   КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - из настраиваемого отчета.
//   НовыеПользовательскиеНастройкиКД - ПользовательскиеНастройкиКомпоновкиДанных - в ДополнительныеСвойства содержат параметры настройки.
//   Форма - ФормаКлиентскогоПриложения - форма отчета.
//
// См. описание процедуры ПриЗагрузкеПользовательскихНастроекНаСервере() из подсистемы ВариантыОтчетов в БСП и описание
// настроек из ОтчетыКлиентСервер.НастройкиОтчетаПоУмолчанию()
//
Процедура ПриЗагрузкеПользовательскихНастроекНаСервере(Форма, НовыеПользовательскиеНастройкиКД, КомпоновщикНастроек) Экспорт
	
	ПриЗагрузкеПользовательскихНастроек(Форма.Отчет, НовыеПользовательскиеНастройкиКД, КомпоновщикНастроек);
	ПриЗагрузкеПользовательскихНастроекНастройкаФормы(Форма, НовыеПользовательскиеНастройкиКД, КомпоновщикНастроек);
	
КонецПроцедуры

// Заполняет настройки СКД на основе переданных настроек по требованиям банка.
//
// Параметры:
//   КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - из настраиваемого отчета.
//   НовыеПользовательскиеНастройкиКД - ПользовательскиеНастройкиКомпоновкиДанных - в ДополнительныеСвойства содержат параметры настройки.
//
// См. реализацию процедуры ПриЗагрузкеПользовательскихНастроекНаСервере() в модуле объекта отчета, вызываемую согласно
// настройкам из ОтчетыКлиентСервер.НастройкиОтчетаПоУмолчанию()
//
Процедура ПриЗагрузкеПользовательскихНастроек(Отчет, НовыеПользовательскиеНастройкиКД, КомпоновщикНастроек) Экспорт

	ПараметрыОтчета = НовыеПользовательскиеНастройкиКД.ДополнительныеСвойства;
	Если Не ПараметрыОтчета.Свойство("ДополнительныеПоля") Тогда // проверяем, что заданы настройки отчета в режиме выгрузки
		Возврат;
	КонецЕсли;
	
	// ГРУППИРОВКИ
	ДоступныеПоля = КомпоновщикНастроек.Настройки.ДоступныеПоляГруппировок;
	КоличествоГруппировок = ПараметрыОтчета.Группировка.Количество();
	ИндексГруппировки = 0;
	Пока ИндексГруппировки < КоличествоГруппировок Цикл
		
		ПолеГруппировки = Новый ПолеКомпоновкиДанных(ПараметрыОтчета.Группировка[ИндексГруппировки].Поле);
		Если ДоступныеПоля.НайтиПоле(ПолеГруппировки) = Неопределено Тогда
			ПараметрыОтчета.Группировка.Удалить(ИндексГруппировки);
			КоличествоГруппировок = КоличествоГруппировок - 1;
		Иначе
			ИндексГруппировки = ИндексГруппировки + 1;
		КонецЕсли;

	КонецЦикла;
	Если КоличествоГруппировок > 0 Тогда
		ЗаполнитьУровеньГруппировки(КомпоновщикНастроек.Настройки.Структура, ПараметрыОтчета.Группировка);
	КонецЕсли;
	
	// ПОЛЯ ОТЧЕТА
	ЦелеваяНастройка = НайтиСоздатьНастройкуКомпоновщика(
		"Выбор", КомпоновщикНастроек, НовыеПользовательскиеНастройкиКД);
	Для Каждого ДопПоле Из ПараметрыОтчета.ДополнительныеПоля Цикл
		
		Для Каждого ПолеКомпоновки Из ЦелеваяНастройка.Элементы Цикл
			Если Строка(ПолеКомпоновки.Поле) = ДопПоле.Поле Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ПолеКомпоновки = Неопределено Или Строка(ПолеКомпоновки.Поле) <> ДопПоле.Поле Тогда
			ПолеКомпоновки = ЦелеваяНастройка.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
			ПолеКомпоновки.Поле          = Новый ПолеКомпоновкиДанных(ДопПоле.Поле);
		КонецЕсли;
		ПолеКомпоновки.Заголовок     = ДопПоле.Представление;
		ПолеКомпоновки.Использование = Истина;
		
	КонецЦикла;
	// Включение только полей-показателей обеспечивается выбором варианта отчета.
	
	// ПАРАМЕТРЫ ВЫВОДА
	ЦелеваяНастройка = НайтиСоздатьНастройкуКомпоновщика(
		"ПараметрВывода", КомпоновщикНастроек, НовыеПользовательскиеНастройкиКД, "РасположениеРеквизитов");
	Если ПараметрыОтчета.РазмещениеДополнительныхПолей = БухгалтерскиеОтчетыКлиентСервер.РазмещениеДополнительныхПолей().ВместеСВладельцем Тогда
		ЦелеваяНастройка.Значение = РасположениеРеквизитовКомпоновкиДанных.ВместеСВладельцем;
	ИначеЕсли ПараметрыОтчета.РазмещениеДополнительныхПолей = БухгалтерскиеОтчетыКлиентСервер.РазмещениеДополнительныхПолей().Отдельно Тогда
		ЦелеваяНастройка.Значение = РасположениеРеквизитовКомпоновкиДанных.Отдельно;
	КонецЕсли;
	ЦелеваяНастройка.Использование = Истина;
	
	// ПАРАМЕТРЫ ОТЧЕТА
	ЦелеваяНастройка = НайтиСоздатьНастройкуКомпоновщика(
		"ПараметрДанных", КомпоновщикНастроек, НовыеПользовательскиеНастройкиКД, "ПериодОтчета");
	ЗаполнитьСтандартныйПериод(ЦелеваяНастройка.Значение, ПараметрыОтчета.НачалоПериода, ПараметрыОтчета.КонецПериода);
	ЦелеваяНастройка.Использование = Истина;
	
	// ОТБОРЫ ОТЧЕТА
	ЦелеваяНастройка = НайтиСоздатьНастройкуКомпоновщика(
		"Отбор", КомпоновщикНастроек, НовыеПользовательскиеНастройкиКД, "Организация");
	Если ЗначениеЗаполнено(ПараметрыОтчета.Организация) Тогда
		
		Если ПараметрыОтчета.ВключатьОбособленныеПодразделения Тогда
			// Заменяем отбор по организации на отбор по списку организаций, которые входят в группу (имеют одну и ту же головную организацию).
			Для Каждого ЭлементОтбора Из КомпоновщикНастроек.Настройки.Отбор.Элементы Цикл
				Если ЭлементОтбора.ИдентификаторПользовательскойНастройки <> ЦелеваяНастройка.ИдентификаторПользовательскойНастройки Тогда
					Продолжить;
				КонецЕсли;
				ЦелеваяНастройка.Использование = Ложь;
				ЭлементОтбора.ИдентификаторПользовательскойНастройки = Неопределено;
				
				ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Организация.ГоловнаяОрганизация");
				ЭлементОтбора.ИдентификаторПользовательскойНастройки = Новый УникальныйИдентификатор;
				ЦелеваяНастройка = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(ЭлементОтбора.ИдентификаторПользовательскойНастройки);
				Прервать;
				
			КонецЦикла;
			
		КонецЕсли;
		ЦелеваяНастройка.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ЦелеваяНастройка.ПравоеЗначение = ПараметрыОтчета.Организация;
		ЦелеваяНастройка.Использование = Истина;
		
	Иначе
		
		ЦелеваяНастройка.Использование = Ложь;
		
	КонецЕсли;
	
	// ОФОРМЛЕНИЕ
	ЦелеваяНастройка = НайтиСоздатьНастройкуКомпоновщика(
		"ПараметрВывода", КомпоновщикНастроек, НовыеПользовательскиеНастройкиКД, "ВыводитьЗаголовок");
	ЦелеваяНастройка.Значение = ?(ПараметрыОтчета.ВыводитьЗаголовок, ТипВыводаТекстаКомпоновкиДанных.Авто, ТипВыводаТекстаКомпоновкиДанных.НеВыводить);
	ЦелеваяНастройка.Использование = Истина;
	// Флаги ВыводитьЕдиницуИзмерения и ВыводитьПодвал не используются.
	
	ЦелеваяНастройка = НайтиСоздатьНастройкуКомпоновщика(
		"ПараметрВывода", КомпоновщикНастроек, НовыеПользовательскиеНастройкиКД, "МакетОформления");
	ЦелеваяНастройка.Значение = ПараметрыОтчета.МакетОформления;
	ЦелеваяНастройка.Использование = Истина;
	
	БухгалтерскиеОтчетыПереопределяемый.ПриЗагрузкеПользовательскихНастроек(Отчет, НовыеПользовательскиеНастройкиКД, КомпоновщикНастроек);
	
КонецПроцедуры

// Вызывается в обработчике одноименного события формы отчета после выполнения кода формы.
//
// Параметры:
//   КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - из настраиваемого отчета.
//   НовыеПользовательскиеНастройкиКД - ПользовательскиеНастройкиКомпоновкиДанных - в ДополнительныеСвойства содержат параметры настройки.
//   Форма - ФормаКлиентскогоПриложения - форма отчета.
//
// См. реализацию процедуры ПриЗагрузкеПользовательскихНастроекНаСервере() в модуле объекта отчета, вызываемую согласно
// настройкам из ОтчетыКлиентСервер.НастройкиОтчетаПоУмолчанию()
//
Процедура ПриЗагрузкеПользовательскихНастроекНастройкаФормы(Форма, НовыеПользовательскиеНастройкиКД, КомпоновщикНастроек) Экспорт

	Если Не Форма.НастройкиОтчета.Свойство("РежимВыгрузки") Тогда
		Возврат;
	КонецЕсли;
	
	ПараметрыОтчета = НовыеПользовательскиеНастройкиКД.ДополнительныеСвойства;
	
	// ПАРАМЕТРЫ ОТЧЕТА
	ЦелеваяНастройка = НайтиСоздатьНастройкуКомпоновщика(
		"ПараметрДанных", КомпоновщикНастроек, НовыеПользовательскиеНастройкиКД, "ПериодОтчета");
	Форма.Период1.Вариант = ЦелеваяНастройка.Значение.Вариант;
	Если Форма.Период1.Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод Тогда
		Форма.Период1.ДатаНачала = ЦелеваяНастройка.Значение.ДатаНачала;
		Форма.Период1.ДатаОкончания = ЦелеваяНастройка.Значение.ДатаОкончания;
	КонецЕсли;
	
	// ОФОРМЛЕНИЕ
	Если ПараметрыОтчета.Свойство("ВыводитьЗаголовок") Тогда
		Форма.ОтображатьЗаголовок = ПараметрыОтчета.ВыводитьЗаголовок;
	КонецЕсли;
	// Флаги ВыводитьЕдиницуИзмерения и ВыводитьПодвал не используются.
	
	Форма.НастройкиОтчета.ПараметрыРежимаВыгрузки.Вставить("ЭталонныеНастройки", КомпоновщикНастроек.ПолучитьНастройки());
	
	БухгалтерскиеОтчетыПереопределяемый.ПриЗагрузкеПользовательскихНастроекНастройкаФормы(
		Форма, НовыеПользовательскиеНастройкиКД, КомпоновщикНастроек);

КонецПроцедуры

// Сравнивает настройки, которые передавались в отчет перед его открытием, и те, которые имеются в отчете после нажатия кнопки "Выгрузить".
// Для отчетов подсистемы ВариантыОтчетов из БСП.
//
// Параметры:
//  ПараметрыРежимаВыгрузки - Структура - см. БухгалтерскиеОтчеты.ЭталонныеПараметры().
//  ТекущиеНастройки - НастройкиКомпоновкиДанных - текущие настройки из формы отчета.
// Возвращаемое значение:
//  Булево.
Функция ЕстьОтличияНастроекОтЭталонныхБСП(ПараметрыРежимаВыгрузки, ТекущиеНастройки) Экспорт
	
	ЭталонныеНастройки = ПараметрыРежимаВыгрузки.ЭталонныеНастройки;
	
	// Отбор
	Если БухгалтерскиеОтчетыВызовСервера.ЕстьОтличияОтборовОтЭталонных(ЭталонныеНастройки.Отбор, ТекущиеНастройки.Отбор) Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Доп.поля
	Если Не НаборПолейЭквивалентен(ЭталонныеНастройки.Выбор.Элементы, ТекущиеНастройки.Выбор.Элементы) Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Структура
	Если Не СтруктураЭквивалентна(ЭталонныеНастройки.Структура, ТекущиеНастройки.Структура) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

//-- НЕ УТ

// Выполняет отложенную инициализацию компоновщика настроек при загрузке пользовательских настроек.
//
// Параметры:
//  Форма                - ФормаКлиентскогоПриложения - форма отчета
//  Настройки			 - ПользовательскиеНастройкиКомпоновкиДанных - загружаемые настройки
//  ИмяВариантаНастроек	 - Строка - Имя варианта настроек.
//                         Допустимо передавать пустую строку для основного варианта.
//
Процедура ИнициализироватьКомпоновщикНастроекПриЗагрузкеПользовательскихНастроек(Форма, Настройки, ИмяВариантаНастроек = "") Экспорт
	
	Если БухгалтерскиеОтчетыКлиентСервер.КомпоновщикНастроекИнициализирован(Форма) Тогда
		Возврат;
	КонецЕсли;
	
	Форма.ПользовательскиеНастройки = ПоместитьВоВременноеХранилище(Настройки, Форма.УникальныйИдентификатор);
	
	Если ОбщегоНазначения.ЭтоВебКлиент() Тогда
		ОрганизацияИзменилась = БухгалтерскиеОтчетыКлиентСервер.ПроверитьОтложеннаяИнициализацияКомпоновщикаВызванаИзменениемОрганизации(Форма);
		БухгалтерскиеОтчетыВызовСервера.ИнициализацияКомпоновщикаНастроек(Форма, ОрганизацияИзменилась, ИмяВариантаНастроек);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет отложенную инициализацию компоновщика настроек при формировании отчета.
//
// Параметры:
//  Форма                - ФормаКлиентскогоПриложения - форма отчета
//  ИмяВариантаНастроек	 - Строка - Имя варианта настроек.
//                         Допустимо передавать пустую строку для основного варианта.
//
Процедура ИнициализироватьКомпоновщикНастроекПриФормированииОтчета(Форма, ИмяВариантаНастроек = "") Экспорт
	
	Если БухгалтерскиеОтчетыКлиентСервер.КомпоновщикНастроекИнициализирован(Форма) Тогда
		Возврат;
	КонецЕсли;
	
	ОрганизацияИзменилась = БухгалтерскиеОтчетыКлиентСервер.ПроверитьОтложеннаяИнициализацияКомпоновщикаВызванаИзменениемОрганизации(Форма);
	// Выше убедились, что отложенная инициализация используется, поэтому ОрганизацияИзменилась отлична от Неопределено.
	
	БухгалтерскиеОтчетыВызовСервера.ИнициализацияКомпоновщикаНастроек(Форма, ОрганизацияИзменилась, ИмяВариантаНастроек);
	
КонецПроцедуры

// Устанавливает имя схемы компоновки данных, которую должен использовать отчет с текущими настройками.
// Если текущая схема компоновки изменилась, сбрасывает признак инициализации компоновщика, чтобы при формировании
// отчета была выполнена повторная инициализация компоновщика с новой схемой.
// Если отчет не использует несколько рабочих схем компоновки - никаких действий не выполняется.
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - форма отчета.
//
Процедура УстановитьТекущуюСхемуКомпоновкиДанныхОтчета(Форма) Экспорт
	
	Если Не БухгалтерскиеОтчетыКлиентСервер.ОтчетПоддерживаетНесколькоСхемКомпоновкиДанных(Форма) Тогда
		Возврат;
	КонецЕсли;
	
	// Схема компоновки данных может поменяться при изменении реквизитов отчета.
	// Состав реквизитов, влияющих на выбор схемы компоновки, определяется программным интерфейсом конкретного отчета.
	
	ИмяОтчета = ИмяОтчета(Форма);
	
	ИмяАктуальнойсхемы = ИмяСхемыКомпоновкиДанныхОтчета(Форма.Отчет, ИмяОтчета);
	
	Если ИмяАктуальнойСхемы <> Форма.Отчет.ТекущаяСхемаКомпоновкиДанных Тогда
		Форма.Отчет.ТекущаяСхемаКомпоновкиДанных = ИмяАктуальнойСхемы;
		Форма.КомпоновщикИнициализирован = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Возвращает имя схемы компоновки данных, которую необходимо использовать в данном экземпляре отчета.
// Используется для отчетов, имеющих рабочих несколько схем. Необходимо вызывать до инициализации компоновщика.
//
// Отчет, поддерживающий использование нескольких схем, должен удовлетворять требованиям:
//  * иметь реквизит ТекущаяСхемаКомпоновкиДанных с типом Строка(80);
//  * содержать в программном интерфейсе функцию ТекущаяСхемаКомпоновкиДанных, принимающую единственный параметр
//    с типом Структура; в этот параметр передаются данные, влияющие на выбор схемы компоновки;
//  * содержать в программном интерфейсе конструктор НовыеПараметрыВыбораСхемыКомпоновкиДанных, формирующий структуру
//    параметров, влияющих на выбор схемы компоновки;
//
// Параметры:
//  КонтекстОтчета - ДанныеФормыСтруктура, Структура - необходимые сведения для выбора схемы компоновки данных.
//  ИмяОтчета      - Строка - имя отчета в метаданных.
//
// Возвращаемое значение:
//   Строка - имя используемой схемы компоновки данных.
//
Функция ИмяСхемыКомпоновкиДанныхОтчета(КонтекстОтчета, ИмяОтчета) Экспорт
	
	Если Не ОтчетПоддерживаетНесколькоСхемКомпоновкиДанных(ИмяОтчета) Тогда
		Возврат ИмяСхемыКомпоновкиДанныхПоУмолчанию();
	КонецЕсли;
	
	МенеджерОтчета = Отчеты[ИмяОтчета];
	
	ПараметрыВыбораСхемы = МенеджерОтчета.НовыеПараметрыВыбораСхемыКомпоновкиДанных();
	ЗаполнитьЗначенияСвойств(ПараметрыВыбораСхемы, КонтекстОтчета);
	
	Возврат МенеджерОтчета.ТекущаяСхемаКомпоновкиДанных(ПараметрыВыбораСхемы);
	
КонецФункции

// Проверяет применение нескольких рабочих схем компоновки данных в отчете.
// Критерий проверки - наличие реквизита ТекущаяСхемаКомпоновкиДанных у отчета.
//
// Параметры:
//  ИмяОтчета - Строка - имя отчета, заданное в конфигурации.
// 
// Возвращаемое значение:
//  Булево - Истина, если отчет использует несколько рабочих схем компоновки данных.
//
Функция ОтчетПоддерживаетНесколькоСхемКомпоновкиДанных(ИмяОтчета) Экспорт
	
	МетаданныеОтчета = Метаданные.Отчеты[ИмяОтчета];
	
	Возврат МетаданныеОтчета.Реквизиты.Найти("ТекущаяСхемаКомпоновкиДанных") <> Неопределено;
	
КонецФункции

//++ НЕ УТ

// В отчетах по видам субконто анализирует наличие признаков учета на счетах, содержащих выбранные субконто.
//
// Параметры:
//  Форма        - ФормаКлиентскогоПриложения - имеет основной реквизит "Отчет".
//
Процедура ЗаполнитьПризнакиУчета(Форма) Экспорт
	
	Отчет = Форма.Отчет;
	
	МассивСубконто = Новый Массив;
	Для Каждого ЭлементСписка Из Отчет.СписокВидовСубконто Цикл 
		Если ЗначениеЗаполнено(ЭлементСписка.Значение) Тогда
			МассивСубконто.Добавить(ЭлементСписка.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Если МассивСубконто.Количество() = 0 Тогда
		
		Форма.ЕстьВалюта               = Истина;
		Форма.ЕстьКоличество           = Истина;
		Форма.ЕстьНалоговыйУчет        = Истина;
		Форма.ЕстьУчетПоПодразделениям = БухгалтерскийУчетПереопределяемый.ИспользоватьПодразделения();
		Форма.ЕстьСчета                = Истина;
		Возврат;
		
	КонецЕсли;
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Хозрасчетный.Ссылка) КАК КоличествоСчетов,
	|	МАКСИМУМ(Хозрасчетный.Количественный) КАК Количественный,
	|	МАКСИМУМ(Хозрасчетный.Валютный) КАК Валютный,
	|	МАКСИМУМ(Хозрасчетный.НалоговыйУчет) КАК НалоговыйУчет,
	|	МАКСИМУМ(Хозрасчетный.УчетПоПодразделениям) КАК УчетПоПодразделениям
	|ИЗ
	|	ПланСчетов.Хозрасчетный КАК Хозрасчетный&УсловиеСоединения
	|ГДЕ
	|	&УсловиеОтбора";
	
	Запрос = Новый Запрос;
	НомерСубконто = 1;
	УсловиеСоединения = "";
	УсловиеОтбора = "";
	Для каждого ВидСубконто Из МассивСубконто Цикл
		
		УсловиеСоединения = УсловиеСоединения + "
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ПланСчетов.Хозрасчетный.ВидыСубконто КАК ХозрасчетныйВидыСубконто" + НомерСубконто + "
		|		ПО Хозрасчетный.Ссылка = ХозрасчетныйВидыСубконто" + НомерСубконто + ".Ссылка";
		УсловиеОтбора = УсловиеОтбора 
			+ ?(НомерСубконто = 1, "", "
		|	И ") + "ХозрасчетныйВидыСубконто" + НомерСубконто + ".ВидСубконто = &ВидСубконто" + НомерСубконто;

		Запрос.УстановитьПараметр("ВидСубконто" + НомерСубконто, ВидСубконто);

		НомерСубконто = НомерСубконто + 1;
		
	КонецЦикла;
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеСоединения", УсловиеСоединения);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", УсловиеОтбора);
	Запрос.Текст = ТекстЗапроса;
	
	Форма.ЕстьВалюта               = Ложь;
	Форма.ЕстьКоличество           = Ложь;
	Форма.ЕстьНалоговыйУчет        = Ложь;
	Форма.ЕстьУчетПоПодразделениям = Ложь;
	Форма.ЕстьСчета                = Ложь;
	
	ВыборкаСчета = Запрос.Выполнить().Выбрать();
	Пока ВыборкаСчета.Следующий() Цикл
		
		Форма.ЕстьВалюта               = ?(ВыборкаСчета.Валютный             = Истина, Истина, Ложь);
		Форма.ЕстьКоличество           = ?(ВыборкаСчета.Количественный       = Истина, Истина, Ложь);
		Форма.ЕстьНалоговыйУчет        = ?(ВыборкаСчета.НалоговыйУчет        = Истина, Истина, Ложь);
		Форма.ЕстьУчетПоПодразделениям = ?(ВыборкаСчета.УчетПоПодразделениям = Истина,
			БухгалтерскийУчетПереопределяемый.ИспользоватьПодразделения(), Ложь);
		Форма.ЕстьСчета                = ?(ВыборкаСчета.КоличествоСчетов     = 0, Ложь, Истина);  
		
	КонецЦикла;
	
	Отчет.ПоказательВалютнаяСумма = Отчет.ПоказательВалютнаяСумма И Форма.ЕстьВалюта;
	Отчет.ПоказательКоличество = Отчет.ПоказательКоличество И Форма.ЕстьКоличество;
	Отчет.ПоказательНУ = Отчет.ПоказательНУ И Форма.ЕстьНалоговыйУчет;
	Отчет.ПоказательПР = Отчет.ПоказательПР И Форма.ЕстьНалоговыйУчет;
	Отчет.ПоказательВР = Отчет.ПоказательВР И Форма.ЕстьНалоговыйУчет;
	Если Отчет.Свойство("ПоказательКонтроль") Тогда
		Отчет.ПоказательКонтроль = Отчет.ПоказательКонтроль И Форма.ЕстьНалоговыйУчет;
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет структуру опций, используемых для указания настроек отчета.
//
// Параметры:
//  Форма        - ФормаКлиентскогоПриложения - имеет основной реквизит "Отчет".
//  Разделитель  - ПланСчетовСсылка.Хозрасчетный, ПланВидовХарактеристикСсылка.ВидыСубконтоХозрасчетные - разделитель
//                              сохраняемых настроек.
//
Процедура СохранитьОписаниеНастроек(Форма, Разделитель) Экспорт
	
	Если Не ЗначениеЗаполнено(Разделитель) Тогда
		Возврат;
	КонецЕсли;
	ИмяРазделителя = Разделитель.Метаданные().Имя;
	ИмяОтчета = ИмяОтчета(Форма);
	Отчет = Форма.Отчет;
	
	Если ИмяРазделителя = "ВидыСубконтоХозрасчетные" Тогда
		
		Если Отчет.СписокВидовСубконто.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		СписокВидовСубконто = Отчет.СписокВидовСубконто.Скопировать();
		СписокВидовСубконто[0].Значение = Разделитель;
		КоличествоСубконто = СписокВидовСубконто.Количество();
		КоличествоСубконтоМаксимум = БухгалтерскийУчет.МаксимальноеКоличествоСубконто();
		Для НомерСубконто = 1 По КоличествоСубконто Цикл
			ИндексСКонца = КоличествоСубконто - НомерСубконто;
			Если ИндексСКонца > КоличествоСубконтоМаксимум - 1
			 Или Не ЗначениеЗаполнено(СписокВидовСубконто[ИндексСКонца].Значение) Тогда
				СписокВидовСубконто.Удалить(ИндексСКонца);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	// Подготавливаем структуру настроек.
	ОписаниеНастройки = Новый Структура;
	
	// Управление показателями.
	ТипБулево = Тип("Булево");
	КоллекцияНастроек = Отчеты[ИмяОтчета].СохраняемыеОпции();
	КоллекцияВключенныхНастроек = Новый Структура;
	Для каждого Показатель Из КоллекцияНастроек Цикл
		Если ТипЗнч(Отчет[Показатель]) <> ТипБулево Или Отчет[Показатель] Тогда
			КоллекцияВключенныхНастроек.Вставить(Показатель, Отчет[Показатель]);
		КонецЕсли;
	КонецЦикла;
	Если ИмяРазделителя = "ВидыСубконтоХозрасчетные"
	   И КоллекцияВключенныхНастроек.Свойство("СписокВидовСубконто") Тогда
		КоллекцияВключенныхНастроек.СписокВидовСубконто = СписокВидовСубконто;
	КонецЕсли;
	ОписаниеНастройки.Вставить("Показатели", КоллекцияВключенныхНастроек);
	
	// Группировки.
	Если Отчет.Свойство("Группировка") Тогда
		КоллекцияВключенныхНастроек = Отчет.Группировка.Выгрузить(, "Использование, Поле, Представление, ТипГруппировки");
		ОписаниеНастройки.Вставить("Группировка", КоллекцияВключенныхНастроек);
	КонецЕсли;
	
	// Отбор.
	// Фиксируем сам факт, что отбор нужно перезаполнять. Однако используем не сохраненные ранее настройки,
	// а алгоритмическим преобразованием. См. ПреобразоватьОтборыПоСчету()
	ОписаниеНастройки.Вставить("Отбор", Неопределено);
	
	// Дополнительные поля.
	Если Отчет.Свойство("ДополнительныеПоля") Тогда
		КоллекцияВключенныхНастроек = Отчет.ДополнительныеПоля.Выгрузить(, "Использование, Поле, Представление");
		ОписаниеНастройки.Вставить("ДополнительныеПоля", КоллекцияВключенныхНастроек);
	КонецЕсли;
	
	// Сортировка.
	Если ИмяРазделителя = "Хозрасчетный" Тогда
		ДанныеСчета = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Форма.СчетИсходноеЗначение);
		КоллекцияВключенныхНастроек = ОписаниеСортировки(Отчет.КомпоновщикНастроек.Настройки.Порядок.Элементы, ДанныеСчета);
	Иначе
		КоллекцияВключенныхНастроек = ОписаниеСортировки(Отчет.КомпоновщикНастроек.Настройки.Порядок.Элементы);
	КонецЕсли;
	ОписаниеНастройки.Вставить("Порядок", КоллекцияВключенныхНастроек);
	
	// Подготавливаем и сохраняем контейнер.
	
	КлючиОписанияНастройки = КлючиОписанияНастройки(ИмяОтчета, ИмяРазделителя, Разделитель);	
	ХранилищеПользовательскихНастроекОтчетов.Сохранить(
		КлючиОписанияНастройки.КлючОбъекта,
		КлючиОписанияНастройки.КлючНастроек,
		ОписаниеНастройки,
		КлючиОписанияНастройки);
	
КонецПроцедуры

// Задает структуру опций, используемых для указания настроек отчета. Если нет ранее сохраненных настроек,
// то устанавливаются настройки по-умолчанию.
//
// Параметры:
//  Форма        - ФормаКлиентскогоПриложения - имеет основной реквизит "Отчет".
//  Разделитель  - ПланСчетовСсылка.Хозрасчетный, ПланВидовХарактеристикСсылка.ВидыСубконтоХозрасчетные - разделитель
//                              сохраняемых настроек.
//  ТолькоОбновление - Строка - если Ложь, то читается ранее сохраненная настройка; если Истина, то только проверяется
//                              корректность текущей настройки.
//
Процедура ПрочитатьОписаниеНастроек(Форма, Разделитель, ТолькоОбновление = Ложь) Экспорт
	
	Перем КоллекцияВключенныхНастроек;
	
	Если Не ЗначениеЗаполнено(Разделитель) Тогда
		Возврат;
	КонецЕсли;
	ИмяРазделителя = Разделитель.Метаданные().Имя;
	ИмяОтчета = ИмяОтчета(Форма);
	Отчет = Форма.Отчет;
	
	// Получаем источник применяемых настроек.
	Если ТолькоОбновление Тогда // лишь обновить настройки
		
		Если ИмяРазделителя = "ВидыСубконтоХозрасчетные" Тогда
			// Используем заданный сейчас в отчете список видов субконто. Для случая изменения одного из неосновных субконто.
			Форма.ИзменениеСхемыКомпоновкиДанныхНаСервере();
			ЗаполнитьПризнакиУчета(Форма);
			СписокВидовСубконто = Отчет.СписокВидовСубконто;
			
		Иначе
			
			ТекстИсключения = НСтр("ru = 'Разделитель настроек ""%1"" не используется для обновления настроек.';
									|en = 'The ""%1"" setting separator is not used for the settings update.'");
			ВызватьИсключение СтрШаблон(ТекстИсключения, ИмяРазделителя);
			
		КонецЕсли;
		
		// Подготавливаем текущие настройки к преобразованию.
		ОписаниеНастройки = Новый Структура;
		Если Отчет.Свойство("Группировка") Тогда
			КоллекцияВключенныхНастроек = Отчет.Группировка.Выгрузить(, "Использование, Поле, Представление, ТипГруппировки");
			ОписаниеНастройки.Вставить("Группировка", КоллекцияВключенныхНастроек);
		КонецЕсли;
		ОписаниеНастройки.Вставить("Отбор", Неопределено);
		Если Отчет.Свойство("ДополнительныеПоля") Тогда
			КоллекцияВключенныхНастроек = Отчет.ДополнительныеПоля.Выгрузить(, "Использование, Поле, Представление");
			ОписаниеНастройки.Вставить("ДополнительныеПоля", КоллекцияВключенныхНастроек);
		КонецЕсли;
		КоллекцияВключенныхНастроек = ОписаниеСортировки(Отчет.КомпоновщикНастроек.Настройки.Порядок.Элементы);
		ОписаниеНастройки.Вставить("Порядок", КоллекцияВключенныхНастроек);
		
	Иначе // прочитать ранее сохраненные
		
		КлючиОписанияНастройки = КлючиОписанияНастройки(ИмяОтчета, ИмяРазделителя, Разделитель);
		ОписаниеНастройки = ХранилищеПользовательскихНастроекОтчетов.Загрузить(
			КлючиОписанияНастройки.КлючОбъекта,
			КлючиОписанияНастройки.КлючНастроек);
		
		Если ОписаниеНастройки = Неопределено Тогда // нет ранее сохраненного описания
		
			Если ИмяРазделителя = "ВидыСубконтоХозрасчетные" Тогда
				Форма.ИзменениеСхемыКомпоновкиДанныхНаСервере();
				ЗаполнитьПризнакиУчета(Форма);
			КонецЕсли;
			
			ЗаполняемыеНастройки = Новый Структура;
			ЗаполняемыеНастройки.Вставить("Показатели",         Истина);
			ЗаполняемыеНастройки.Вставить("Группировка",        Отчет.Свойство("Группировка"));
			ЗаполняемыеНастройки.Вставить("Отбор",              Истина);
			ЗаполняемыеНастройки.Вставить("ДополнительныеПоля", Отчет.Свойство("ДополнительныеПоля"));
			ЗаполняемыеНастройки.Вставить("Порядок",            Истина);
			ЗаполняемыеНастройки.Вставить("ВыводимыеДанные",    ИмяОтчета = "ОборотыСчета");

			Форма.ЗаполнитьНастройкамиПоУмолчанию(ЗаполняемыеНастройки);
			БухгалтерскиеОтчетыВызовСервера.ОбновитьОписаниеОтборовОтчета(Форма);
			Возврат;
			
		Иначе // используем ранее сохраненное описание настроек
			
			Если ИмяРазделителя = "ВидыСубконтоХозрасчетные" Тогда
			
				СписокВидовСубконто = Неопределено;
				Если Не ОписаниеНастройки.Свойство("Показатели")
				 Или Не ОписаниеНастройки.Показатели.Свойство("СписокВидовСубконто", СписокВидовСубконто) Тогда
					// Используем заданный сейчас в отчете список видов субконто.
					СписокВидовСубконто = Отчет.СписокВидовСубконто;
				Иначе
					// Используем ранее сохраненный список видов субконто.
					Отчет.СписокВидовСубконто = СписокВидовСубконто;
				КонецЕсли;
				Форма.ИзменениеСхемыКомпоновкиДанныхНаСервере();
				ЗаполнитьПризнакиУчета(Форма);
				
			ИначеЕсли ИмяРазделителя <> "Хозрасчетный" Тогда
				
				ТекстИсключения = НСтр("ru = 'Разделитель настроек ""%1"" не используется для хранения настроек.';
										|en = 'The ""%1"" setting separator is not used for storing the settings.'");
				ВызватьИсключение СтрШаблон(ТекстИсключения, ИмяРазделителя);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Получаем параметры, влияющие на настройки отчета.
	Если ИмяРазделителя = "Хозрасчетный" Тогда
		
		ДанныеСчета = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Отчет.Счет);
		КоличествоСубконто       = ДанныеСчета.КоличествоСубконто;
		ЕстьУчетПоПодразделениям = БухгалтерскийУчетПереопределяемый.ИспользоватьПодразделения() И ДанныеСчета.УчетПоПодразделениям;
		ЕстьУчетПоНаправлениямДеятельности = БухгалтерскийУчетПереопределяемый.ИспользоватьНаправленияДеятельности() И ДанныеСчета.УчетПоНаправлениямДеятельности;
			
	ИначеЕсли ИмяРазделителя = "ВидыСубконтоХозрасчетные" Тогда
		
		ДанныеСчета = Новый Структура;
		ДанныеСчета.Вставить("Вид",            ?(Форма.ЕстьСчета, ВидСчета.АктивноПассивный, Неопределено));
		ДанныеСчета.Вставить("Валютный",       Форма.ЕстьВалюта);
		ДанныеСчета.Вставить("Количественный", Форма.ЕстьКоличество);
		
		НомерСубконто = 1;
		КоличествоСубконто = СписокВидовСубконто.Количество();
		Для каждого ВидСубконто Из СписокВидовСубконто Цикл
			Если ЗначениеЗаполнено(ВидСубконто.Значение) Тогда
				ДанныеСчета.Вставить("ВидСубконто" + НомерСубконто, ВидСубконто.Значение);
				НомерСубконто = НомерСубконто + 1;
			Иначе
				КоличествоСубконто = КоличествоСубконто - 1;
			КонецЕсли;
		КонецЦикла;

		ЕстьУчетПоПодразделениям = БухгалтерскийУчетПереопределяемый.ИспользоватьПодразделения();
		ЕстьУчетПоНаправлениямДеятельности = БухгалтерскийУчетПереопределяемый.ИспользоватьНаправленияДеятельности();
		
	КонецЕсли;
	НеиспользуемаяАналитика = ПланыСчетов.Хозрасчетный.НеиспользуемаяАналитика();
	
	Если ОписаниеНастройки.Свойство("Показатели", КоллекцияВключенныхНастроек) Тогда
		
		ТипБулево = Тип("Булево");
		КоллекцияНастроек = Отчеты[ИмяОтчета].СохраняемыеОпции();
		// Сбрасываем все флаги.
		Для каждого Показатель Из КоллекцияНастроек Цикл
			Если ТипЗнч(Отчет[Показатель]) = ТипБулево И Отчет[Показатель] Тогда // только для типа Булево
				Отчет[Показатель] = Ложь;
			КонецЕсли;
		КонецЦикла;
		// Устанавливаем нужные флаги и свойства.
		ОдинИзПоказателейОтмечен = Ложь;
		Для каждого Показатель Из КоллекцияВключенныхНастроек Цикл
			
			Если Не Отчет.Свойство(Показатель.Ключ) Тогда
				Продолжить;
			КонецЕсли;
			
			Если Показатель.Ключ = "ПоказательВалютнаяСумма" Тогда
				Отчет[Показатель.Ключ] = ДанныеСчета.Валютный;
			ИначеЕсли Показатель.Ключ = "ПоказательКоличество" Тогда
				Отчет[Показатель.Ключ] = ДанныеСчета.Количественный;
			ИначеЕсли Показатель.Ключ = "РазвернутоеСальдо" Тогда
				Отчет[Показатель.Ключ] = (ДанныеСчета.Вид = ВидСчета.АктивноПассивный);
			Иначе
				Отчет[Показатель.Ключ] = Показатель.Значение;
			КонецЕсли;
			Если Не ОдинИзПоказателейОтмечен
			   И ТипЗнч(Показатель.Значение) = ТипБулево И Показатель.Значение
			   И Лев(Показатель.Ключ, 10) = "Показатель" Тогда
				ОдинИзПоказателейОтмечен = Истина;
			КонецЕсли;
			
		КонецЦикла;
		Если Не ОдинИзПоказателейОтмечен Тогда
			Отчет.ПоказательБУ = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
	ДоступныеПоляГруппировок = Отчет.КомпоновщикНастроек.Настройки.ДоступныеПоляГруппировок;
	Если ОписаниеНастройки.Свойство("Группировка", КоллекцияВключенныхНастроек) Тогда
		
		// Удаляем сохраненные группировки, которые стали некорректными.
		ИсключаемыеНастройки = Новый Массив;
		Если Не ЕстьУчетПоПодразделениям Тогда
			ИсключаемыеНастройки.Добавить("Подразделение");
		КонецЕсли;
		Если Не ЕстьУчетПоНаправлениямДеятельности Тогда
			ИсключаемыеНастройки.Добавить("НаправлениеДеятельности");
		КонецЕсли;
		Если Не ДанныеСчета.Валютный Тогда
			ИсключаемыеНастройки.Добавить("Валюта");
		КонецЕсли;
		Для НомерСубконто = 1 По КоличествоСубконто Цикл
			
			Если НеиспользуемаяАналитика.Найти(ДанныеСчета["ВидСубконто" + НомерСубконто]) <> Неопределено Тогда
				ИсключаемыеНастройки.Добавить("Субконто" + НомерСубконто);
			Иначе // проверяем, что состав субконто на счете не изменился
				ОписаниеПоля = ДоступныеПоляГруппировок.НайтиПоле(Новый ПолеКомпоновкиДанных("Субконто" + НомерСубконто));
				Если ОписаниеПоля = Неопределено Тогда
					ИсключаемыеНастройки.Добавить("Субконто" + НомерСубконто);
				Иначе
					ИндексПоля = ИндексПоляВКоллекции(КоллекцияВключенныхНастроек, "Субконто" + НомерСубконто);
					Если ИндексПоля <> Неопределено Тогда // ранее была группировка для этого субконто
						ПредставлениеПоля = КоллекцияВключенныхНастроек[ИндексПоля].Представление;
						ДлинаПредставленияПоля = СтрДлина(ОписаниеПоля.Заголовок);
						Если ОписаниеПоля.Заголовок <> Лев(ПредставлениеПоля, ДлинаПредставленияПоля) Тогда
							// Субконто сдвинулись.
							ИсключаемыеНастройки.Добавить("Субконто" + НомерСубконто);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли; 
			
		КонецЦикла;
		Для НомерСубконто = КоличествоСубконто + 1 По БухгалтерскийУчет.МаксимальноеКоличествоСубконто() Цикл
			ИсключаемыеНастройки.Добавить("Субконто" + НомерСубконто);
		КонецЦикла;
		Для каждого ИмяПоля Из ИсключаемыеНастройки Цикл
			ИндексПоля = ИндексПоляВКоллекции(КоллекцияВключенныхНастроек, ИмяПоля);
			Пока ИндексПоля <> Неопределено Цикл
				КоллекцияВключенныхНастроек.Удалить(ИндексПоля);
				ИндексПоля = ИндексПоляВКоллекции(КоллекцияВключенныхНастроек, ИмяПоля);
			КонецЦикла;
		КонецЦикла; 

		Отчет.Группировка.Загрузить(КоллекцияВключенныхНастроек);
		
		// Добавляем отсутствующие группировки.
		Если ЕстьУчетПоПодразделениям
		   И ИндексПоляВКоллекции(КоллекцияВключенныхНастроек, "Подразделение") = Неопределено Тогда
			
			ПоследняяГруппировка = ДобавитьГруппировкуОтчета(Отчет.Группировка,
										ДоступныеПоляГруппировок,
										"Подразделение");
			
		КонецЕсли;
		Если ЕстьУчетПоНаправлениямДеятельности
		   И ИндексПоляВКоллекции(КоллекцияВключенныхНастроек, "НаправлениеДеятельности") = Неопределено Тогда
			
			ПоследняяГруппировка = ДобавитьГруппировкуОтчета(Отчет.Группировка,
										ДоступныеПоляГруппировок,
										"НаправлениеДеятельности");
			
		КонецЕсли;
									
		Для НомерСубконто = 1 По КоличествоСубконто Цикл
			
			Если НеиспользуемаяАналитика.Найти(ДанныеСчета["ВидСубконто" + НомерСубконто]) <> Неопределено Тогда 
				Продолжить;
			ИначеЕсли ИндексПоляВКоллекции(КоллекцияВключенныхНастроек, "Субконто" + НомерСубконто) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ПоследняяГруппировка = ДобавитьГруппировкуОтчета(Отчет.Группировка,
										ДоступныеПоляГруппировок,
										"Субконто" + НомерСубконто);
				
			Если ИмяРазделителя = "ВидыСубконтоХозрасчетные"
			   И ПоследняяГруппировка <> Неопределено Тогда
				ПоследняяГруппировка.Использование = Истина;
			КонецЕсли;	
			
		КонецЦикла;
		Если ДанныеСчета.Валютный
		   И ИндексПоляВКоллекции(КоллекцияВключенныхНастроек, "Валюта") = Неопределено Тогда
			ДобавитьГруппировкуОтчета(Отчет.Группировка, ДоступныеПоляГруппировок, "Валюта");
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОписаниеНастройки.Свойство("Отбор") Тогда
		Форма.ЗаполнитьНастройкамиПоУмолчанию(Новый Структура("Отбор", Истина));
		БухгалтерскиеОтчетыВызовСервера.ОбновитьОписаниеОтборовОтчета(Форма);
	КонецЕсли;
	
	Если ОписаниеНастройки.Свойство("ДополнительныеПоля", КоллекцияВключенныхНастроек) Тогда
		
		ДополнительныеПоляИзНастроек(Отчет, КоллекцияВключенныхНастроек, КоличествоСубконто);
		
	КонецЕсли;
	
	// Сортировка.
	Если ОписаниеНастройки.Свойство("Порядок", КоллекцияВключенныхНастроек) Тогда
		
		Порядок = Отчет.КомпоновщикНастроек.Настройки.Порядок;
		Порядок.Элементы.Очистить();
		
		// Удаляем сохраненные поля, которые стали некорректными.
		Если ИмяРазделителя = "Хозрасчетный" Тогда 
			УдалитьНедоступныеПоля(КоллекцияВключенныхНастроек, Порядок.ДоступныеПоляПорядка, КоличествоСубконто, ДанныеСчета);
		Иначе
			УдалитьНедоступныеПоля(КоллекцияВключенныхНастроек, Порядок.ДоступныеПоляПорядка, КоличествоСубконто);
		КонецЕсли;
		
		// Заполняем ранее включавшуюся сортировку.
		Для каждого Показатель Из КоллекцияВключенныхНастроек Цикл
			
			НоваяСтрока = Порядок.Элементы.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
			НоваяСтрока.РежимОтображения  = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ;
			НоваяСтрока.Использование     = Показатель.Использование;
			НоваяСтрока.Поле              = Новый ПолеКомпоновкиДанных(Показатель.Поле);
			НоваяСтрока.ТипУпорядочивания = Показатель.ТипУпорядочивания;
		
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Преобразует отборы, ранее применявшиеся по счету РазделительИсходноеЗначение к отборам по счету Разделитель,
// удаляя неподходящие. Сопоставление производится по видам субконто.
//
// Параметры:
//  Отбор        - ОтборКомпоновкиДанных - набор преобразуемых отборов.
//  ИсходныйСчет - ПланСчетовСсылка - ранее использовавшийся счет.
//  НовыйСчет    - ПланСчетовСсылка - новый счет, который будет использоваться.
//
Процедура ПреобразоватьОтборыПоСчету(Отбор, ИсходныйСчет, НовыйСчет) Экспорт
	
	Если ИсходныйСчет = НовыйСчет Тогда
		Возврат;
 	КонецЕсли; 
	
	// Определяем правила преобразования аналитик одного счета в аналитики другого.
	
	ДанныеИсходногоСчета = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(ИсходныйСчет);
	ДанныеНовогоСчета = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(НовыйСчет);
	НеиспользуемаяАналитика = ПланыСчетов.Хозрасчетный.НеиспользуемаяАналитика();
	
	// Правила преобразования будут описаны в виде соответствия.
	// Ключ = имя поля в исходном отборе.
	// Значение = имя поля в новом отборе. Если задано пустое значение, то отбор по полю нужно удалить.
	КартаПолей = Новый Соответствие;
	
	// Проекция измерений.
	Если БухгалтерскийУчетПереопределяемый.ИспользоватьПодразделения()
	   И ДанныеНовогоСчета.УчетПоПодразделениям Тогда
		КартаПолей.Вставить("Подразделение", "Подразделение");
	Иначе
		КартаПолей.Вставить("Подразделение", "");
	КонецЕсли;
	Если БухгалтерскийУчетПереопределяемый.ИспользоватьНаправленияДеятельности()
	   И ДанныеНовогоСчета.УчетПоНаправлениямДеятельности Тогда
		КартаПолей.Вставить("НаправлениеДеятельности", "НаправлениеДеятельности");
	Иначе
		КартаПолей.Вставить("НаправлениеДеятельности", "");
	КонецЕсли;
	Если ДанныеНовогоСчета.Валютный Тогда
		КартаПолей.Вставить("Валюта", "Валюта");
	Иначе
		КартаПолей.Вставить("Валюта", "");
	КонецЕсли;
	
	// Проекция субконто.
	НовыеСубконто = Новый Массив;
	Для НомерСубконто = 1 По ДанныеНовогоСчета.КоличествоСубконто Цикл
		НовыеСубконто.Добавить("Субконто" + НомерСубконто);
	КонецЦикла;
	Для НомерСубконтоИсходного = 1 По ДанныеИсходногоСчета.КоличествоСубконто Цикл
		
		ЦелевоеСубконто = 0;
		Для НомерСубконто = 1 По ДанныеНовогоСчета.КоличествоСубконто Цикл
			Если ДанныеИсходногоСчета["ВидСубконто" + НомерСубконтоИсходного] = ДанныеНовогоСчета["ВидСубконто" + НомерСубконто] Тогда
				
				Если НеиспользуемаяАналитика.Найти(ДанныеНовогоСчета["ВидСубконто" + НомерСубконто]) = Неопределено Тогда
					ЦелевоеСубконто = НомерСубконто;
				Иначе // Это субконто существует на счете, но не должно использоваться.
					НовыеСубконто.Удалить(НовыеСубконто.Найти("Субконто" + НомерСубконто));
				КонецЕсли;
				Прервать;
				
			КонецЕсли;
		КонецЦикла;
		КартаПолей.Вставить("Субконто" + НомерСубконтоИсходного,
			?(ЦелевоеСубконто = 0, "", "Субконто" + ЦелевоеСубконто));
	
	КонецЦикла;	
		
	// Проекция ресурсов. Задаем только те ресурсы, которые необходимо удалить.
	ДоступныеПоляОтбора = Отбор.ДоступныеПоляОтбора.Элементы;
	ГруппыРесурсов = Новый Структура;
	Если ДоступныеПоляОтбора.Найти("ОборотыЗаПериод") <> Неопределено Тогда
		ГруппыРесурсов.Вставить("ОборотыЗаПериод", "Оборот");
	КонецЕсли;
	Если ДоступныеПоляОтбора.Найти("СальдоНаКонецПериода") <> Неопределено Тогда
		ГруппыРесурсов.Вставить("СальдоНаКонецПериода",  "Конечный");
	КонецЕсли;
	Если ДоступныеПоляОтбора.Найти("СальдоНаНачалоПериода") <> Неопределено Тогда
		ГруппыРесурсов.Вставить("СальдоНаНачалоПериода", "Начальный");
	КонецЕсли;
	ГруппыПоказателей = Новый Массив;
	ГруппыПоказателей.Добавить("БУ");
	ГруппыПоказателей.Добавить("НУ");
	ГруппыПоказателей.Добавить("ПР");
	ГруппыПоказателей.Добавить("ВР");
	ГруппыПоказателей.Добавить("Контроль");
	ГруппыПоказателей.Добавить("ВалютнаяСумма");
	СтороныПроводки = Новый Массив;
	СтороныПроводки.Добавить("Дт");
	СтороныПроводки.Добавить("Кт");
	
	Если Не ДанныеНовогоСчета.Валютный И ДанныеИсходногоСчета.Валютный Тогда
		
		Для каждого СторонаПроводки Из СтороныПроводки Цикл
		
			Для каждого ГруппаРесурсов Из ГруппыРесурсов Цикл
				
				Если ГруппаРесурсов.Значение = "Оборот" Тогда
					
					ИмяРесурса = ГруппаРесурсов.Ключ + "." + "ВалютнаяСумма" + ГруппаРесурсов.Значение + СторонаПроводки;
					КартаПолей.Вставить(ИмяРесурса, "");
					
				Иначе
					
					ИмяРесурса = ГруппаРесурсов.Ключ + "." + "ВалютнаяСумма" + ГруппаРесурсов.Значение + "Остаток" + СторонаПроводки;
					КартаПолей.Вставить(ИмяРесурса, "");
					ИмяРесурса = ГруппаРесурсов.Ключ + "." + "ВалютнаяСумма" + ГруппаРесурсов.Значение + "РазвернутыйОстаток" + СторонаПроводки;
					КартаПолей.Вставить(ИмяРесурса, "");
					
				КонецЕсли;
				
			КонецЦикла;
		
		КонецЦикла; 
		
	КонецЕсли;
	
	Если Не ДанныеНовогоСчета.Количественный И ДанныеИсходногоСчета.Количественный Тогда
		
		Для каждого СторонаПроводки Из СтороныПроводки Цикл
		
			Для каждого ГруппаРесурсов Из ГруппыРесурсов Цикл
				
				Если ГруппаРесурсов.Значение = "Оборот" Тогда
					
					ИмяРесурса = ГруппаРесурсов.Ключ + "." + "Количество" + ГруппаРесурсов.Значение + СторонаПроводки;
					КартаПолей.Вставить(ИмяРесурса, "");
					
				Иначе
					
					ИмяРесурса = ГруппаРесурсов.Ключ + "." + "Количество" + ГруппаРесурсов.Значение + "Остаток" + СторонаПроводки;
					КартаПолей.Вставить(ИмяРесурса, "");
					ИмяРесурса = ГруппаРесурсов.Ключ + "." + "Количество" + ГруппаРесурсов.Значение + "РазвернутыйОстаток" + СторонаПроводки;
					КартаПолей.Вставить(ИмяРесурса, "");
					
				КонецЕсли;
				
			КонецЦикла;
		
		КонецЦикла; 
		
	КонецЕсли;
	
	Если Не ДанныеНовогоСчета.НалоговыйУчет И ДанныеИсходногоСчета.НалоговыйУчет Тогда
		
		Для каждого ГруппаПоказателей Из ГруппыПоказателей Цикл
			Если ГруппаПоказателей <> "НУ"
			   И ГруппаПоказателей <> "ПР"
			   И ГруппаПоказателей <> "ВР"
			   И ГруппаПоказателей <> "Контроль" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого СторонаПроводки Из СтороныПроводки Цикл
			
				Для каждого ГруппаРесурсов Из ГруппыРесурсов Цикл
					
					Если ГруппаРесурсов.Значение = "Оборот" Тогда
						
						ИмяРесурса = ГруппаРесурсов.Ключ + "." + ГруппаПоказателей + ГруппаРесурсов.Значение + СторонаПроводки;
						КартаПолей.Вставить(ИмяРесурса, "");
						
					Иначе
						
						ИмяРесурса = ГруппаРесурсов.Ключ + "." + ГруппаПоказателей + ГруппаРесурсов.Значение + "Остаток" + СторонаПроводки;
						КартаПолей.Вставить(ИмяРесурса, "");
						ИмяРесурса = ГруппаРесурсов.Ключ + "." + ГруппаПоказателей + ГруппаРесурсов.Значение + "РазвернутыйОстаток" + СторонаПроводки;
						КартаПолей.Вставить(ИмяРесурса, "");
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЦикла;
		
		КонецЦикла; 
		
	КонецЕсли;
	
	Если ДанныеНовогоСчета.Вид <> ВидСчета.АктивноПассивный И ДанныеИсходногоСчета.Вид = ВидСчета.АктивноПассивный Тогда
		
		Для каждого ГруппаРесурсов Из ГруппыРесурсов Цикл
			Если ГруппаРесурсов.Значение = "Оборот" Тогда
				Продолжить;
			КонецЕсли;
		
			Для каждого СторонаПроводки Из СтороныПроводки Цикл
				
				Для каждого ГруппаПоказателей Из ГруппыПоказателей Цикл
				
					ИмяРесурса = ГруппаРесурсов.Ключ + "." + ГруппаПоказателей + ГруппаРесурсов.Значение + "РазвернутыйОстаток" + СторонаПроводки;
					КартаПолей.Вставить(ИмяРесурса, "");
				
				КонецЦикла;
				
			КонецЦикла;
		
		КонецЦикла;
		
	КонецЕсли;
	
	// Применяем проекцию аналитик. Удаляем неподходящие отборы.
	
	КоллекцияОтборов = Отбор.Элементы;
	ИспользуемыеПоля = Новый Соответствие;
	ПрименитьКартуПолей(КартаПолей, КоллекцияОтборов, ИспользуемыеПоля);
	
	// Добавляем отсутствующие отборы по-умолчанию, упорядочиваем имеющиеся.
	
	// Сдвигаем группы отборов вверх.
	ТекущийИндексУпорядоченных = 0;
	Для ТекущийИндексАнализируемых = 0 По КоллекцияОтборов.Количество() - 1 Цикл
		
		Если ТипЗнч(КоллекцияОтборов[ТекущийИндексАнализируемых]) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			
			Если ТекущийИндексУпорядоченных < ТекущийИндексАнализируемых Тогда
				КоллекцияОтборов.Сдвинуть(КоллекцияОтборов[ТекущийИндексАнализируемых],
					ТекущийИндексУпорядоченных - ТекущийИндексАнализируемых);
			КонецЕсли;
			ТекущийИндексУпорядоченных = ТекущийИндексУпорядоченных + 1;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(КартаПолей["Подразделение"]) Тогда
		ДобавитьОтборОтчета(КоллекцияОтборов,
			ДоступныеПоляОтбора,
			ИспользуемыеПоля,
			"Подразделение",
			ТекущийИндексУпорядоченных);
		КонецЕсли;
	Если Не ПустаяСтрока(КартаПолей["НаправлениеДеятельности"]) Тогда
		ДобавитьОтборОтчета(КоллекцияОтборов,
			ДоступныеПоляОтбора,
			ИспользуемыеПоля,
			"НаправлениеДеятельности",
			ТекущийИндексУпорядоченных);
	КонецЕсли;
	
	Для НомерСубконто = 1 По ДанныеНовогоСчета.КоличествоСубконто Цикл
		
		Если НовыеСубконто.Найти("Субконто" + НомерСубконто) = Неопределено Тогда
			// Это субконто существует на счете, но не должно использоваться.
			Продолжить;
		КонецЕсли;
		
		ДобавитьОтборОтчета(КоллекцияОтборов,
			ДоступныеПоляОтбора,
			ИспользуемыеПоля,
			"Субконто" + НомерСубконто,
			ТекущийИндексУпорядоченных);		
			
	КонецЦикла;
	Если Не ПустаяСтрока(КартаПолей["Валюта"]) Тогда
		ДобавитьОтборОтчета(КоллекцияОтборов,
			ДоступныеПоляОтбора,
			ИспользуемыеПоля,
			"Валюта",
			ТекущийИндексУпорядоченных);
	КонецЕсли; 
	
КонецПроцедуры

// Удаляет некорректные поля сортировки.
//
// Параметры:
//  ПоляСортировки - ПорядокКомпоновкиДанных, ТаблицаЗначений - набор обрабатываемых полей сортировки.
//  ДоступныеПоляПорядка - ДоступныеПоляКомпоновкиДанных - проверка на доступность полей.
//  КоличествоСубконто - Число - количество субконто, которые можно использовать.
//  ДанныеСчета  - Структура - если заполнено, то сверяются виды субконто.
//
Процедура УдалитьНедоступныеПоля(ПоляСортировки, ДоступныеПоляПорядка, КоличествоСубконто, ДанныеСчета = Неопределено) Экспорт
	
	// Удаляем сохраненные поля, которые стали некорректными.
	ИсключаемыеНастройки = Новый Массив;
	Для каждого Показатель Из ПоляСортировки Цикл
		
		ПозицияТочки = СтрНайти(Показатель.Поле, ".");
		Если ПозицияТочки = 0 Тогда
			ИмяПоля = Показатель.Поле;
		Иначе
			ИмяПоля = Лев(Показатель.Поле, ПозицияТочки - 1);
		КонецЕсли;
		Если КоличествоСубконто < 3 И ИмяПоля = "Субконто3" Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		ИначеЕсли КоличествоСубконто < 2 И ИмяПоля = "Субконто2" Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		ИначеЕсли КоличествоСубконто < 1 И ИмяПоля = "Субконто1" Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		ИначеЕсли ДанныеСчета <> Неопределено И СтрНачинаетсяС(ИмяПоля, "Субконто")
		   И Показатель.ВидСубконто <> ДанныеСчета["Вид" + ИмяПоля] Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		ИначеЕсли ДоступныеПоляПорядка.НайтиПоле(Новый ПолеКомпоновкиДанных(ИмяПоля)) = Неопределено Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		КонецЕсли; 
		
	КонецЦикла;
	Для каждого Показатель Из ИсключаемыеНастройки Цикл
		ПоляСортировки.Удалить(Показатель);
	КонецЦикла;
	
КонецПроцедуры

// Процедуру необходимо вызывать для отчетов, в которых используются группировки по дополнительным реквизитам или
// свойствам субконто. В случае, когда группировка по доп.реквизиту выше группировки по самому субконто, суммы с
// незаполненными значениями доп.реквизита (и подчиненные им) не выводятся в отчет. Чтобы они выводились, данная
// процедура для полей-реквизитов (или доп.свойств) сбрасывает флаг ИгнорироватьЗначенияNULL .
//
// Параметры:
//  ПоляНабораДанных - ПоляНабораДанныхМакетаКомпоновкиДанных - коллекция полей.
//
Процедура ОтключитьИгнорированиеNull(ПоляНабораДанных) Экспорт
	
	Для Каждого Поле Из ПоляНабораДанных Цикл
			
		Если СтрНачинаетсяС(Поле.ПутьКДанным, "Субконто")
		   И Сред(Поле.ПутьКДанным, 10, 1) = "." Тогда
			
			Поле.Роль.ИгнорироватьЗначенияNULL = Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Конструктор таблицы дополнительных полей.
//
// Возвращаемое значение:
//  ТаблицаЗначений - Новый дополнительные поля:
// * Использование - Булево. 
// * Поле - Строка.
// * Представление - Строка.  
Функция НовыйДополнительныеПоля() Экспорт
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	
	ТаблицаНастроек = Новый ТаблицаЗначений;
	ТаблицаНастроек.Колонки.Добавить("Использование",  Новый ОписаниеТипов("Булево"));
	ТаблицаНастроек.Колонки.Добавить("Поле",           ТипСтрока);
	ТаблицаНастроек.Колонки.Добавить("Представление",  ТипСтрока);
	
	Возврат ТаблицаНастроек;
	
КонецФункции

// Конструктор таблицы групировок.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Новый группировки:
// * Использование - Булево. 
// * Поле - Строка.
// * Представление - Строка. 
// * ТипГруппировки - Число.
Функция НовыйГруппировки() Экспорт
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	
	ТаблицаНастроек = Новый ТаблицаЗначений;
	ТаблицаНастроек.Колонки.Добавить("Использование",  Новый ОписаниеТипов("Булево"));
	ТаблицаНастроек.Колонки.Добавить("Поле",           ТипСтрока);
	ТаблицаНастроек.Колонки.Добавить("Представление",  ТипСтрока);
	ТаблицаНастроек.Колонки.Добавить("ТипГруппировки", ОбщегоНазначения.ОписаниеТипаЧисло(1, 0, ДопустимыйЗнак.Неотрицательный));
	
	Возврат ТаблицаНастроек;
	
КонецФункции

// Находит в таблицах, входящих в состав структуры настроек отчета, группировку строк с заданным именем.
//
// Параметры:
//  Структура	 - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных - элементы структуры настроек, в составе которых нужно искать. 
//  Имя			 - Строка - имя группировки.
// 
// Возвращаемое значение:
//  ГруппировкаТаблицыКомпоновкиДанных - найденная группировка.
//  Неопределено - не найдена группировка с указанным именем.
//
Функция НайтиГруппировкуТаблицы(Структура, Имя) Экспорт
	
	Отбор = Новый Структура;
	Отбор.Вставить("Имя",         Имя);
	Отбор.Вставить("Лимит",       1);
	Отбор.Вставить("Направление", "Строки");
	
	НайденныеГруппировки = Новый Массив;
	НайтиГруппировкиТаблицы(НайденныеГруппировки, Структура, Отбор);
	
	Если Не ЗначениеЗаполнено(НайденныеГруппировки) Тогда
		Возврат Неопределено;
	Иначе
		Возврат НайденныеГруппировки[0];
	КонецЕсли;
	
КонецФункции

// Ищет в структуре отчета (структуре настроек) группировки по заданному отбору.
//
// Параметры:
//  НайденныеГруппировки - Массив из ГруппировкаТаблицыКомпоновкиДанных - будет дополнен найденными группировками.
//  Группировки			 - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных - элементы структуры настроек.
//  Отбор				 - Структура - отбор. Допустимые свойства:
//                         * Имя             - Строка - Имя группировки.
//                         * ИмяТаблицы      - Строка - Имя таблицы, в которой находится группировка.
//                         * КоличествоПолей - Число - количество полей, выбранных в группировке. 
//                                             Например, могут быть нужны только группировки, содержащие одно поле.
//                         * Состояние       - СостояниеЭлементаНастройкиКомпоновкиДанных - состояние группировки.
//                         * Лимит           - Максимальное количество искомых группировок.
//                                             Например, предполагается, что под отбор попадет не более одной группировки.
//  ТаблицаНайдена		 - Булево - служебный параметр, используемый при рекурсивном вызове.
//
Процедура НайтиГруппировкиТаблицы(НайденныеГруппировки, Группировки, Отбор, ТаблицаНайдена = Ложь) Экспорт
	
	Если Отбор.Свойство("Лимит") И НайденныеГруппировки.Количество() >= Отбор.Лимит Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Группировка Из Группировки Цикл
		
		Если Не Группировка.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		ТипЭлемента = ТипЗнч(Группировка);
		
		Если ТаблицаНайдена Тогда
			
			Если ТипЭлемента = Тип("ГруппировкаТаблицыКомпоновкиДанных") Тогда
				Если Не Отбор.Свойство("КоличествоПолей") Или Группировка.Выбор.Элементы.Количество() = Отбор.КоличествоПолей Тогда
					
					Если (Не Отбор.Свойство("Состояние") Или Группировка.Состояние = Отбор.Состояние)
						И (Не Отбор.Свойство("Имя") Или Группировка.Имя = Отбор.Имя) Тогда
						НайденныеГруппировки.Добавить(Группировка);
					КонецЕсли;
					
					НайтиГруппировкиТаблицы(НайденныеГруппировки, Группировка.Структура, Отбор, Истина);
					
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли ТипЭлемента = Тип("ТаблицаКомпоновкиДанных") Тогда
			
			Если Не Отбор.Свойство("ИмяТаблицы") Или Группировка.Имя = Отбор.ИмяТаблицы Тогда
				
				Если Не Отбор.Свойство("Направление") Или Отбор.Направление = "Строки" Тогда
					НайтиГруппировкиТаблицы(НайденныеГруппировки, Группировка.Строки, Отбор, Истина);
				КонецЕсли;
				
				Если Не Отбор.Свойство("Направление") Или Отбор.Направление = "Колонки" Тогда
					НайтиГруппировкиТаблицы(НайденныеГруппировки, Группировка.Колонки, Отбор, Истина);
				КонецЕсли;
				
			КонецЕсли;
			
		ИначеЕсли ТипЭлемента = Тип("ГруппировкаКомпоновкиДанных") Тогда
			
			НайтиГруппировкиТаблицы(НайденныеГруппировки, Группировка.Структура, Отбор);
			
		КонецЕсли;
		
		Если Отбор.Свойство("Лимит") И НайденныеГруппировки.Количество() >= Отбор.Лимит Тогда
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает таблицу значений с группировками отчета, в которых каждый счет встречается только один раз.
// Возвращаются только те строки, у которых в исходной таблице заполнен Счет и установлен признак Использование.
//
// Параметры:
//	ГруппировкиОтчета - ТаблицаЗначений - Исходные группировки отчета по счетам. Обязательные колонки:
//		* Счет - ПланСчетовСсылка.Хозрасчетный - Счет учета, для которого заданы настройки.
//		* Использование - Булево - Признак "включения" строки настройки для отчета.
//
// Возвращаемое значение:
//	ТаблицаЗначений - Совпадает по структуре с исходной таблицей ГруппировкиОтчета,
//  но не содержит повторяющихся строк для одного и того же счета. Дополнительно включает колонки:
//		* СчетаВИерархии - Массив - Массив субсчетов, которые необходимо учитывать по строке группировки.
//
Функция УникальныеНастройкиОтчетаПоСчетам(ГруппировкиОтчета) Экспорт
	
	// Создаем таблицу, из которой дальше будем считывать настройки группировки.
	ГруппировкиПоСубсчетам = ГруппировкиОтчета.СкопироватьКолонки();
	
	// Для счетов-групп развернем каждую строку таблицы по субсчетам.
	ГруппировкиПоСубсчетам.Колонки.Добавить("Субсчет", Новый ОписаниеТипов("ПланСчетовСсылка.Хозрасчетный"));
	ГруппировкиПоСубсчетам.Колонки.Добавить("НомерИсходнойГруппировки",        ОбщегоНазначения.ОписаниеТипаЧисло(5));
	ГруппировкиПоСубсчетам.Колонки.Добавить("ЭтоСобственнаяНастройкаСубсчета", Новый ОписаниеТипов("Булево"));
	
	СчетаССобственнымиНастройками = Новый Массив;
	НомерИсходнойГруппировки = 0;
	Для каждого СтрокаГруппировки Из ГруппировкиОтчета Цикл

		НомерИсходнойГруппировки = НомерИсходнойГруппировки + 1;
		Если НЕ СтрокаГруппировки.Использование
		 Или НЕ ЗначениеЗаполнено(СтрокаГруппировки.Счет) Тогда
			Продолжить;
		КонецЕсли;
		
		Если СчетаССобственнымиНастройками.Найти(СтрокаГруппировки.Счет) <> Неопределено Тогда
			// Повторяется один и тот же счет. Оставляет только первую из встреченных настроек.
			Продолжить;
		Иначе
			СчетаССобственнымиНастройками.Добавить(СтрокаГруппировки.Счет);
		КонецЕсли;
	
		Субсчета = БухгалтерскийУчетПовтИсп.СчетаВИерархии(СтрокаГруппировки.Счет);
		Для каждого Субсчет Из Субсчета Цикл
			НоваяСтрока = ГруппировкиПоСубсчетам.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаГруппировки);
			НоваяСтрока.Субсчет                         = Субсчет;
			НоваяСтрока.НомерИсходнойГруппировки        = НомерИсходнойГруппировки;
			// Признак того, что настройка задана для самого субсчета, а не вычислена через счет верхнего уровня.
			НоваяСтрока.ЭтоСобственнаяНастройкаСубсчета = (СтрокаГруппировки.Счет = Субсчет);
		КонецЦикла;
		
	КонецЦикла;

	// Оставим по одной строке по каждому субсчету.
	ГруппировкиПоСубсчетам.Сортировать("Субсчет, ЭтоСобственнаяНастройкаСубсчета УБЫВ", Новый СравнениеЗначений);
	
	СтрокиКУдалению = Новый Массив;
	ТекущийСубсчет  = Неопределено;
	
	Для каждого СтрокаГруппировки Из ГруппировкиПоСубсчетам Цикл
		
		Если СтрокаГруппировки.Субсчет <> ТекущийСубсчет Тогда
			// Новый субсчет, первую строку по нему оставляем, остальные удалим.
			ТекущийСубсчет = СтрокаГруппировки.Субсчет;
		Иначе
			СтрокиКУдалению.Добавить(СтрокаГруппировки);
		КонецЕсли;
	
	КонецЦикла;
	
	// Удаляем дублирующиеся строки.
	Для каждого СтрокаКУдалению Из СтрокиКУдалению Цикл
		ГруппировкиПоСубсчетам.Удалить(СтрокаКУдалению);
	КонецЦикла;
	
	// Оставляем исходные колонки и формируем список субсчетов, которые относятся к конкретной строке.
	Результат = ГруппировкиПоСубсчетам.СкопироватьКолонки();
	Результат.Колонки.Добавить("СчетаВИерархии", Новый ОписаниеТипов("Массив"));
	
	ГруппировкиПоСубсчетам.Сортировать("НомерИсходнойГруппировки", Новый СравнениеЗначений);
	ТекущаяСтрока = Неопределено;
	
	Для каждого СтрокаГруппировки Из ГруппировкиПоСубсчетам Цикл
	
		Если ТекущаяСтрока = Неопределено 
			ИЛИ ТекущаяСтрока.НомерИсходнойГруппировки <> СтрокаГруппировки.НомерИсходнойГруппировки Тогда
			// Добавляем новую строку в результирующую таблицу группировок.
			ТекущаяСтрока = Результат.Добавить();
			ЗаполнитьЗначенияСвойств(ТекущаяСтрока, СтрокаГруппировки);
		КонецЕсли;
		
		// Заполняем массив субсчетов, входящих в строку группировки.
		ТекущаяСтрока.СчетаВИерархии.Добавить(СтрокаГруппировки.Субсчет);
	
	КонецЦикла;

	// Удалим вспомогательные колонки.
	Результат.Колонки.Удалить("Субсчет");
	Результат.Колонки.Удалить("НомерИсходнойГруппировки");
	Результат.Колонки.Удалить("ЭтоСобственнаяНастройкаСубсчета");
	
	Возврат Результат;
	
КонецФункции

//-- НЕ УТ

// Возвращает искомые значения из данных расшифровки.
//
// Параметры:
//  ДанныеРасшифровки - ДанныеРасшифровкиКомпоновкиДанных - Данные расшифровки из СКД.
//  СоответствиеПолей - Соответствие - Ключи соответствуют именам искомых в данных расшифровки полей
//  Расшифровка - ИдентификаторРасшифровкиКомпоновкиДанных - Идентификатор элемента данных расшифровки
//                в иерархии которого нужно осуществлять поиск.
//
// Возвращаемое значение:
//  Соответствие - Ключи соответствуют именам запрошенных полей.
//
Функция ПолучитьДанныеРасшифровки(ДанныеРасшифровки, СоответствиеПолей, Расшифровка) Экспорт
	
	СоответствиеДанных = Новый Соответствие();
	
	Если ДанныеРасшифровки <> Неопределено Тогда
		// Ищем интересующие нас поля в заданной расшифровке
		Для каждого ЭлементДанных Из СоответствиеПолей Цикл
			// Получаем элемент расшифровки, в котором нужно искать поля
			Родитель = ДанныеРасшифровки.Элементы[Расшифровка];
			// Вызываем рекурсивный поиск поля
			ЗначениеРасшифровки = ПолучитьЗначениеРасшифровки(Родитель, ЭлементДанных.Ключ);
			Если ЗначениеРасшифровки <> Неопределено Тогда
				// Значение нашлось, помещаем в структуру
				СоответствиеДанных.Вставить(ЭлементДанных.Ключ, ЗначениеРасшифровки);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СоответствиеДанных;

КонецФункции

// Устанавливает порядок сортировки из схемы компоновки данных.
//
// Параметры:
//  Схема - СхемаКомпоновкиДанных - Схема компоновки данных
//  КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - Компоновщик настроек
//
Процедура УстановитьПорядокСортировкиИзСхемы(Схема, КомпоновщикНастроек) Экспорт
	
	КомпоновщикНастроек.Настройки.Порядок.Элементы.Очистить();
	Для каждого ЭлементПорядкаСхемы Из Схема.НастройкиПоУмолчанию.Порядок.Элементы Цикл
		ЭлементПорядкаКомпоновщика = КомпоновщикНастроек.Настройки.Порядок.Элементы.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
		ЗаполнитьЗначенияСвойств(ЭлементПорядкаКомпоновщика, ЭлементПорядкаСхемы);
	КонецЦикла;
	
КонецПроцедуры

// Ищет в структуре отчета (структуре настроек) группировку по имени элемента.
//
// Параметры:
//  Структура    - КоллекцияЭлементовСтруктурыНастроекКомпоновкиДанных - набор группировок данного уровня настроек.
//  Имя          - Строка - имя искомого элемента структуры отчета.
//
// Возвращаемое значение:
//   ГруппировкаКомпоновкиДанных, ТаблицаКомпоновкиДанных - искомый элемент настроек.
//
Функция НайтиПоИмени(Структура, Имя) Экспорт
	Перем Группировка;
	
	Для каждого Элемент Из Структура Цикл

		Если Элемент.Имя = Имя Тогда
			Группировка = Элемент;
			Прервать;
		КонецЕсли;
		
		Если ТипЗнч(Элемент) = Тип("ТаблицаКомпоновкиДанных") Тогда
			Продолжить;
		КонецЕсли;

		Для каждого Поле Из Элемент.ПоляГруппировки.Элементы Цикл

			Если ТипЗнч(Поле) <> Тип("АвтоПолеГруппировкиКомпоновкиДанных")
			   И Поле.Поле = Новый ПолеКомпоновкиДанных(Имя) Тогда
				Группировка = Элемент;
				Прервать;
			КонецЕсли;

		КонецЦикла;
		
		Если Группировка = Неопределено
		   И Элемент.Структура.Количество() > 0 Тогда
			Группировка = НайтиПоИмени(Элемент.Структура, Имя);
		КонецЕсли;
		
		Если Группировка <> Неопределено Тогда
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Группировка;
	
КонецФункции

#КонецОбласти 

#Область Оформление

// Определяет имя отчета (объекта метаданных), отображаемого в форме.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - Форма объекта.
//
// Возвращаемое значение:
//	Строка - Имя объекта метаданных.
//
Функция ИмяОтчета(Форма) Экспорт
	
	ИмяОтчета = БухгалтерскиеОтчетыКлиентСервер.ИмяОтчетаПоИмениФормы(Форма);
	Если ИмяОтчета <> Неопределено Тогда
		Возврат ИмяОтчета;
	КонецЕсли;
	
	// Основной реквизит формы должен называться Отчет
	ОтчетОбъект = Форма.РеквизитФормыВЗначение("Отчет");
	Возврат ОтчетОбъект.Метаданные().Имя;
	
КонецФункции

// Устанавливает в настройках отчета заголовки групп колонок с ресурсами.
//
// Группы колонок должны быть помещены в именованные наборы колонок с уровнем группировки "детальные записи".
//
// Другими словами, настройки схемы компоновки должны быть выполнены так:
// - колонки кросс-таблицы содержат на верхнем уровне несколько наборов уровня группировки "Детальные записи";
// - каждый такой набор:
// -- соответствует группе колонок, которые в отчете объединены дополнительной шапкой;
// -- имеет имя;
// -- в выбранных полях содержит одну группу верхнего уровня;
// -- в составе группы содержит несколько выбранных полей (ресурсов), входящих в эту группу.
//
// Параметры:
//  КомпоновщикНастроек	 - КомпоновщикНастроекКомпоновкиДанных - настраиваемый объект.
//  ТекстыЗаголовков	 - Структура - 
//                         * Ключ - имя набора колонок, заданное в схеме;
//                         * Значение - Строка - заголовок колонки.
//
Процедура УстановитьЗаголовкиГруппКолонок(КомпоновщикНастроек, ТекстыЗаголовков) Экспорт
	
	Для Каждого Таблица Из КомпоновщикНастроек.Настройки.Структура Цикл
		
		Если ТипЗнч(Таблица) <> Тип("ТаблицаКомпоновкиДанных") Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ГруппаКолонок Из Таблица.Колонки Цикл
			
			Если ПустаяСтрока(ГруппаКолонок.Имя) Тогда
				Продолжить;
			КонецЕсли;
			
			Если Не ТекстыЗаголовков.Свойство(ГруппаКолонок.Имя) Тогда
				Продолжить;
			КонецЕсли;
			
			Для Каждого Поле Из ГруппаКолонок.Выбор.Элементы Цикл
				
				Если ТипЗнч(Поле) <> Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
					Продолжить;
				КонецЕсли;
				
				Если Не Поле.Использование Тогда
					Продолжить;
				КонецЕсли;
				
				Поле.Заголовок = ТекстыЗаголовков[ГруппаКолонок.Имя];
				
				Прервать;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает заголовок, помещающийся без переноса при установленной в процедуре УстановитьШиринуПоказателей() ширине.
//
// Возвращаемое значение:
//	Строка - Текст заголовка для группы "Показатели".
//
Функция ЗаголовокГруппыПоказателей() Экспорт
	
	Возврат НСтр("ru = 'Показа-" + Символы.ПС + "тели'");
	
КонецФункции

// Устанавливает минимальную ширину полей с показателями,
// при которой умещается заголовок, заданный в функции ЗаголовокГруппыПоказателей().
//
// Параметры:
//	Схема - СхемаКомпоновкиДанных - Схема отчета.
//	НаборПоказателей - Массив - Содержит имена показателей отчета.
//
Процедура УстановитьМинимальнуюШиринуПоказателей(Схема, НаборПоказателей) Экспорт
	
	ВычисляемыеПоля = Схема.ВычисляемыеПоля;
	
	Для Каждого Показатель Из НаборПоказателей Цикл
		УстановитьЗначениеМинимальнойШириныПоля(ВычисляемыеПоля.Найти("Показатели." + Показатель));
		УстановитьЗначениеМинимальнойШириныПоля(ВычисляемыеПоля.Найти("Показатели." + Показатель + "НачальныйОстаток"));
		УстановитьЗначениеМинимальнойШириныПоля(ВычисляемыеПоля.Найти("Показатели." + Показатель + "Оборот"));
		УстановитьЗначениеМинимальнойШириныПоля(ВычисляемыеПоля.Найти("Показатели." + Показатель + "КонечныйОстаток"));
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает условное оформление для поля ТипГруппировки табличной части Группировка настроек отчета.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - форма отчета.
//
Процедура УстановитьУсловноеОформлениеТипГруппировки(Форма) Экспорт

	УсловноеОформление = Форма.УсловноеОформление;


	// Тип группировки "Без групп"

	ЭлементУО = УсловноеОформление.Элементы.Добавить();

	КомпоновкаДанныхКлиентСервер.ДобавитьОформляемоеПоле(ЭлементУО.Поля, "ГруппировкаТипГруппировки");

	ОбщегоНазначенияКлиентСервер.ДобавитьЭлементКомпоновки(ЭлементУО.Отбор,
		"Отчет.Группировка.ТипГруппировки", ВидСравненияКомпоновкиДанных.Равно, 0);

	ЭлементУО.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Без групп';
																	|en = 'Without groups'"));


	// Тип группировки "С группами"

	ЭлементУО = УсловноеОформление.Элементы.Добавить();

	КомпоновкаДанныхКлиентСервер.ДобавитьОформляемоеПоле(ЭлементУО.Поля, "ГруппировкаТипГруппировки");

	ОбщегоНазначенияКлиентСервер.ДобавитьЭлементКомпоновки(ЭлементУО.Отбор,
		"Отчет.Группировка.ТипГруппировки", ВидСравненияКомпоновкиДанных.Равно, 1);

	ЭлементУО.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'С группами';
																	|en = 'With groups'"));


	// Тип группировки "Только группы"

	ЭлементУО = УсловноеОформление.Элементы.Добавить();

	КомпоновкаДанныхКлиентСервер.ДобавитьОформляемоеПоле(ЭлементУО.Поля, "ГруппировкаТипГруппировки");

	ОбщегоНазначенияКлиентСервер.ДобавитьЭлементКомпоновки(ЭлементУО.Отбор,
		"Отчет.Группировка.ТипГруппировки", ВидСравненияКомпоновкиДанных.Равно, 2);

	ЭлементУО.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Только группы';
																	|en = 'Only groups'"));

КонецПроцедуры

// Удаляем из переданной коллекции настроек условного оформления автоотступ.
//
// Параметры:
//	УсловноеОформление - УсловноеОформление - Коллекция условного оформления.
//
Процедура УдалитьАвтоотступИзУсловногоОформления(УсловноеОформление) Экспорт

	// Удалим автоотступ из условного оформления.
	ЭлементыДляУдаления = Новый Массив;
	Для Каждого ЭлементУсловногоОформления Из УсловноеОформление.Элементы Цикл
		ПараметрОформления = БухгалтерскиеОтчетыКлиентСервер.ПолучитьПараметр(ЭлементУсловногоОформления.Оформление, "Автоотступ");
		Если ПараметрОформления <> Неопределено И ПараметрОформления.Использование = Истина Тогда
			ЭлементыДляУдаления.Добавить(ЭлементУсловногоОформления);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого УдаляемыйЭлемент Из ЭлементыДляУдаления Цикл
		УсловноеОформление.Элементы.Удалить(УдаляемыйЭлемент);
	КонецЦикла;

КонецПроцедуры

// Настраивает кнопки командной панели.
//
// Параметры:
//  Форма        - ФормаКлиентскогоПриложения - на командной панели которой есть кнопка ПредварительныйПросмотр.
//
Процедура УстановитьАктивностьКнопокКоманднойПанели(Форма) Экспорт

	Если Не ПравоДоступа("Вывод", Метаданные) Тогда
		// Делает неактивной кнопку "Сохранить", если пользователю не разрешён вывод.
		ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы, "Сохранить", "Доступность", Ложь);
		ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы, "СохранитьВсеДействия", "Доступность", Ложь);

	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоВебКлиент() Тогда
		// Скрывает кнопку "Предварительный просмотр" при работе через браузер, т.к. она работает также как "Печать".
		ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы, "ПредварительныйПросмотр", "Видимость", Ложь);
		ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы, "ПредварительныйПросмотрВсеДействия", "Видимость", Ложь);

	КонецЕсли;	

КонецПроцедуры

//++ НЕ УТ

// Возвращает макет компоновки шапки отчета.
//
// Параметры:
// 	МакетКомпоновки - МакетКомпоновкиДанных - Результат формирования макета компоновки.
//	Тело - ТелоМакетаКомпоновкиДанных - Содержание макета компоновки.
//	ТипМакета - Строка - Возможные значения "Заголовок", "Подвал".
//
// Возвращаемое значение:
//	ОписаниеМакетаОбластиМакетаКомпоновкиДанных - Искомый макет.
//
Функция ПолучитьМакетШапки(МакетКомпоновки, Тело = Неопределено, ТипМакета = "Заголовок") Экспорт
	
	ЕстьПустойМакет = Ложь;
	
	Если Тело = Неопределено Тогда
		Тело = МакетКомпоновки.Тело;
	КонецЕсли;
	
	Если Тело.Количество() > 0 Тогда
		Если ТипМакета = "Заголовок" Тогда
			НачальныйИндекс = 0;
			КонечныйИндекс  = Тело.Количество();
			ИтераторПрямой  = Истина;
		ИначеЕсли ТипМакета = "Подвал" Тогда 
			НачальныйИндекс = Тело.Количество() - 1;
			КонечныйИндекс  = 0;
			ИтераторПрямой  = Ложь;
		КонецЕсли;
		
		Индекс = НачальныйИндекс;
		Пока Индекс <> КонечныйИндекс Цикл
			Элемент = Тело[Индекс];
			Если ТипЗнч(Элемент) = Тип("МакетОбластиМакетаКомпоновкиДанных") Тогда
				Если ЕстьПустойМакет 
				  Или ТипЗнч(МакетКомпоновки.Макеты[Элемент.Макет].Макет) <> Тип("МакетОбластиКомпоновкиДанных") Тогда
					ЕстьПустойМакет = Ложь;
				Иначе
					Возврат МакетКомпоновки.Макеты[Элемент.Макет];
				КонецЕсли;
			ИначеЕсли ТипЗнч(Элемент) = Тип("МакетГруппировкиТаблицыМакетаКомпоновкиДанных") Тогда
				Возврат МакетКомпоновки.Макеты[Элемент.Макет];
			ИначеЕсли ТипЗнч(Элемент) = Тип("ДиаграммаМакетаКомпоновкиДанных") Тогда
				ЕстьПустойМакет = Истина;
			ИначеЕсли ТипЗнч(Элемент) = Тип("ТаблицаМакетаКомпоновкиДанных") Тогда
				Возврат МакетКомпоновки.Макеты[Элемент.МакетШапки];
			КонецЕсли;
			
			Если ИтераторПрямой Тогда
				Индекс = Индекс + 1;
			Иначе
				Индекс = Индекс - 1;
			КонецЕсли;
		КонецЦикла;	
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает макет компоновки подвала отчета.
//
// Параметры:
// 	МакетКомпоновки - МакетКомпоновкиДанных - Результат формирования макета компоновки.
//	Тело - ТелоМакетаКомпоновкиДанных - Содержание макета компоновки.
//
// Возвращаемое значение:
//	ОписаниеМакетаОбластиМакетаКомпоновкиДанных - Искомый макет.
//
Функция ПолучитьМакетПодвала(МакетКомпоновки, Тело = Неопределено) Экспорт
	
	Если Тело = Неопределено Тогда
		Тело = МакетКомпоновки.Тело;
	КонецЕсли;
	
	Для Каждого Элемент Из Тело Цикл
		Если ТипЗнч(Элемент) = Тип("ГруппировкаМакетаКомпоновкиДанных") Тогда
			Если Не ПустаяСтрока(Элемент.МакетПодвала) Тогда
				Возврат МакетКомпоновки.Макеты[Элемент.МакетПодвала];
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат Неопределено;
	
КонецФункции

// Задает параметры для алгоритма подбора элементов из тела компоновки данных.
//
// Возвращаемое значение:
//   Структура   - параметры подбора.
//
Функция ПараметрыПоискаВТелеМакетаКомпоновки() Экспорт
	
	ПараметрыПоиска = Новый Структура;
	
	// Искать ли в элементах типа "ЗаписиТаблицыМакетаКомпоновкиДанных".
	ПараметрыПоиска.Вставить("ИскатьВДетальныхЗаписях", Ложь);
	
	// Если "Ложь", то после подбора первого элемента, удовлетворяющего условию, поиск будет прекращен.
	ПараметрыПоиска.Вставить("МножественныйПодбор", Ложь);
	
	// "ТипЭлемента" - представление типа элемента;
	// "Группировка" - имя элемента тела макета;
	// "ПолеГруппировки" - имя поля в элементе тела макета.
	ПараметрыПоиска.Вставить("СвойствоДляИдентификации", "Группировка");
	
	// "Макет" - макет из элемента тела компоновки данных;
	// "Элемент" - элемент тела компоновки данных;
	ПараметрыПоиска.Вставить("ВозвращаемыйТип", "Элемент");
	
	// "Заголовок" или "Подвал".
	ПараметрыПоиска.Вставить("ТипМакета", "Заголовок");
	
	Возврат ПараметрыПоиска;
	
КонецФункции

// Поиск по телу макета компоновки данных.
//
// Параметры:
//  МакетКомпоновки - МакетКомпоновкиДанных - результат формирования макета компоновки.
//  ИдентификаторДляПоиска - Строка - начало имени элемента, который ищем, или имя типа этого элемента.
//  ПараметрыПоиска - Структура - см. ПараметрыПоискаВТелеМакетаКомпоновки()
//
// Возвращаемое значение:
//   * Неопределено - если не удалось подобрать элемент при параметре МножественныйПодбор=Ложь;
//   * ОписаниеМакетаОбластиМакетаКомпоновкиДанных - если МножественныйПодбор=Ложь и ВозвращаемыйТип=Макет;
//   * ТелоГруппировкиТаблицыМакетаКомпоновкиДанных - один из типов элементов этой коллекции, если МножественныйПодбор=Ложь и ВозвращаемыйТип=Элемент;
//   * Массив - если МножественныйПодбор=Истина.
//
Функция ПодобратьЭлементыИзТелаМакета(МакетКомпоновки, ИдентификаторДляПоиска, ПараметрыПоиска) Экспорт
	
	ЭлементыТела = Новый Массив;
	
	ОбойтиТелоМакетаКомпоновки(МакетКомпоновки.Тело, ИдентификаторДляПоиска, ПараметрыПоиска, ЭлементыТела);
	
	Если ПараметрыПоиска.ВозвращаемыйТип = "Макет" Тогда
		
		ИндексЭлемента = 0;
		КоличествоЭлементов = ЭлементыТела.Количество();
		Пока ИндексЭлемента < КоличествоЭлементов Цикл

			МакетТело = ПолучитьМакетШапки(МакетКомпоновки, ЭлементыТела[ИндексЭлемента], ПараметрыПоиска.ТипМакета);
			Если МакетТело = Неопределено Тогда
				
				ЭлементыТела.Удалить(ИндексЭлемента);
				КоличествоЭлементов = КоличествоЭлементов - 1;
				
			Иначе
				
				ЭлементыТела[ИндексЭлемента] = МакетТело;
				ИндексЭлемента = ИндексЭлемента + 1;
				
			КонецЕсли;
		
		КонецЦикла; 

	КонецЕсли;
	
	Если ПараметрыПоиска.МножественныйПодбор Тогда
		Возврат ЭлементыТела;
	ИначеЕсли ЭлементыТела.Количество() = 0 Тогда
		Возврат Неопределено;
	Иначе
		Возврат ЭлементыТела[0];
	КонецЕсли;
	
КонецФункции

// Преобразует табличный документ в двоичные данные.
//
// Параметры:
//  СохраняемыйДокумент - ТабличныйДокумент - преобразуемый в двоичные данные.
//  ТипФайла     - ТипФайлаТабличногоДокумента - в какой формат файла сохранить табличный документ.
//
// Возвращаемое значение:
//   ДвоичныеДанные - данные в новом формате.
//
Функция ДвоичныеДанныеИзТабличногоДокумента(СохраняемыйДокумент, ТипФайла) Экспорт

	ВозможностьЗаписиВПоток = Новый Соответствие;
	ВозможностьЗаписиВПоток.Вставить(ТипФайлаТабличногоДокумента.DOCX,  Истина);
	ВозможностьЗаписиВПоток.Вставить(ТипФайлаТабличногоДокумента.MXL,   Истина);
	ВозможностьЗаписиВПоток.Вставить(ТипФайлаТабличногоДокумента.ODS,   Истина);
	ВозможностьЗаписиВПоток.Вставить(ТипФайлаТабличногоДокумента.PDF,   Истина);
	ВозможностьЗаписиВПоток.Вставить(ТипФайлаТабличногоДокумента.TXT,   Истина);
	ВозможностьЗаписиВПоток.Вставить(ТипФайлаТабличногоДокумента.HTML5, Ложь);
	ВозможностьЗаписиВПоток.Вставить(ТипФайлаТабличногоДокумента.XLS,   Ложь);
	ВозможностьЗаписиВПоток.Вставить(ТипФайлаТабличногоДокумента.XLSX,  Ложь);
	
	ПреобразоватьЧерезПоток = ВозможностьЗаписиВПоток[ТипФайла];
	Если ПреобразоватьЧерезПоток = Неопределено Тогда

		// Формат, который был выбран пользователем для сохранения табличного документа, определяется по расширению файла.
		// Поэтому из набора значений перечисления ТипФайлаТабличногоДокумента используются только значения, имеющие различные
		// расширения файла. См. БухгалтерскиеОтчетыКлиент.ОтчетСохранитьКакПриПодключенииРасширенияРаботыСФайлами()
		
		ТекстИсключения = НСтр("ru = 'Сохранение результата отчета в табличный документ формата %1 не предусмотрено';
								|en = 'Saving report result to a %1 format spreadsheet document is not available'");
		ВызватьИсключение СтрШаблон(ТекстИсключения, ТипФайла);

	КонецЕсли;
		
	Если ПреобразоватьЧерезПоток Тогда
		
		Поток = Новый ПотокВПамяти;
		СохраняемыйДокумент.Записать(Поток, ТипФайла);
		ДвоичныеДанныеФайла = Поток.ЗакрытьИПолучитьДвоичныеДанные();
		
	Иначе

		ИмяФайла = ПолучитьИмяВременногоФайла();
		СохраняемыйДокумент.Записать(ИмяФайла, ТипФайла);
		ДвоичныеДанныеФайла = Новый ДвоичныеДанные(ИмяФайла);
		УдалитьФайлы(ИмяФайла);
		
	КонецЕсли;
		
	Возврат ДвоичныеДанныеФайла;
	
КонецФункции

//-- НЕ УТ

#КонецОбласти

#Область Вспомогательные

// Отчет открывается в особом режиме для передачи результата в пакет отчетности. Для стандартных бухгалтерских отчетов БП.
//
// Форма         - ФормаКлиентскогоПриложения - открываемый отчет.
//
Процедура ИнициализироватьРежимВыгрузкиБП(Форма) Экспорт

	Если Не Форма.Параметры.Свойство("РежимВыгрузки") Тогда
		Возврат;
	КонецЕсли;

	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(Форма.Элементы, "Выгрузить", "Видимость",                 Истина);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(Форма.Элементы, "Выгрузить", "КнопкаПоУмолчанию",         Истина);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(Форма.Элементы, "Выгрузить", "АктивизироватьПоУмолчанию", Истина);
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(Форма.Элементы, "ВыгрузитьВсеДействия", "Видимость", Истина);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(Форма.Элементы, "ВыгрузитьПослеНастройки", "Видимость", Истина);

	НаборНастроек = Неопределено;
	Если Форма.Параметры.Свойство("ПользовательскиеНастройки", НаборНастроек) И НаборНастроек <> Неопределено Тогда
		
		Форма.ПараметрыРежимаВыгрузки = ЭталонныеПараметры(НаборНастроек.ДополнительныеСвойства);
		
		Для Каждого ЭталонныйПараметр Из НаборНастроек.Элементы Цикл
			
			Если ТипЗнч(ЭталонныйПараметр) = Тип("ОтборКомпоновкиДанных") Тогда
				Форма.ПараметрыРежимаВыгрузки.Вставить("Отбор", ЭталонныйПараметр);
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	ИначеЕсли Форма.Параметры.Свойство("ПараметрыРежимаВыгрузки", НаборНастроек) И Форма.Параметры.Свойство("ИдентификаторОтчета") Тогда
		
		Если ПустаяСтрока(НаборНастроек.ВидОтчета) Тогда
			НаборНастроек.ВидОтчета = Форма.Параметры.ИдентификаторОтчета;
		КонецЕсли;
		
		ДополнительныеСвойства = Новый Структура("ПараметрыРежимаВыгрузки", НаборНастроек);
		ЗначениеВлияющегоПараметра = Неопределено;
		ВлияющиеПараметры = Метаданные.Отчеты[Форма.Параметры.ИдентификаторОтчета].Реквизиты;
		Для Каждого ЭталонныйПараметр Из ВлияющиеПараметры Цикл
			Если Форма.Параметры.Свойство(ЭталонныйПараметр.Имя, ЗначениеВлияющегоПараметра) Тогда
				
				Если ТипЗнч(ЗначениеВлияющегоПараметра) = Тип("СписокЗначений")
				   И Не ЗначениеЗаполнено(ЗначениеВлияющегоПараметра) Тогда
					// Список не является частью настроек отчета, определяемых банками в сервисе.
					Продолжить;
				КонецЕсли;
				
				ДополнительныеСвойства.Вставить(ЭталонныйПараметр.Имя, ЗначениеВлияющегоПараметра);
				
			КонецЕсли;
		КонецЦикла;
		
		Форма.ПараметрыРежимаВыгрузки = ЭталонныеПараметры(ДополнительныеСвойства);
		
	КонецЕсли;
	
КонецПроцедуры

// Отчет открывается в особом режиме для передачи результата в пакет отчетности. Для отчетов подсистемы ВариантыОтчетов из БСП.
//
// Форма         - ФормаКлиентскогоПриложения - открываемый отчет.
//
Процедура ИнициализироватьРежимВыгрузкиБСП(Форма) Экспорт

	Если Не Форма.Параметры.Свойство("РежимВыгрузки") Тогда
		Возврат;
	КонецЕсли;

	КнопкаВыгрузить = Форма.Команды.Добавить("Выгрузить");
	КнопкаВыгрузить.Действие = "БухгалтерскиеОтчетыКлиент.ОбработчикКомандыВыгрузитьБСП";
	КнопкаВыгрузить.Подсказка = НСтр("ru = 'Выгрузить';
									|en = 'Export'");
	ОтчетыСервер.ВывестиКоманду(Форма, КнопкаВыгрузить, "Главное", Истина);
	Форма.Элементы.Выгрузить.КнопкаПоУмолчанию = Истина;
	
	НастройкиОтчета = Форма.НастройкиОтчета;
	НастройкиОтчета.РазрешеноВыбиратьИНастраиватьВариантыБезСохранения = Истина;
	НастройкиОтчета.События.ПриЗагрузкеПользовательскихНастроекНаСервере = Истина;
	НастройкиОтчета.Вставить("РежимВыгрузки", Истина);
	
	ПараметрыОтчета = Форма.Параметры;
	НастройкиОтчета.ФормироватьСразу = ПараметрыОтчета.РежимРасшифровки;
	ДопСвойства = ПараметрыОтчета.ПользовательскиеНастройки.ДополнительныеСвойства;
	Если ДопСвойства.Свойство("ПараметрыРежимаВыгрузки") Тогда
		
		НастройкиОтчета.Вставить("ПараметрыРежимаВыгрузки", ДопСвойства.ПараметрыРежимаВыгрузки);
		
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура УстановитьЗначениеМинимальнойШириныПоля(Поле)
	
	Если Поле = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Поле.Оформление.УстановитьЗначениеПараметра("МинимальнаяШирина", 8);
	
КонецПроцедуры

// Возвращает значение искомого поля из элемента расшифровки.
//
Функция ПолучитьЗначениеРасшифровки(Элемент, ИмяПоля)
	
	Если ТипЗнч(Элемент) = Тип("ЭлементРасшифровкиКомпоновкиДанныхПоля") Тогда
		// Ищем поля в текущем элементе
		Поле = Элемент.ПолучитьПоля().Найти(ИмяПоля);
		Если Поле <> Неопределено Тогда
			// Возвращаем значение найденного поля
			Возврат Поле.Значение;
		КонецЕсли;
	КонецЕсли;
	
	// Если поле не нашлось, или текущий элемент не содержит полей
	// ищем поля среди родителей элемента (вышестоящие группировки).
	Родители  = Элемент.ПолучитьРодителей();
	Если Родители.Количество() > 0 Тогда
		
		Для Каждого Родитель Из Родители Цикл
			// Вызываем рекурсивный поиск поля
			ЗначениеРасшифровки = ПолучитьЗначениеРасшифровки(Родитель, ИмяПоля);
			
			Если ЗначениеРасшифровки <> Неопределено Тогда
				Возврат ЗначениеРасшифровки;
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	// Если ничего не нашлось
	Возврат Неопределено;
	
КонецФункции

//++ НЕ УТ

Функция ИсключаемыеСчетаУчетаТоваров()
	
	Счета_1011 = БухгалтерскийУчетПовтИсп.СчетаВИерархии(ПланыСчетов.Хозрасчетный.СпецоснасткаИСпецодеждаВЭксплуатации);
	СчетаИсключаемые = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(Счета_1011);
	СчетаИсключаемые.Добавить(ПланыСчетов.Хозрасчетный.МатериалыПереданныеВПереработку);            // 10.07
	СчетаИсключаемые.Добавить(ПланыСчетов.Хозрасчетный.ТоварыВРозничнойТорговлеВПродажныхЦенахАТТ); // 41.11
	СчетаИсключаемые.Добавить(ПланыСчетов.Хозрасчетный.ТоварыВРозничнойТорговлеВПродажныхЦенахНТТ); // 41.12
	СчетаИсключаемые.Добавить(ПланыСчетов.Хозрасчетный.КорректировкаТоваровПрошлогоПериода);        // 41.К
	
	Возврат СчетаИсключаемые;
	
КонецФункции

// Формируем ключи, идентифицирующие описание сохраняемых настроек.
//
// Параметры:
//  ИмяОтчета    - Строка - имя объекта метаданных.
//  ИмяРазделителя - Строка - вариант разделения настроек.
//  Разделитель  - ПланСчетовСсылка, ПланВидовХарактеристикСсылка - значение, разделяющее сохраняемые настройки.
//
// Возвращаемое значение:
//   ОписаниеНастроек - содержит ключи-идентификаторы.
//
Функция КлючиОписанияНастройки(ИмяОтчета, ИмяРазделителя, Разделитель)
	
	ИмяПредопределенныхДанных = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Разделитель, "ИмяПредопределенныхДанных");
	
	ОписаниеНастроек = Новый ОписаниеНастроек;
	ОписаниеНастроек.КлючОбъекта = "Отчет." + ИмяОтчета + "/" + ИмяРазделителя;
	ОписаниеНастроек.КлючНастроек = ?(ПустаяСтрока(ИмяПредопределенныхДанных),
		Строка(Разделитель.УникальныйИдентификатор()),
		ИмяПредопределенныхДанных);
	ОписаниеНастроек.Представление = ИмяОтчета + " " + Разделитель;
		
	Возврат ОписаниеНастроек;
	
КонецФункции

// Формирует список настроек сортировки.
//
// Параметры:
//  КоллекцияНастроек - ПорядокКомпоновкиДанных - список полей сортировки.
//  ДанныеСчета  - Структура - если заполнено, то запоминаются виды субконто.
//
// Возвращаемое значение:
//  ТаблицаЗначение - список настроек сортировки в отчете.
//
Функция ОписаниеСортировки(КоллекцияНастроек, ДанныеСчета = Неопределено)

	КоллекцияВключенныхНастроек = Новый ТаблицаЗначений;
	КоллекцияВключенныхНастроек.Колонки.Добавить("Использование", Новый ОписаниеТипов("Булево"));
	КоллекцияВключенныхНастроек.Колонки.Добавить("Поле", Новый ОписаниеТипов("Строка"));
	КоллекцияВключенныхНастроек.Колонки.Добавить("ВидСубконто",
		Новый ОписаниеТипов("ПланВидовХарактеристикСсылка.ВидыСубконтоХозрасчетные"));
	КоллекцияВключенныхНастроек.Колонки.Добавить("ТипУпорядочивания", Новый ОписаниеТипов("НаправлениеСортировкиКомпоновкиДанных"));
	
	Для каждого Показатель Из КоллекцияНастроек Цикл
		Если ТипЗнч(Показатель) <> Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
			Продолжить;
		КонецЕсли;
		
		ВидСубконто = Неопределено;
		Если ДанныеСчета <> Неопределено
		   И СтрНачинаетсяС(Показатель.Поле, "Субконто") Тогда
		   
			Если СтрДлина(Показатель.Поле) = 9 Тогда
				ВидСубконто = ДанныеСчета["Вид" + Показатель.Поле];
			ИначеЕсли Сред(Показатель.Поле, 10, 1) = "." Тогда
				ВидСубконто = ДанныеСчета["Вид" + Лев(Показатель.Поле, 9)];
			КонецЕсли;
			 
		КонецЕсли;
		ЭлементПорядка = КоллекцияВключенныхНастроек.Добавить();
		ЗаполнитьЗначенияСвойств(ЭлементПорядка, Показатель);
		ЭлементПорядка.ВидСубконто = ВидСубконто;
		
	КонецЦикла;
	
	Возврат КоллекцияВключенныхНастроек;
	
КонецФункции

// Добавляет группировку в список настроек отчета.
//
// Параметры:
//  Группировки  - ТабличнаяЧасть - список группировок отчета.
//  ДоступныеГруппировки - ДоступныеПоляКомпоновкиДанных - источник информации о полях группировок.
//  ИмяПоля      - Строка - имя поля группировки.
//
// Возвращаемое значение:
//   СтрокаТабличнойЧасти - последняя добавленная строка.
//
Функция ДобавитьГруппировкуОтчета(Группировки, ДоступныеГруппировки, ИмяПоля)
	
	Поле = ДоступныеГруппировки.НайтиПоле(Новый ПолеКомпоновкиДанных(ИмяПоля));
	Если Поле = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НоваяСтрока = Группировки.Добавить();
	НоваяСтрока.Использование  = Ложь;
	НоваяСтрока.Поле           = Поле.Поле;
	НоваяСтрока.Представление  = Поле.Заголовок;
	НоваяСтрока.ТипГруппировки = 0;
	
	Возврат НоваяСтрока;
	
КонецФункции

// Добавляет отбор в список настроек отчета. Если ВключенныеОтборы не содержит признак использования отбора
// (или его реквизита), то создается неиспользуемый отбор по-умолчанию.
//
// Параметры:
//  Отборы       - КоллекцияЭлементовОтбораКомпоновкиДанных - список отборов отчета.
//  ДоступныеОтборы - ДоступныеПоляКомпоновкиДанных - источник информации о полях отборов.
//  ВключенныеОтборы - Соответствие - отборы, которые уже включены.
//  ИмяПоля      - Строка - имя поля отбора.
//  ИндексВставки - Число - индекс строки, на которую нужно переместить отбор.
//
Процедура ДобавитьОтборОтчета(Отборы, ДоступныеОтборы, ВключенныеОтборы, ИмяПоля, ИндексВставки)
	
	Если ВключенныеОтборы[ИмяПоля] <> Неопределено Тогда // было по крайней мере одно использование
		
		ДлинаИмениПоля = СтрДлина(ИмяПоля);
		КоличествоОтборов = Отборы.Количество() - 1;
		Для ИндексОтбора = ИндексВставки По КоличествоОтборов Цикл
			
			ИмяОтбора = Лев(Отборы[ИндексОтбора].ЛевоеЗначение, ДлинаИмениПоля);
			Если ИмяПоля <> ИмяОтбора Тогда
				Продолжить;
			КонецЕсли;
			
			Если ИндексОтбора <> ИндексВставки Тогда
				Отборы.Сдвинуть(Отборы[ИндексОтбора], ИндексВставки - ИндексОтбора);
			КонецЕсли;
			ИндексВставки = ИндексВставки + 1;
		
		КонецЦикла; 
		
	Иначе // нужно добавить неиспользуемый отбор
		
		ПолеЦель = Новый ПолеКомпоновкиДанных(ИмяПоля);
		Поле = ДоступныеОтборы.Найти(ПолеЦель);
		НовыйЭлемент = Отборы.Вставить(ИндексВставки, Тип("ЭлементОтбораКомпоновкиДанных"));
		ИндексВставки = ИндексВставки + 1;
		НовыйЭлемент.ЛевоеЗначение  = ПолеЦель;
		НовыйЭлемент.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
		НовыйЭлемент.ПравоеЗначение = Поле.Тип.ПривестиЗначение(Неопределено);
		НовыйЭлемент.Использование  = Ложь;
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет дополнительные поля отчета из их описания в настройках.
//
Процедура ДополнительныеПоляИзНастроек(Отчет, КоллекцияВключенныхНастроек, КоличествоСубконто)

	ДоступныеПоляВыбора = Отчет.КомпоновщикНастроек.Настройки.Выбор.ДоступныеПоляВыбора;
	Отчет.ДополнительныеПоля.Очистить();
	ШаблонСпискаПолей = Отчет.ДополнительныеПоля.Выгрузить();
	
	// Удаляем сохраненные поля, которые стали некорректными.
	ИсключаемыеНастройки = Новый Массив;
	Для каждого Показатель Из КоллекцияВключенныхНастроек Цикл
		
		ПозицияТочки = СтрНайти(Показатель.Поле, ".");
		Если ПозицияТочки = 0 Тогда
			ИмяПоля = Показатель.Поле;
		Иначе
			ИмяПоля = Лев(Показатель.Поле, ПозицияТочки - 1);
		КонецЕсли;
		Если КоличествоСубконто < 3 И ИмяПоля = "Субконто3" Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		ИначеЕсли КоличествоСубконто < 2 И ИмяПоля = "Субконто2" Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		ИначеЕсли КоличествоСубконто < 1 И ИмяПоля = "Субконто1" Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		ИначеЕсли СтрНачинаетсяС(ИмяПоля, "Субконто") Тогда // проверяем, что состав субконто на счете не изменился
			ОписаниеПоля = ДоступныеПоляВыбора.НайтиПоле(Новый ПолеКомпоновкиДанных(ИмяПоля));
			Если ОписаниеПоля = Неопределено Тогда
				ИсключаемыеНастройки.Добавить(ИмяПоля);
			Иначе
				ДлинаПредставленияПоля = СтрДлина(ОписаниеПоля.Заголовок);
				Если ОписаниеПоля.Заголовок <> Лев(Показатель.Представление, ДлинаПредставленияПоля) Тогда
					// Субконто сдвинулись.
					ИсключаемыеНастройки.Добавить(Показатель);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ДоступныеПоляВыбора.НайтиПоле(Новый ПолеКомпоновкиДанных(ИмяПоля)) = Неопределено Тогда
			ИсключаемыеНастройки.Добавить(Показатель);
		КонецЕсли; 
		
	КонецЦикла;
	Для каждого Показатель Из ИсключаемыеНастройки Цикл
		КоллекцияВключенныхНастроек.Удалить(Показатель);
	КонецЦикла;
	
	// Заполняем ранее включавшиеся дополнительные поля.
	Для каждого Показатель Из КоллекцияВключенныхНастроек Цикл
		
		НоваяСтрока = Отчет.ДополнительныеПоля.Добавить();
		НоваяСтрока.Использование = Показатель.Использование;
		НоваяСтрока.Поле          = Показатель.Поле;
		НоваяСтрока.Представление = Показатель.Представление;
	
	КонецЦикла;
	
	// Заполняем невключенные дополнительные поля.
	ГруппировкиОтчета = Неопределено;
	Если Не Отчет.Свойство("Группировка", ГруппировкиОтчета) Тогда
		// В отчете "Карточка счета" есть доп.поля, но нет группировок. Считаем, что группировками являются все выводимые поля.
		ГруппировкиОтчета = ГруппировкиКарточкиСчета();

	КонецЕсли;
	БухгалтерскиеОтчетыВызовСервера.ЗаполнитьДополнительныеПоляИзНастроек(Отчет.КомпоновщикНастроек, ШаблонСпискаПолей, ГруппировкиОтчета);
	Для каждого Показатель Из ШаблонСпискаПолей Цикл
		
		Если КоллекцияВключенныхНастроек.Найти(Показатель.Поле, "Поле") <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = Отчет.ДополнительныеПоля.Добавить();
		НоваяСтрока.Использование = Ложь;
		НоваяСтрока.Поле          = Показатель.Поле;
		НоваяСтрока.Представление = Показатель.Представление;
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, входит ли в коллекцию поле или один из его реквизитов.
//
// Параметры:
//  КоллекцияПолей - ТаблицаЗначений - содержит колонку "Поле", по которой выполняется проверка.
//  Поле         - Строка - имя поля, вхождение которого проверяется.
//
// Возвращаемое значение:
//   Число       - индекс строки с полем или Неопределено, если вхождения не нашли.
//
Функция ИндексПоляВКоллекции(КоллекцияПолей, Поле)
	
	ИндексПоля = 0;
	
	ДлинаИмениПоля = СтрДлина(Поле);
	Для каждого СтрокаКоллекции Из КоллекцияПолей Цикл
		
		ИмяПоля = Лев(СтрокаКоллекции.Поле, ДлинаИмениПоля + 1);
		Если ИмяПоля = Поле
		 Или Прав(ИмяПоля, 1) = "." И Лев(ИмяПоля, ДлинаИмениПоля) = Поле Тогда
			Возврат ИндексПоля;
		КонецЕсли;
		ИндексПоля = ИндексПоля + 1;
		
	КонецЦикла; 
	
	Возврат Неопределено;
	
КонецФункции

// Удаляет лишние отборы или преобразует значение одного субконто в другое.
//
// Параметры:
//  КартаПолей   - Соответствие - правила преобразования отборов.
//  Отборы       - КоллекцияЭлементовОтбораКомпоновкиДанных - набор преобразуемых отборов.
//  ИспользуемыеПоля - Соответствие - список полей отборов обработанных (и неудаленных) при проецировании.
//
Процедура ПрименитьКартуПолей(КартаПолей, Отборы, ИспользуемыеПоля)
	
	УдаляемыеОтборы = Новый Массив;
	
	Для каждого ЭлементОтбора Из Отборы Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ПрименитьКартуПолей(КартаПолей, ЭлементОтбора.Элементы, ИспользуемыеПоля);
			Если ЭлементОтбора.Элементы.Количество() = 0 Тогда
				УдаляемыеОтборы.Добавить(ЭлементОтбора);
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		ИмяИсходногоПоля = Строка(ЭлементОтбора.ЛевоеЗначение);
		ИмяПоля = ИмяИсходногоПоля;
		ИмяНовогоПоля = КартаПолей[ИмяИсходногоПоля];
		Если ИмяНовогоПоля = Неопределено Тогда // возможно ИмяИсходногоПоля содержит реквизит через точку
			ПозицияТочки = СтрНайти(ИмяИсходногоПоля, ".");
			Если ПозицияТочки <> 0 Тогда
				ИмяПоля = Лев(ИмяИсходногоПоля, ПозицияТочки - 1);
				ИмяНовогоПоля = КартаПолей[ИмяПоля];
			КонецЕсли;
			Если ИмяНовогоПоля = Неопределено Тогда
				
				// Если раньше был некий отбор, а сейчас в карте преобразований этого поля нет, то может быть две ситуации:
				// * Это субконто, которое могло быть, но отсутствует на этом счете (например, Партии). Удалить отбор по нему.
				// * Это поле, отбор по которому всегда допустим (например, Организация). Оставить неизменным.
				Если СтрНачинаетсяС(ИмяПоля, "Субконто") И СтрДлина(ИмяПоля) = 9 Тогда
					ИмяНовогоПоля = ""; // субконто больше нет на счёте
				Иначе // ничего делать не нужно
					ИспользуемыеПоля.Вставить(ИмяИсходногоПоля, Истина);
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
		КонецЕсли;
		
		Если ПустаяСтрока(ИмяНовогоПоля) Тогда // удалить
			УдаляемыеОтборы.Добавить(ЭлементОтбора);
			Продолжить;
		КонецЕсли;
		
		// Заменяем одно субконто на другое.
		ИспользуемыеПоля.Вставить(ИмяНовогоПоля, Истина);
		Если ИмяНовогоПоля = ИмяПоля Тогда // отбор не меняется
			Продолжить;
		КонецЕсли;
		ИмяПоляЦели = ИмяНовогоПоля + ?(ИмяИсходногоПоля = ИмяПоля, "", Сред(ИмяИсходногоПоля, СтрДлина(ИмяПоля) + 1));
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоляЦели);
	
	КонецЦикла;
	
	Для каждого ЭлементОтбора Из УдаляемыеОтборы Цикл
		Отборы.Удалить(ЭлементОтбора);
	КонецЦикла; 
	
КонецПроцедуры

// Видам субконто у субсчетов меняется номер, чтобы псевдоним поля соответствовал номеру соответствующего вида
// субконто у счета-группы. Если такого вида субконто нет, то подставляется первый из достуных.
// См. комментарий к функции КартаСубконто() .
//
Функция ЗаменитьНомераСубконтоВТексте(Знач ТекстЗапроса, СтрокаКартыСубконто, МаксНомерЗаполненногоСубконто)
	
	// Предполагается, что исходный текст запроса содержит:
	// Субконто1 КАК Субконто1,
	// Субконто2 КАК Субконто2,
	// Требуется подставить на место Субконто1 и Субконто2 поля с правильными номерами из виртуальной таблицы, а псевдонимы сохранить.
	
	Для НомерСубконто = 1 По БухгалтерскийУчет.МаксимальноеКоличествоСубконто() Цикл
	
		НомерСубконтоВиртуальнойТаблицы = СтрокаКартыСубконто["СубконтоВиртуальнойТаблицыВПозиции" + НомерСубконто];
		
		Если НомерСубконтоВиртуальнойТаблицы = НомерСубконто Тогда
			// Менять не требуется.
			Продолжить;
		КонецЕсли;
	
		Если ЗначениеЗаполнено(НомерСубконтоВиртуальнойТаблицы) Тогда
		
			ТекстПодстановки = Строка(НомерСубконтоВиртуальнойТаблицы);	
		
			ШаблонПоиска = "(Субконто%1).* КАК Субконто%2";
			ИсходноеСоответствие = СтрШаблон(ШаблонПоиска, НомерСубконто, НомерСубконто);
			НовоеСоответствие = СтрШаблон(ШаблонПоиска, ТекстПодстановки, НомерСубконто);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИсходноеСоответствие, НовоеСоответствие);
			
			ШаблонПоиска = ".Субконто%1 КАК Субконто%2";
			ИсходноеСоответствие = СтрШаблон(ШаблонПоиска, НомерСубконто,НомерСубконто);
			НовоеСоответствие = СтрШаблон(ШаблонПоиска, ТекстПодстановки, НомерСубконто);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИсходноеСоответствие, НовоеСоответствие);
			
			ШаблонПоиска = ".Субконто%1) КАК Субконто%2Представление";
			ИсходноеСоответствие = СтрШаблон(ШаблонПоиска, НомерСубконто, НомерСубконто);
			НовоеСоответствие = СтрШаблон(ШаблонПоиска, ТекстПодстановки, НомерСубконто);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИсходноеСоответствие, НовоеСоответствие);
			
		Иначе
			
			Если НомерСубконто <= МаксНомерЗаполненногоСубконто Тогда
				// Вставляем заглушку вместо поля виртуальной таблицы в промежуточную позицию.
				ТекстПодстановки   = "НЕОПРЕДЕЛЕНО";
				ТекстПредставления = """<...>""";
			Иначе
				// Субконто вообще не должно выводиться в отчет.
				// Заменяем его на NULL, чтобы удалилось при компоновке отчета.
				ТекстПодстановки   = "NULL";
				ТекстПредставления = """""";
			КонецЕсли;
		
			ШаблонПоиска = "(Субконто%1).* КАК Субконто%2";
			ИсходноеСоответствие = СтрШаблон(ШаблонПоиска, НомерСубконто, НомерСубконто);
			НовоеСоответствие = СтрШаблон("(%1) КАК Субконто%2", ТекстПодстановки, НомерСубконто);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИсходноеСоответствие, НовоеСоответствие);

			НомерСимвола = СтрНайти(ТекстЗапроса, "РегистрБухгалтерии.Хозрасчетный.");
			ТаблицаВТексте = "Хозрасчетный" + Сред(ТекстЗапроса, НомерСимвола + 32,
				СтрНайти(ТекстЗапроса, "(", , НомерСимвола + 32) - НомерСимвола - 32);
				
			ШаблонПоиска = ТаблицаВТексте + ".Субконто%1 КАК Субконто%2";
			ИсходноеСоответствие = СтрШаблон(ШаблонПоиска, НомерСубконто, НомерСубконто);
			НовоеСоответствие = СтрШаблон("%1 КАК Субконто%2", ТекстПодстановки, НомерСубконто);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИсходноеСоответствие, НовоеСоответствие);
			
			ШаблонПоиска = "ПРЕДСТАВЛЕНИЕССЫЛКИ(" + ТаблицаВТексте + ".Субконто%1) КАК Субконто%2Представление";
			ИсходноеСоответствие = СтрШаблон(ШаблонПоиска, НомерСубконто, НомерСубконто);
			НовоеСоответствие = СтрШаблон("%1 КАК Субконто%2Представление", ТекстПредставления, НомерСубконто);
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИсходноеСоответствие, НовоеСоответствие);
			
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат ТекстЗапроса;
	
КонецФункции

Процедура ПодготовитьСхемуКомпоновкиДанныхДляИзменения(ПараметрыОтчета, Схема, КомпоновщикНастроек)

	// При изменении счета на форме отчета для полей наборов схемы назначаются заголовки и типы значений
	// в соответствии с видами субконто на выбранном счете.
	// Т.к. сейчас для работы будем использовать новый объект Схема на основе типового макета,
	// то повторим эти настройки полей для нового объекта схемы.

	Если КомпоновщикНастроек.Настройки.ДополнительныеСвойства.Свойство("ИзмененТекстЗапросаСКД") Тогда
		// В схему уже ранее были внесены изменения в рамках текущего сеанса формирования отчета, 
		// повторно получать типовую схему из макета отчета не требуется.
		Возврат;
	КонецЕсли;

	// Запомним, что схему уже изменили.
	КомпоновщикНастроек.Настройки.ДополнительныеСвойства.Вставить("ИзмененТекстЗапросаСКД", Истина);

	Отчет = Отчеты[ПараметрыОтчета.ИдентификаторОтчета];
	ИмяСхемы = ИмяСхемыКомпоновкиДанныхОтчета(ПараметрыОтчета, ПараметрыОтчета.ИдентификаторОтчета);
	Схема = Отчет.ПолучитьМакет(ИмяСхемы);
	
	Отчет.НастроитьСхемуКомпоновкиДанных(Схема, ПараметрыОтчета.Счет);

КонецПроцедуры

// Убирает конструкции, которые не должны дублироваться при копировании текста запроса.
//
Процедура УдалитьОднократноИспользуемыеКонструкцииЗапроса(ТекстЗапроса)
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ВЫБРАТЬ РАЗРЕШЕННЫЕ", "ВЫБРАТЬ");
	
	НачалоСкобок = СтрНайти(ТекстЗапроса, "{ВЫБРАТЬ");
	Если НачалоСкобок <> 0 Тогда
		
		КонецСкобок = СтрНайти(ТекстЗапроса, "}", НаправлениеПоиска.СНачала, НачалоСкобок);
		ТекстЗапроса = Лев(ТекстЗапроса, НачалоСкобок - 2) + Сред(ТекстЗапроса, КонецСкобок + 1);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбойтиТелоМакетаКомпоновки(КоллекцияЭлементов, ИдентификаторДляПоиска, ПараметрыПоиска, ЭлементыТела)
	
	Для Каждого Элемент Из КоллекцияЭлементов Цикл
		
		ТипЭлемента = ТипЗнч(Элемент);
		Если ПараметрыПоиска.ИскатьВДетальныхЗаписях И ТипЭлемента = Тип("ЗаписиМакетаКомпоновкиДанных") Тогда
			
			Если Элемент.Имя = ИдентификаторДляПоиска Тогда

				ЭлементыТела.Добавить(Элемент.Тело);

			КонецЕсли;
			Продолжить;
			
		КонецЕсли;

		Если ПараметрыПоиска.СвойствоДляИдентификации = "ПолеГруппировки" Тогда
			// Проверяем, есть ли среди полей группировки поле с искомым именем.
			Если ТипЭлемента = Тип("ГруппировкаМакетаКомпоновкиДанных")
			 Или ТипЭлемента = Тип("ГруппировкаТаблицыМакетаКомпоновкиДанных") Тогда

				Для каждого ЭлементГруппировки Из Элемент.Группировка Цикл
		
					Если СтрНачинаетсяС(ЭлементГруппировки.ИмяПоля, ИдентификаторДляПоиска) Тогда
						
						ЭлементыТела.Добавить(Элемент.Тело);
						ЭлементыТела.Добавить(Элемент.ТелоИерархии);

					КонецЕсли;
					
				КонецЦикла;

			КонецЕсли;
			
		ИначеЕсли ПараметрыПоиска.СвойствоДляИдентификации = "ТипЭлемента" Тогда
			// Находим в коллекции элементы искомого типа.
			Если ТипЭлемента = Тип(ИдентификаторДляПоиска) Тогда

				ЭлементыТела.Добавить(Элемент);
				
			КонецЕсли;
			
		Иначе // "Группировка"
			// Проверяем имя групировки.
			Если ТипЭлемента = Тип("МакетОбластиМакетаКомпоновкиДанных")
			 Или ТипЭлемента = Тип("МакетГруппировкиТаблицыМакетаКомпоновкиДанных")
			 Или ТипЭлемента = Тип("МакетГруппировкиДиаграммыМакетаКомпоновкиДанных") Тогда
				Если СтрНачинаетсяС(Элемент.Макет, ИдентификаторДляПоиска) Тогда
					ЭлементыТела.Добавить(Элемент);
				КонецЕсли;
			Иначе
				Если СтрНачинаетсяС(Элемент.Имя, ИдентификаторДляПоиска) Тогда
					ЭлементыТела.Добавить(Элемент);
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
		Если Не ПараметрыПоиска.МножественныйПодбор
			И ЭлементыТела.Количество() <> 0
			И ПараметрыПоиска.ВозвращаемыйТип <> "Макет" Тогда

			Возврат;
			
		Иначе
			// Для варианта "Макет". Макет у элемента может быть пустым, и тогда нужно искать следующий элемент. Поэтому даже
			// при параметре МножественныйПодбор=Ложь мы сначала найдем все элементы тел, а затем в вышестоящей процедуре после
			// получения макетов будем смотреть на параметр.
			
			Если ТипЭлемента = Тип("ТаблицаМакетаКомпоновкиДанных") Тогда
				
				ПараметрыПоиска.ИскатьВДетальныхЗаписях = Не ПараметрыПоиска.ИскатьВДетальныхЗаписях;
				ОбойтиТелоМакетаКомпоновки(Элемент.Строки, ИдентификаторДляПоиска, ПараметрыПоиска, ЭлементыТела);
				ПараметрыПоиска.ИскатьВДетальныхЗаписях = Не ПараметрыПоиска.ИскатьВДетальныхЗаписях;
				
			ИначеЕсли ТипЭлемента <> Тип("МакетОбластиМакетаКомпоновкиДанных")
			   И ТипЭлемента <> Тип("МакетГруппировкиТаблицыМакетаКомпоновкиДанных")
			   И ТипЭлемента <> Тип("МакетГруппировкиДиаграммыМакетаКомпоновкиДанных") Тогда

				ОбойтиТелоМакетаКомпоновки(Элемент.Тело, ИдентификаторДляПоиска, ПараметрыПоиска, ЭлементыТела);
				
			КонецЕсли;
			
			Если Не ПараметрыПоиска.МножественныйПодбор
				И ЭлементыТела.Количество() <> 0
				И ПараметрыПоиска.ВозвращаемыйТип <> "Макет" Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры

//-- НЕ УТ

Функция ИмяСхемыКомпоновкиДанныхПоУмолчанию()
	
	Возврат "СхемаКомпоновкиДанных";
	
КонецФункции

// Выделяем из списка параметров, на основании которых должен формироваться отчет, те, которые определяют выводимые в нем данные.
//
// Параметры:
//  ПараметрыКомпоновкиОтчета - Структура - см. ПустыеПараметрыКомпоновкиОтчета() в модуле менеджера отчета.
//
// Возвращаемое значение:
//   Структура   - параметры, идентифицирующие отчет и определяющие его данные.
//
Функция ЭталонныеПараметры(ПараметрыКомпоновкиОтчета)
	
	ВспомогательныеПараметры = БухгалтерскиеОтчетыКлиентСервер.ПараметрыНеВлияющиеНаДанныеОтчета();
	
	ЭталонныеНастройки = Новый Структура;
	ПараметрыРежимаВыгрузки = Новый Структура("ЭталонныеНастройки", ЭталонныеНастройки);
	
	Для Каждого ЭталонныйПараметр Из ПараметрыКомпоновкиОтчета Цикл
		
		Если ЭталонныйПараметр.Ключ = "ПараметрыРежимаВыгрузки" Тогда
			
			Для Каждого ПараметрИдентификации Из ЭталонныйПараметр.Значение Цикл
				ПараметрыРежимаВыгрузки.Вставить(ПараметрИдентификации.Ключ, ПараметрИдентификации.Значение);
			КонецЦикла;
			
		ИначеЕсли ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ВспомогательныеПараметры, ЭталонныйПараметр.Ключ, Ложь) <> Истина Тогда
			
			ЭталонныеНастройки.Вставить(ЭталонныйПараметр.Ключ, ЭталонныйПараметр.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПараметрыРежимаВыгрузки;
	
КонецФункции

#КонецОбласти

#Область ПроверкаАктуальности

// Выполняет запуск фонового задания по получению актуальности данных закрытия месяца и последующую обработку результата.
//
//	Параметры:
//		ПараметрыПроверки - Структура - параметры выполнения фонового задания, см. БухгалтерскиеОтчетыКлиентСервер.ИнициализироватьПараметрыПроверкиАктуальности();
//		ДанныеАктуализации - Структура - данные актуализации отчета, служит для последующего изменения данных формы отчета:
//			* ИдентификаторЗаданияАктуализации - Строка - идентификатор выполняемого задания актуализации;
//			* АдресХранилищаАктуализации - Строка - адрес хранения данных выполненного задания актуализации отчета.
//
Процедура ПроверитьАктуальность(ПараметрыПроверки, ДанныеАктуализации) Экспорт
	
	Если Не (ПравоДоступа("Чтение", Метаданные.РегистрыСведений.ВыполнениеОперацийЗакрытияМесяца)
		И ПравоДоступа("Использование", Метаданные.Обработки.ОперацииЗакрытияМесяца))
		ИЛИ ПолучитьФункциональнуюОпцию("НеИспользоватьПроверкуЗаданийЗакрытияМесяцаВОтчетахРегл") Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДанныеАктуализации.ИдентификаторЗаданияАктуализации) Тогда
		ФоновоеЗадание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ДанныеАктуализации.ИдентификаторЗаданияАктуализации);
		Если ФоновоеЗадание <> Неопределено И ФоновоеЗадание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
			ФоновоеЗадание.Отменить();
			ДанныеАктуализации.ИдентификаторЗаданияАктуализации = "";
		КонецЕсли;
	КонецЕсли;
	
	ПараметрыВыполнения = ДлительныеОперации.ПараметрыВыполненияВФоне(ПараметрыПроверки.УникальныйИдентификаторФормы);
	ПараметрыВыполнения.НаименованиеФоновогоЗадания = НСтр("ru = 'Проверка актуальности данных';
															|en = 'Data relevance check'");
	ПараметрыВыполнения.ОжидатьЗавершение = 0;
	ПараметрыВыполнения.КлючФоновогоЗадания = Новый УникальныйИдентификатор;
	ПараметрыВыполнения.ЗапуститьВФоне = Истина;
	
	РезультатВыполнения = ДлительныеОперации.ВыполнитьВФоне(
		"БухгалтерскиеОтчеты.ОпределитьСостояниеЭтаповРасчетаЗакрытияМесяца",
		ПараметрыПроверки,
		ПараметрыВыполнения);
	
	ОбработатьРезультатВыполненияАктуализации(РезультатВыполнения, ДанныеАктуализации);
	
КонецПроцедуры

// В зависимости от результата выполнения фонового задания, изменяет данные актуализации отчета.
//
//	Параметры:
//		РезультатВыполнения - Структура - см. возвращаемое значение ДлительныеОперации.ВыполнитьВФоне();
//		ДанныеАктуализации - Структура - данные актуализации отчета, служит для последующего изменения данных формы отчета:
//			* ИдентификаторЗаданияАктуализации - Строка - идентификатор выполняемого задания актуализации;
//			* АдресХранилищаАктуализации - Строка - адрес хранения данных выполненного задания актуализации отчета.
//
Процедура ОбработатьРезультатВыполненияАктуализации(РезультатВыполнения, ДанныеАктуализации) Экспорт
	
	Если Не РезультатВыполнения.Свойство("АдресРезультата") И ЗначениеЗаполнено(ДанныеАктуализации.АдресХранилищаАктуализации) Тогда
		РезультатВыполнения.Вставить("АдресРезультата", ДанныеАктуализации.АдресХранилищаАктуализации);
	КонецЕсли;
	
	Если РезультатВыполнения.Статус = "Выполняется" И РезультатВыполнения.Свойство("ИдентификаторЗадания") Тогда
		ДанныеАктуализации.ИдентификаторЗаданияАктуализации = РезультатВыполнения.ИдентификаторЗадания;
		ДанныеАктуализации.АдресХранилищаАктуализации = РезультатВыполнения.АдресРезультата;
	ИначеЕсли РезультатВыполнения.Статус = "Выполнено" Тогда
		ДанныеАктуализации.ИдентификаторЗаданияАктуализации = "";
		ДанныеАктуализации.АдресХранилищаАктуализации = РезультатВыполнения.АдресРезультата;
	ИначеЕсли РезультатВыполнения.Статус = "Ошибка" Тогда
		ДанныеАктуализации.ИдентификаторЗаданияАктуализации = "";
		ДанныеАктуализации.АдресХранилищаАктуализации = ПоместитьВоВременноеХранилище(РезультатВыполнения, Новый УникальныйИдентификатор);
	КонецЕсли;
		
КонецПроцедуры

// Для определения статуса выполнения регламентных операций в фоновом задании.
//
// Параметры:
//  Параметры - Структура - см. БухгалтерскиеОтчетыКлиентСервер.ИнициализироватьПараметрыПроверкиАктуальности();
//  АдресХранилища - Строка - адрес временного хранилища, куда будет помещен результат определения состояний.
//
Процедура ОпределитьСостояниеЭтаповРасчетаЗакрытияМесяца(Параметры, АдресХранилища) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ДатаАктуальности", КонецМесяца(Параметры.КонецПериода));
	Результат.Вставить("СостоянияЭтапов", Новый Соответствие);
	Результат.Вставить("Состояние", "НеТребуется");
	
	Если РасчетЗакрытияМесяцаВыполняется(Параметры) Тогда
		Результат.Состояние = "Выполняется";
		ПоместитьВоВременноеХранилище(Результат, АдресХранилища);
		Возврат;
	КонецЕсли;
		
	Результат.СостоянияЭтапов = ЗакрытиеМесяцаСервер.ОпределитьСостояниеЭтаповРасчета(
		Параметры.ЭтапыЗакрытияМесяца, Результат.ДатаАктуальности, Параметры.СписокОрганизаций);
		
	Для каждого Этап Из Параметры.ЭтапыЗакрытияМесяца Цикл
		
		Если Результат.СостоянияЭтапов.Получить(Этап) = Перечисления.СостоянияОперацийЗакрытияМесяца.ВыполненоСОшибками
	 		Или Результат.СостоянияЭтапов.Получить(Этап) = Перечисления.СостоянияОперацийЗакрытияМесяца.НеВыполнено
			Или Результат.СостоянияЭтапов.Получить(Этап) = Перечисления.СостоянияОперацийЗакрытияМесяца.ОжидаетВыполненияПредыдущихОпераций Тогда
			
			Результат.Состояние = "НеВыполнено";
			Прервать;
		
		КонецЕсли;
		
	КонецЦикла;
	
	ПоместитьВоВременноеХранилище(Результат, АдресХранилища);
	
КонецПроцедуры

// Определяет факт выполнения расчета закрытия месяца
//
//	Параметры:
//		ПараметрыПроверки - Структура - параметры выполнения фонового задания, см. БухгалтерскиеОтчетыКлиентСервер.ИнициализироватьПараметрыПроверкиАктуальности();
//
//	Возвращаемое значение:
//		Булево - Истина, если в базе есть активные задания закрытия месяца.
//
Функция РасчетЗакрытияМесяцаВыполняется(ПараметрыПроверки) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ВыполнениеОперацийЗакрытияМесяца.Организация КАК Организация,
	|	ВыполнениеОперацийЗакрытияМесяца.ПериодРасчета КАК ПериодРасчета,
	|	ВыполнениеОперацийЗакрытияМесяца.Операция КАК Операция,
	|	ВыполнениеОперацийЗакрытияМесяца.ДатаНачала КАК ДатаНачала,
	|	ВыполнениеОперацийЗакрытияМесяца.ДатаОкончания КАК ДатаОкончания,
	|	ВыполнениеОперацийЗакрытияМесяца.БылиОшибки КАК БылиОшибки,
	|	ВыполнениеОперацийЗакрытияМесяца.ИдентификаторРасчета КАК ИдентификаторРасчета,
	|	ВыполнениеОперацийЗакрытияМесяца.ИнформацияОЗапускеРасчета КАК ИнформацияОЗапускеРасчета
	|ИЗ
	|	РегистрСведений.ВыполнениеОперацийЗакрытияМесяца КАК ВыполнениеОперацийЗакрытияМесяца
	|ГДЕ
	|	ВыполнениеОперацийЗакрытияМесяца.Организация В(&СписокОрганизаций)
	|	И (ВыполнениеОперацийЗакрытияМесяца.Операция В(&ЭтапыЗакрытияМесяца)
	|	ИЛИ ВыполнениеОперацийЗакрытияМесяца.Операция = ЗНАЧЕНИЕ(Перечисление.ОперацииЗакрытияМесяца.ПустаяСсылка))
	|	И ВыполнениеОперацийЗакрытияМесяца.РасчетВыполняется
	|	И ВыполнениеОперацийЗакрытияМесяца.ПериодРасчета МЕЖДУ &НачалоПериодаРасчета И &КонецПериодаРасчета";
	
	Запрос.УстановитьПараметр("СписокОрганизаций", ПараметрыПроверки.СписокОрганизаций);
	Запрос.УстановитьПараметр("ЭтапыЗакрытияМесяца", ПараметрыПроверки.ЭтапыЗакрытияМесяца);
	Запрос.УстановитьПараметр("НачалоПериодаРасчета", ПараметрыПроверки.НачалоПериода);
	Запрос.УстановитьПараметр("КонецПериодаРасчета", ПараметрыПроверки.КонецПериода);
	
	Результат = Запрос.Выполнить();
	
	Возврат Не Результат.Пустой();
	
КонецФункции

#КонецОбласти

//++ НЕ УТ

#Область УниверсальныеНастройки

// Возвращает структуру служебных параметров стандартных отчетов на основе СКД.
// Перечисленные в ней параметры являются служебными в том смысле, что они обслуживаются
// каждым отчетом самостоятельно.
// При программном вызове формирования отчета заполнять их вызывающему коду не нужно,
// они будут заполнены в коде процедур из модуля менеджера самого отчета.
//
// Возвращаемое значение:
//	Структура
//
Функция СлужебныеПустыеПараметрыКомпоновкиОтчета() Экспорт

	ПараметрыОтчета = Новый Структура;

	ПараметрыОтчета.Вставить("ИдентификаторОтчета", "");   // имя объекта метаданных (зависит от семейства конфигураций)
	ПараметрыОтчета.Вставить("СхемаКомпоновкиДанных");     // адрес временного хранилища со схемой компоновки данных
	ПараметрыОтчета.Вставить("НастройкиКомпоновкиДанных"); // настройки по-умолчанию для компоновщика
	ПараметрыОтчета.Вставить("ДанныеРасшифровки");         // адрес временного хранилища для помещения данных расшифровок
	ПараметрыОтчета.Вставить("РежимРасшифровки", Ложь);    // Истина - если настройки сгенерированы автоматически
	ПараметрыОтчета.Вставить("НаборПоказателей", Новый Массив);

	Возврат ПараметрыОтчета;

КонецФункции

// Общая для всех отчетов структура настроек. Используется как при интерактивном, так и при программном вызове отчета.
// После вызова ПустыеПараметрыКомпоновкиОтчета() к параметрам можно добавить стандартные наборы дополнительных параметров
// посредством вызова процедур ДобавитьПоказателиВПараметры(), ДобавитьГруппировкиВПараметры() и ДобавитьДополнительныеПоляВПараметры().
// Затем:
// * при интерактивном формировании из формы вызывается ЗаполнитьПараметрыИзФормы() ;
// * при программном вызове из кода вызывается ПодготовитьСхемуКомпоновкиДанных() .
//
// Возвращаемое значение:
//	Структура
//
Функция ПустыеПараметрыКомпоновкиОтчета() Экспорт

	ПараметрыОтчета = СлужебныеПустыеПараметрыКомпоновкиОтчета();
	
	// Отборы из шапки отчета.
	ПараметрыОтчета.Вставить("Организация",   Справочники.Организации.ПустаяСсылка()); // по организации
	ПараметрыОтчета.Вставить("ВключатьОбособленныеПодразделения", Ложь); // по обособленным подразделениям организации
	ПараметрыОтчета.Вставить("НачалоПериода", '00010101');
	ПараметрыОтчета.Вставить("КонецПериода",  '00010101');
	
	// Какие элементы структуры отчета (колонки, элементы группировки, макета) выводить в отчет.
	ПараметрыОтчета.Вставить("ВыводитьЗаголовок",        Истина);
	ПараметрыОтчета.Вставить("ВыводитьЕдиницуИзмерения", Ложь);
	ПараметрыОтчета.Вставить("ВыводитьПодвал",           Ложь);
	ПараметрыОтчета.Вставить("ОтветственноеЛицо",        Перечисления.ОтветственныеЛицаОрганизаций.ОтветственныйЗаБухгалтерскиеРегистры);
	
	ПараметрыОтчета.Вставить("ИмяВарианта",           "");     // имя варианта настроек
	ПараметрыОтчета.Вставить("МакетОформления",       БухгалтерскиеОтчетыКлиентСервер.ИмяМакетаОформленияПоУмолчанию());
	ПараметрыОтчета.Вставить("ВыделятьОтрицательные", Истина); // предопределенная настройка оформления
	ПараметрыОтчета.Вставить("УменьшенныйАвтоотступ", Ложь);   // предопределенная настройка оформления
	
	Возврат ПараметрыОтчета;
	
КонецФункции

Процедура ДобавитьПоказателиВПараметры(ПараметрыОтчета, НаборПоказателей) Экспорт
	
	ПараметрыОтчета.НаборПоказателей = НаборПоказателей;

	Для каждого Показатель Из НаборПоказателей Цикл
		ПараметрыОтчета.Вставить("Показатель" + Показатель, Ложь);
	КонецЦикла;
	
КонецПроцедуры

// Переносим из реквизитов формы в универсальные настройки.
//
// Параметры:
//  ПараметрыОтчета - Структура - см. ПустыеПараметрыКомпоновкиОтчета()
//  Форма - УправляемаяФорма - содержит основновной реквизит Отчет .
//
Процедура ЗаполнитьПараметрыИзФормы(ПараметрыОтчета, Форма) Экспорт
	Перем ЗначениеПоказателя, Группировки, РазмещениеДополнительныхПолей;
	
	Отчет = Форма.Отчет;

	ПараметрыОтчета.СхемаКомпоновкиДанных     = ПолучитьИзВременногоХранилища(Форма.СхемаКомпоновкиДанных);
	ПараметрыОтчета.НастройкиКомпоновкиДанных = Отчет.КомпоновщикНастроек.ПолучитьНастройки();
	ПараметрыОтчета.ДанныеРасшифровки         = Форма.ДанныеРасшифровки;
	ПараметрыОтчета.РежимРасшифровки          = Отчет.РежимРасшифровки;
	
	РежимВыгрузки = Ложь;
	Если Форма.Параметры.Свойство("РежимВыгрузки", РежимВыгрузки) И РежимВыгрузки Тогда
		
		ПараметрыОтчета.Вставить("РежимВыгрузки", РежимВыгрузки);
		ПараметрыОтчета.Вставить("ПараметрыРежимаВыгрузки",
			Форма.Параметры.ПользовательскиеНастройки.ДополнительныеСвойства.ПараметрыРежимаВыгрузки);
		
	КонецЕсли;

	ПараметрыОтчета.Организация                       = Отчет.Организация;
	ПараметрыОтчета.ВключатьОбособленныеПодразделения = Отчет.ВключатьОбособленныеПодразделения;
	
	Если Отчет.Свойство("Период") Тогда
		ПараметрыОтчета.Период = Отчет.Период;
	КонецЕсли;
	Если Отчет.Свойство("НачалоПериода") Тогда
		ПараметрыОтчета.НачалоПериода = Отчет.НачалоПериода;
	КонецЕсли;
	Если Отчет.Свойство("КонецПериода") Тогда
		ПараметрыОтчета.КонецПериода  = Отчет.КонецПериода;
	КонецЕсли;

	Для каждого Показатель Из ПараметрыОтчета.НаборПоказателей Цикл

		ПараметрыОтчета.Вставить("Показатель" + Показатель,
			Отчет.Свойство("Показатель" + Показатель, ЗначениеПоказателя) И ЗначениеПоказателя = Истина);
	
	КонецЦикла;
	БухгалтерскиеОтчетыПереопределяемый.ОтключитьНедоступныеПоказатели(ПараметрыОтчета);	

	ПараметрыОтчета.ВыводитьЗаголовок = Форма.ВыводитьЗаголовок;
	ПараметрыОтчета.ВыводитьПодвал = Форма.ВыводитьПодвал;
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма, "ВыводитьЕдиницуИзмерения") Тогда
		ПараметрыОтчета.ВыводитьЕдиницуИзмерения = Форма.ВыводитьЕдиницуИзмерения;
	КонецЕсли;
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма, "ВыводитьПримечания") Тогда
		ПараметрыОтчета.ВыводитьПримечания = Форма.ВыводитьПримечания;
	КонецЕсли;
	
	ПараметрыОтчета.МакетОформления = Форма.МакетОформления;
	
	ВидыТаблицГруппировок = Новый Массив;
	ВидыТаблицГруппировок.Добавить("Группировка");
	ВидыТаблицГруппировок.Добавить("ГруппировкаКор");
	ВидыТаблицГруппировок.Добавить("РазвернутоеСальдо");
	Для каждого ВариантГруппировки Из ВидыТаблицГруппировок Цикл
	
		Если Не Отчет.Свойство(ВариантГруппировки, Группировки)
		 Или ТипЗнч(ПараметрыОтчета[ВариантГруппировки]) <> Тип("ТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		ТаблицаГруппировок = ПараметрыОтчета[ВариантГруппировки];
		НастройкиПоСчетам = (ТаблицаГруппировок.Колонки.Найти("Счет") <> Неопределено);
		Для Каждого Группировка Из Группировки Цикл
			ЗаполнитьЗначенияСвойств(ТаблицаГруппировок.Добавить(), Группировка);
		КонецЦикла;
	
	КонецЦикла;
	
	Если Отчет.Свойство("РазмещениеДополнительныхПолей", РазмещениеДополнительныхПолей) Тогда
		
		ПараметрыОтчета.РазмещениеДополнительныхПолей = РазмещениеДополнительныхПолей;
		
		Для Каждого ДопПоле Из Отчет.ДополнительныеПоля Цикл
			ЗаполнитьЗначенияСвойств(ПараметрыОтчета.ДополнительныеПоля.Добавить(), ДопПоле);
		КонецЦикла;
		
	КонецЕсли;

	Если Отчет.Свойство("Интервалы") Тогда
		
		Для Каждого СтрокаИнтервала Из Отчет.Интервалы Цикл
			ЗаполнитьЗначенияСвойств(ПараметрыОтчета.Интервалы.Добавить(), СтрокаИнтервала);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Подбирает настройку по имени, создавая при необходимости и саму настройку СКД, и соответствующую ей пользовательскую настройку.
//
// Параметры:
//  ВидНастроек - Строка - соответствует ключам объекта НастройкиКомпоновкиДанных.
//  КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - из настраиваемого отчета.
//  НовыеПользовательскиеНастройкиКД - ПользовательскиеНастройкиКомпоновкиДанных - в ДополнительныеСвойства содержат параметры настройки.
//  ИмяНастройки - Строка - имя поля у элемента настроек данного вида.
//
// Возвращаемое значение:
//   Элемент из КоллекцияЭлементовПользовательскихНастроекКомпоновкиДанных - подобранная настройка.
//
Функция НайтиСоздатьНастройкуКомпоновщика(ВидНастроек, КомпоновщикНастроек, НовыеПользовательскиеНастройкиКД, ИмяНастройки = "") Экспорт
	Перем ЦелеваяНастройка;
	
	Если ВидНастроек = "Выбор" Тогда
		
		ОбщаяНастройка = КомпоновщикНастроек.Настройки.Выбор;
		
	ИначеЕсли ВидНастроек = "Отбор" Тогда
		
		НастройкиОтчета = КомпоновщикНастроек.Настройки.Отбор.Элементы;
		Для Каждого ЭлементОтбора Из НастройкиОтчета Цикл
			Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных")
			   И Строка(ЭлементОтбора.ЛевоеЗначение) = ИмяНастройки Тогда
				ОбщаяНастройка = ЭлементОтбора;
			КонецЕсли;
		КонецЦикла;
		Если ОбщаяНастройка = Неопределено Тогда
			
			ОбщаяНастройка = НастройкиОтчета.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ОбщаяНастройка.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяНастройки);
			ОбщаяНастройка.ИдентификаторПользовательскойНастройки = Новый УникальныйИдентификатор;
			
		КонецЕсли;
		
	ИначеЕсли ВидНастроек = "ПараметрВывода" Тогда
		
		НастройкиОтчета = КомпоновщикНастроек.Настройки.ПараметрыВывода.Элементы;
		ОбщаяНастройка = НастройкиОтчета.Найти(ИмяНастройки);
		
	ИначеЕсли ВидНастроек = "ПараметрДанных" Тогда
		
		ПараметрДанных = Новый ПараметрКомпоновкиДанных(ИмяНастройки);
		ОбщаяНастройка = КомпоновщикНастроек.Настройки.ПараметрыДанных.НайтиЗначениеПараметра(ПараметрДанных);
		Если ОбщаяНастройка = Неопределено И ИмяНастройки = "ПериодОтчета" Тогда
			ПараметрДанных = Новый ПараметрКомпоновкиДанных("Период");
			ОбщаяНастройка = КомпоновщикНастроек.Настройки.ПараметрыДанных.НайтиЗначениеПараметра(ПараметрДанных);
		КонецЕсли;
		
	ИначеЕсли ВидНастроек = "УсловноеОформление" Тогда
		
		ПараметрДанных = Новый ПараметрКомпоновкиДанных(ИмяНастройки);
		НастройкиОтчета = КомпоновщикНастроек.Настройки.УсловноеОформление.Элементы;
		Для каждого ЭлементКоллекции Из НастройкиОтчета Цикл
			
			ЭлементОформления = ЭлементКоллекции.Оформление.НайтиЗначениеПараметра(ПараметрДанных);
			Если ЭлементОформления <> Неопределено И ЭлементОформления.Использование Тогда
				ОбщаяНастройка = ЭлементКоллекции;
				Прервать;
			КонецЕсли;
		
		КонецЦикла; 
		Если ОбщаяНастройка = Неопределено Тогда
			
			ОбщаяНастройка = НастройкиОтчета.Добавить();
			ОбщаяНастройка.ИдентификаторПользовательскойНастройки = Новый УникальныйИдентификатор;
			
		КонецЕсли;

	КонецЕсли;
	
	Если Не ПустаяСтрока(ОбщаяНастройка.ИдентификаторПользовательскойНастройки) Тогда
			
		ЦелеваяНастройка = НовыеПользовательскиеНастройкиКД.Элементы.Найти(ОбщаяНастройка.ИдентификаторПользовательскойНастройки);
		Если ЦелеваяНастройка = Неопределено Тогда
			ЦелеваяНастройка = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(ОбщаяНастройка.ИдентификаторПользовательскойНастройки);
		КонецЕсли;
		
	КонецЕсли;
	Если ЦелеваяНастройка = Неопределено Тогда
		ЦелеваяНастройка = ОбщаяНастройка;
	КонецЕсли;
	
	Возврат ЦелеваяНастройка;
	
КонецФункции

Процедура ЗаполнитьСтандартныйПериод(ЗначениеСтандартногоПериода, НачалоПериода, КонецПериода) Экспорт
	
	Сейчас = ТекущаяДатаСеанса();
	ВидПериода = ВыборПериодаКлиентСервер.ПолучитьВидПериода(НачалоПериода, КонецДня(КонецПериода));
	ПодобраноЗначениеСтандартногоПериода = Истина;
	Если ВидПериода = Перечисления.ДоступныеПериодыОтчета.Год Тогда
		Если НачалоГода(НачалоПериода) = НачалоГода(Сейчас) Тогда
			ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ЭтотГод;
		ИначеЕсли НачалоГода(НачалоПериода) = НачалоГода(ДобавитьМесяц(Сейчас, -12)) Тогда
			ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ПрошлыйГод;
		Иначе
			ПодобраноЗначениеСтандартногоПериода = Ложь;
		КонецЕсли;
	ИначеЕсли ВидПериода = Перечисления.ДоступныеПериодыОтчета.Полугодие Тогда	
		
		ЭталонныйПериод = Окр(Месяц(Сейчас) / 6, 0, РежимОкругления.Окр15как10);
		ПроверяемыйПериод = НачалоПериода;
		Если Год(Сейчас) = Год(ПроверяемыйПериод)
		   И ЭталонныйПериод = Окр(Месяц(ПроверяемыйПериод) / 6, 0, РежимОкругления.Окр15как10) Тогда
			ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ЭтоПолугодие;
		Иначе
			ПроверяемыйПериод = ДобавитьМесяц(ПроверяемыйПериод, -6);
			Если Год(Сейчас) = Год(ПроверяемыйПериод)
			   И ЭталонныйПериод = Окр(Месяц(ПроверяемыйПериод) / 6, 0, РежимОкругления.Окр15как10) Тогда
				ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ПрошлоеПолугодие;
			Иначе
				ПодобраноЗначениеСтандартногоПериода = Ложь;
			КонецЕсли;
		КонецЕсли;

	ИначеЕсли ВидПериода = Перечисления.ДоступныеПериодыОтчета.Квартал Тогда
		
		ЭталонныйПериод = Окр(Месяц(Сейчас) / 3, 0, РежимОкругления.Окр15как10);
		ПроверяемыйПериод = НачалоПериода;
		Если Год(Сейчас) = Год(ПроверяемыйПериод)
		   И ЭталонныйПериод = Окр(Месяц(ПроверяемыйПериод) / 3, 0, РежимОкругления.Окр15как10) Тогда
			ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ЭтотКвартал;
		Иначе
			ПроверяемыйПериод = ДобавитьМесяц(ПроверяемыйПериод, -3);
			Если Год(Сейчас) = Год(ПроверяемыйПериод)
			   И ЭталонныйПериод = Окр(Месяц(ПроверяемыйПериод) / 3, 0, РежимОкругления.Окр15как10) Тогда
				ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ПрошлыйКвартал;
			Иначе
				ПодобраноЗначениеСтандартногоПериода = Ложь;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли ВидПериода = Перечисления.ДоступныеПериодыОтчета.Месяц Тогда
		
		ЭталонныйПериод = Месяц(Сейчас);
		ПроверяемыйПериод = НачалоПериода;
		Если Год(Сейчас) = Год(ПроверяемыйПериод) И ЭталонныйПериод = Месяц(ПроверяемыйПериод) Тогда
			ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ЭтотМесяц;
		Иначе
			ПроверяемыйПериод = ДобавитьМесяц(ПроверяемыйПериод, -1);
			Если Год(Сейчас) = Год(ПроверяемыйПериод) И ЭталонныйПериод = Месяц(ПроверяемыйПериод) Тогда
				ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ПрошлыйМесяц;
			Иначе
				ПодобраноЗначениеСтандартногоПериода = Ложь;
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		ПодобраноЗначениеСтандартногоПериода = Ложь;
	КонецЕсли;
	Если Не ПодобраноЗначениеСтандартногоПериода Тогда
		
		ЗначениеСтандартногоПериода.Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод;
		ЗначениеСтандартногоПериода.ДатаНачала = НачалоПериода;
		ЗначениеСтандартногоПериода.ДатаОкончания = КонецПериода;
		
	КонецЕсли;
	
КонецПроцедуры

// Устанавливаем параметры СхемаКомпоновкиДанных и НастройкиКомпоновкиДанных.
//
// Параметры:
//  ПараметрыОтчета - см. ПустыеПараметрыКомпоновкиОтчета()
//
// После вызова данной процедуры вызывающий код может редактировать настройки СКД, с которыми будет формироваться отчет:
// * Отборы.
//     БухгалтерскиеОтчетыКлиентСервер.ДобавитьОтбор(
//         ПараметрыОтчета.НастройкиКомпоновкиДанных.Отбор, ИмяЛевогоПоля, ЗначениеПравогоПоля, ВидСравнения);
// * Порядок.
//     ПолеПорядка = ПараметрыОтчета.НастройкиКомпоновкиДанных.Порядок.Элементы.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
//     ПолеПорядка.Поле = Новый ПолеКомпоновкиДанных(Настройка.Поле);
//     ПолеПорядка.ТипУпорядочивания = ?(Настройка.ТипУпорядочивания = 1,
//         НаправлениеСортировкиКомпоновкиДанных.Убыв, НаправлениеСортировкиКомпоновкиДанных.Возр);
//     ПолеПорядка.Использование = Истина;
// * Условное оформление.
//     ЭлементУсловногоОформления = ПараметрыОтчета.НастройкиКомпоновкиДанных.УсловноеОформление.Элементы.Добавить();
//     БухгалтерскиеОтчетыКлиентСервер.УстановитьПараметр(ЭлементУсловногоОформления.Оформление, ИмяПараметра, ЗначениеПараметра);
//     ЭлементУсловногоОформления.Представление = ПредставлениеПараметра;
//
// Кроме того, в ПараметрыОтчета могут быть переданы заранее подготовленные ПользовательскиеНастройки
// (тип ПользовательскиеНастройкиКомпоновкиДанных), которые необходимо загрузить в СКД.
//
Процедура ПодготовитьСхемуКомпоновкиДанных(ПараметрыОтчета) Экспорт

	МенеджерОтчета = Отчеты[ПараметрыОтчета.ИдентификаторОтчета];
	ПараметрыОтчета.СхемаКомпоновкиДанных = МенеджерОтчета.ПолучитьМакет("СхемаКомпоновкиДанных");
	Если ПараметрыОтчета.Свойство("Счет") Тогда
		МенеджерОтчета.НастроитьСхемуКомпоновкиДанных(ПараметрыОтчета.СхемаКомпоновкиДанных, ПараметрыОтчета.Счет);
	КонецЕсли;
	
	// Если явно указан вариант отчета, то используем его,
	// иначе - основной вариант отчета, который совпадает с названием отчета.
	Если ПараметрыОтчета.Свойство("КлючВарианта") Тогда
		КлючВарианта = ПараметрыОтчета.КлючВарианта;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КлючВарианта) Тогда
		КлючВарианта = ПараметрыОтчета.ИдентификаторОтчета;
	КонецЕсли;
	ПараметрыОтчета.НастройкиКомпоновкиДанных = ПараметрыОтчета.СхемаКомпоновкиДанных.ВариантыНастроек[КлючВарианта].Настройки;

	// Если переданы подготовленные пользовательские настройки, то загрузим их.
	Если ПараметрыОтчета.Свойство("ПользовательскиеНастройки") Тогда
	    ИсточникДоступныхДанных = Новый ИсточникДоступныхНастроекКомпоновкиДанных(ПараметрыОтчета.СхемаКомпоновкиДанных);
	    
		КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных();
		КомпоновщикНастроек.Инициализировать(ИсточникДоступныхДанных);
		
		КомпоновщикНастроек.ЗагрузитьНастройки(ПараметрыОтчета.НастройкиКомпоновкиДанных);

		// Установка пользовательских настроек.
		ТекущиеНастройки = КомпоновщикНастроек.Настройки;
		ТекущиеНастройки.Отбор.ИдентификаторПользовательскойНастройки              = "Отбор";
		ТекущиеНастройки.Порядок.ИдентификаторПользовательскойНастройки            = "Порядок";
		ТекущиеНастройки.УсловноеОформление.ИдентификаторПользовательскойНастройки = "УсловноеОформление";
		
		КомпоновщикНастроек.ЗагрузитьПользовательскиеНастройки(ПараметрыОтчета.ПользовательскиеНастройки);
		
		ПараметрыОтчета.НастройкиКомпоновкиДанных = КомпоновщикНастроек.ПолучитьНастройки();
		
		// Очистка пользовательских настроек.
		ТекущиеНастройки = ПараметрыОтчета.НастройкиКомпоновкиДанных;
		ТекущиеНастройки.Отбор.ИдентификаторПользовательскойНастройки              = "";
		ТекущиеНастройки.Порядок.ИдентификаторПользовательскойНастройки            = "";
		ТекущиеНастройки.УсловноеОформление.ИдентификаторПользовательскойНастройки = "";
	КонецЕсли;

	// Предопределенное условное оформление
	КоллекцияСКД = ПараметрыОтчета.НастройкиКомпоновкиДанных.УсловноеОформление;
	Если ПараметрыОтчета.УменьшенныйАвтоотступ Тогда
		
		ЭлементУсловногоОформления = Неопределено;
		Для каждого ЭлементКоллекции Из КоллекцияСКД.Элементы Цикл
		
			Если Не ЭлементКоллекции.Использование Тогда
				Продолжить;
			КонецЕсли;
			Для каждого ЭлементОформления Из ЭлементКоллекции.Оформление.Элементы Цикл
				Если ЭлементОформления.Использование И Строка(ЭлементОформления.Параметр) = "АвтоОтступ" Тогда
					ЭлементУсловногоОформления = ЭлементКоллекции;
				КонецЕсли;
			КонецЦикла;
		
		КонецЦикла; 
		Если ЭлементУсловногоОформления = Неопределено Тогда
			ЭлементУсловногоОформления = КоллекцияСКД.Элементы.Добавить();
		КонецЕсли;
		БухгалтерскиеОтчетыКлиентСервер.УстановитьПараметр(ЭлементУсловногоОформления.Оформление, "Автоотступ", 1);
		ЭлементУсловногоОформления.Представление = НСтр("ru = 'Уменьшенный автоотступ';
														|en = 'Reduced auto indent'");
		
	КонецЕсли;
	Если ПараметрыОтчета.ВыделятьОтрицательные Тогда
		
		ЭлементУсловногоОформления = Неопределено;
		Для каждого ЭлементКоллекции Из КоллекцияСКД.Элементы Цикл
		
			Если Не ЭлементКоллекции.Использование Тогда
				Продолжить;
			КонецЕсли;
			Для каждого ЭлементОформления Из ЭлементКоллекции.Оформление.Элементы Цикл
				Если ЭлементОформления.Использование И Строка(ЭлементОформления.Параметр) = "ВыделятьОтрицательные" Тогда
					ЭлементУсловногоОформления = ЭлементКоллекции;
				КонецЕсли;
			КонецЦикла;
		
		КонецЦикла; 
		Если ЭлементУсловногоОформления = Неопределено Тогда
			ЭлементУсловногоОформления = КоллекцияСКД.Элементы.Добавить();
		КонецЕсли;
		БухгалтерскиеОтчетыКлиентСервер.УстановитьПараметр(ЭлементУсловногоОформления.Оформление, "ВыделятьОтрицательные", Истина);
		ЭлементУсловногоОформления.Представление = НСтр("ru = 'Выделять отрицательные';
														|en = 'Select negative'");
		
	КонецЕсли;
	
КонецПроцедуры

// Заменяем имя субконто в переданном пути на "Субконто[N]" для переданного счета.
//
// Параметры:
//  Счет         - ПланСчетовСсылка.Хозрасчетный - счет, который содержит данный вид субконто.
//  ИмяПоля      - Строка - путь к полю СКД вида "[имя значения ПланВидовХарактеристик.ВидыСубконтоХозрасчетные]{.[ИмяРеквизита]}"
//  ПредставленияСубконто - Структура - кеш сопоставлений:
//                          * ключ - строка - имя предопределенного элемента плана видов характеристик,
//                          * значение - строка - "Субконто[N]"
// Возвращаемое значение:
// Строка.
Функция ПодобратьНомерПоИмениВидаСубконто(Счет, Знач ИмяПоля, ПредставленияСубконто = Неопределено) Экспорт
	Перем ИмяСНомером, ВидСубконто;
	
	Если Не ЗначениеЗаполнено(Счет) Тогда 
		Возврат ИмяПоля;
	КонецЕсли; 
	
	// Подбираем виды субконто счета.
	ПозицияТочки = СтрНайти(ИмяПоля, ".");
	ИмяВидаСубконто = ?(ПозицияТочки = 0, ИмяПоля, Лев(ИмяПоля, ПозицияТочки - 1));
	
	Если ПредставленияСубконто = Неопределено Или Не ПредставленияСубконто.Свойство(ИмяВидаСубконто, ИмяСНомером) Тогда
		
		ВидыСубконтоХозрасчетные = СтандартныеПодсистемыПовтИсп.СсылкиПоИменамПредопределенных(
			"ПланВидовХарактеристик.ВидыСубконтоХозрасчетные");
		ВидСубконто = ВидыСубконтоХозрасчетные.Получить(ИмяВидаСубконто);
		Если Не ЗначениеЗаполнено(ВидСубконто) Тогда
			Возврат ИмяПоля;
		КонецЕсли;
		
		НомерСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.НомерСубконто(Счет, ВидСубконто);
		Если Не ЗначениеЗаполнено(НомерСубконто) Тогда
			Возврат ИмяПоля;
		КонецЕсли;
		
		ИмяСНомером = "Субконто" + НомерСубконто;
		Если ПредставленияСубконто <> Неопределено Тогда 
			ПредставленияСубконто.Вставить(ИмяВидаСубконто, ИмяСНомером);
		КонецЕсли;
		
	КонецЕсли;
	Если ПозицияТочки <> 0 Тогда
		ИмяСНомером = ИмяСНомером + Сред(ИмяПоля, ПозицияТочки);
	КонецЕсли;

	Возврат ИмяСНомером;
	
КонецФункции

Процедура ЗаполнитьУровеньГруппировки(ГруппировкиКомпоновки, ГруппировкиНастроек, УровеньГруппировки = 0)
	
	Если ГруппировкиНастроек.Количество() <= УровеньГруппировки Тогда
		Возврат;
	КонецЕсли;
	Если ГруппировкиКомпоновки.Количество() = 0 Тогда
		ГруппировкаКомпоновки = ГруппировкиКомпоновки.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	КонецЕсли;	
	
	ГруппировкаОбработана = Ложь;
	Для Каждого ГруппировкаКомпоновки Из ГруппировкиКомпоновки Цикл
		
		Если ГруппировкаОбработана Тогда // все следующие (если они есть) только отключаем
			
			ГруппировкаКомпоновки.Использование = Ложь;
			Продолжить;
			
		КонецЕсли;
		ГруппировкаОбработана = Истина;
		ГруппировкаКомпоновки.Использование = Истина;
		ГруппировкаКомпоновки.ПоляГруппировки.Элементы.Очистить();
		ПоляГруппировки = ГруппировкаКомпоновки.Выбор.Элементы;
		
		// Обеспечиваем наличие авто-поля для работы доп.полей.
		НомерУдаляемогоЭлемента = 0;
		Пока ПоляГруппировки.Количество() > НомерУдаляемогоЭлемента Цикл
			
			ПолеГруппировки = ПоляГруппировки[НомерУдаляемогоЭлемента];
			Если ТипЗнч(ПолеГруппировки) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
				
				ПолеГруппировки.Использование = Истина;
				НомерУдаляемогоЭлемента = НомерУдаляемогоЭлемента + 1;
				
			Иначе
				
				ПоляГруппировки.Удалить(ПолеГруппировки);
				
			КонецЕсли;

		КонецЦикла;
		Если НомерУдаляемогоЭлемента = 0 Тогда // нет автовыбранного поля
			
			ПолеГруппировки = ПоляГруппировки.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
			ПолеГруппировки.Использование = Истина;
			
		КонецЕсли;
		
		Если ГруппировкаКомпоновки.Порядок.Элементы.Количество() = 0 Тогда
			ПолеГруппировки = ГруппировкаКомпоновки.Порядок.Элементы.Добавить(Тип("АвтоЭлементПорядкаКомпоновкиДанных"));
			ПолеГруппировки.Использование = Истина;
		КонецЕсли;
		
		// Добавляем поле группировки.
		ПолеНастроек = ГруппировкиНастроек[УровеньГруппировки];
		ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ПолеНастроек.Поле);
		
		ПолеГруппировки = ПоляГруппировки.Вставить(0, Тип("ВыбранноеПолеКомпоновкиДанных"));
		ПолеГруппировки.Поле          = ПолеКомпоновки;
		ПолеГруппировки.Заголовок     = ПолеНастроек.Представление;
		ПолеГруппировки.Использование = Истина;
		
		ПолеГруппировки = ГруппировкаКомпоновки.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
		ПолеГруппировки.Поле          = ПолеКомпоновки;
		Если ПолеНастроек.ТипГруппировки = 1 Тогда
			ПолеГруппировки.ТипГруппировки = ТипГруппировкиКомпоновкиДанных.Иерархия;
		ИначеЕсли ПолеНастроек.ТипГруппировки = 2 Тогда
			ПолеГруппировки.ТипГруппировки = ТипГруппировкиКомпоновкиДанных.ТолькоИерархия;
		Иначе
			ПолеГруппировки.ТипГруппировки = ТипГруппировкиКомпоновкиДанных.Элементы;
		КонецЕсли;
		ПолеГруппировки.Использование = Истина;
		
		ЗаполнитьУровеньГруппировки(ГруппировкаКомпоновки.Структура, ГруппировкиНастроек, УровеньГруппировки + 1);
		
	КонецЦикла;
	
КонецПроцедуры

Функция НаборПолейЭквивалентен(ЭталонныеПоля, ТекущиеПоля)
	
	КоличествоПолей = ТекущиеПоля.Количество();
	ИндексПоля = -1;
	Для Каждого ПолеНастроек Из ЭталонныеПоля Цикл
		ИндексПоля = ИндексПоля + 1;
		
		Если Не ПолеНастроек.Использование Тогда
			Продолжить;
		КонецЕсли;

		Если ИндексПоля >= КоличествоПолей Тогда // последние из полей удалили
			Возврат Ложь;
		КонецЕсли;
		
		ТекущееПолеНастроек = ТекущиеПоля[ИндексПоля];
		Если Не ТекущееПолеНастроек.Использование Тогда // сняли признак использования
			Возврат Ложь;
		КонецЕсли;
		
		ТипПоля = ТипЗнч(ПолеНастроек);
		Если ТипПоля = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
			
			Если Не НаборПолейЭквивалентен(ПолеНастроек.Элементы, ТекущееПолеНастроек.Элементы) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		ИначеЕсли ТипПоля = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
			
			Если ТипЗнч(ТекущееПолеНастроек) <> Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
				Возврат Ложь;
			КонецЕсли;
			
		Иначе
			
			ИмяПоля = Строка(ТекущееПолеНастроек.Поле);
			Если Строка(ПолеНастроек.Поле) <> ИмяПоля Тогда
				Возврат Ложь;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция СтруктураЭквивалентна(ЭталонныеНастройки, ТекущиеНастройки)
	
	КоличествоЭлементов = ТекущиеНастройки.Количество();
	инд = 0;
	Для Каждого ЭлементНастройки Из ЭталонныеНастройки Цикл
		
		Если инд >= КоличествоЭлементов Тогда // отсутствуют последние элементы на этом уровне структуры
			Возврат Ложь;
		КонецЕсли;
		
		ТекущийЭлементНастроек = ТекущиеНастройки[инд];
		Если ТипЗнч(ЭлементНастройки) <> ТипЗнч(ТекущийЭлементНастроек) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Не НаборПолейЭквивалентен(ЭлементНастройки.Выбор.Элементы, ТекущийЭлементНастроек.Выбор.Элементы) Тогда
			Возврат Ложь;
		КонецЕсли;

		Если Не СтруктураЭквивалентна(ЭлементНастройки.Структура, ТекущийЭлементНастроек.Структура) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		инд = инд + 1;
		
	КонецЦикла;
		
	Возврат Истина;
	
КонецФункции

#КонецОбласти

//-- НЕ УТ
