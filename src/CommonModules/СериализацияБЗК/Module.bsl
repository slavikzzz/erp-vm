#Область СлужебныйПрограммныйИнтерфейс

#Область DOM

// На основании XML получает структуру с документом DOM и разыменователем пространств имен DOM.
//   Полученную структуру можно передавать в другие методы модуля в качестве параметра СтруктураDOM.
//
// Параметры:
//   XMLСтрокаИлиДвоичныеДанные - Строка, ДвоичныеДанные - Строка в формате XML или двоичные данные XML документа.
//
// Возвращаемое значение:
//   Структура - Информация о документе DOM.
//       * ДокументDOM - ДокументDOM
//       * Разыменователь - РазыменовательПространствИменDOM
//
Функция СтруктураDOM(XMLСтрокаИлиДвоичныеДанные) Экспорт
	Если ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		БуферДвоичныхДанных = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(XMLСтрокаИлиДвоичныеДанные);
		ПотокВПамяти = Новый ПотокВПамяти(БуферДвоичныхДанных);
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.ОткрытьПоток(ПотокВПамяти);
	ИначеЕсли ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("Строка") Тогда
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XMLСтрокаИлиДвоичныеДанные);
	КонецЕсли;
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	ЧтениеXML.Закрыть();
	
	СтруктураDOM = Новый Структура;
	СтруктураDOM.Вставить("ДокументDOM", ДокументDOM);
	СтруктураDOM.Вставить("Разыменователь", Новый РазыменовательПространствИменDOM(ДокументDOM));
	Возврат СтруктураDOM;
КонецФункции

// Находит узел документа DOM используя выражение XPath.
//
// Параметры:
//   СтруктураDOM - Структура - См. СериализацияБЗК.СтруктураDOM.
//   ВыражениеXPath - Строка - См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath", параметр "Выражение".
//   ЭлементDOM - Произвольный - Элемент документа, в контексте которого выполняется поиск.
//       См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath", параметр "УзелКонтекста".
//
// Возвращаемое значение:
//   Неопределено - Если элемент не найден.
//   ЭлементDOM, Произвольный - См. в синтакс-помощнике "РезультатXPath.ПолучитьСледующий", возвращаемое значение.
//
Функция НайтиУзелDOM(Знач СтруктураDOM, Знач ВыражениеXPath, Знач ЭлементDOM = Неопределено) Экспорт
	Возврат ВычислитьВыражениеXPath(СтруктураDOM, ВыражениеXPath, ЭлементDOM).ПолучитьСледующий();
КонецФункции

// Находит узел документа DOM используя выражение XPath.
//
// Параметры:
//   СтруктураDOM - Структура - См. СериализацияБЗК.СтруктураDOM.
//   ЛокальноеИмя - Строка - Имя элемента или маска имени. Допускается использование предопределенного шаблона '*'.
//
// Возвращаемое значение:
//   Неопределено - Если элемент не найден.
//   ЭлементDOM, Произвольный - См. в синтакс-помощнике "СписокЭлементовDOM", элементы коллекции.
//
Функция НайтиУзелDOMПоИмени(Знач СтруктураDOM, Знач ЛокальноеИмя) Экспорт
	СписокЭлементовDOM = СтруктураDOM.ДокументDOM.ПолучитьЭлементыПоИмени("*", ЛокальноеИмя);
	Возврат ?(СписокЭлементовDOM.Количество() > 0, СписокЭлементовDOM[0], Неопределено);
КонецФункции

// Вычисляет выражение XPath для документа DOM.
//
// Параметры:
//   СтруктураDOM - Структура - См. СериализацияБЗК.СтруктураDOM.
//   ВыражениеXPath - Строка - См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath", параметр "Выражение".
//   ЭлементDOM - Произвольный - Элемент документа, в контексте которого выполняется поиск.
//       См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath", параметр "УзелКонтекста".
//
// Возвращаемое значение:
//   РезультатXPath - См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath".
//
Функция ВычислитьВыражениеXPath(Знач СтруктураDOM, Знач ВыражениеXPath, Знач ЭлементDOM = Неопределено) Экспорт
	Если ЭлементDOM = Неопределено Тогда
		ЭлементDOM = СтруктураDOM.ДокументDOM;
	КонецЕсли;
	Возврат СтруктураDOM.ДокументDOM.ВычислитьВыражениеXPath(ВыражениеXPath, ЭлементDOM, СтруктураDOM.Разыменователь);
КонецФункции

// Преобразует (сериализует) объект DOM в строку в формате XML.
//
// Параметры:
//   ОбъектDOM - ЭлементDOM, ДокументDOM - Объект, который требуется сериализовать в строку XML.
//
// Возвращаемое значение:
//   Строка
//
Функция ОбъектDOMВСтрокуXML(ОбъектDOM) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ОбъектDOM, ЗаписьXML);
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Получает дочерние узлы элемента DOM по перечисленным именам.
//
// Параметры:
//   ЭлементDOM      - ЭлементDOM
//   ИменаРеквизитов - Строка - Если имена не указаны, то будут получены все узлы.
//
// Возвращаемое значение:
//   Структура - Найденные узлы.
//       * Ключ     - Строка     - Имя узла.
//       * Значение - ЭлементDOM - Дочерний узел.
//
Функция УзлыЭлементаDOM(ЭлементDOM, ИменаРеквизитов = "") Экспорт
	Все = ПустаяСтрока(ИменаРеквизитов);
	Если Все Тогда
		Результат = Новый Структура;
	Иначе
		Результат = Новый Структура(ИменаРеквизитов);
	КонецЕсли;
	Если ЭлементDOM = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	Для Каждого ВложенныйЭлементDOM Из ЭлементDOM.ДочерниеУзлы Цикл
		Если ВложенныйЭлементDOM.ТипУзла <> ТипУзлаDOM.Элемент Тогда
			Продолжить;
		КонецЕсли;
		ИмяУзла = ВложенныйЭлементDOM.ЛокальноеИмя;
		Если Не ЗначениеЗаполнено(ИмяУзла) Тогда
			ИмяУзла = СтроковыеФункцииБЗККлиентСервер.СтрПрав(ВложенныйЭлементDOM.ИмяУзла, ":");
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ИмяУзла) Тогда
			Продолжить;
		КонецЕсли;
		Если Все Тогда
			Если Результат.Свойство(ИмяУзла) Тогда
				Массив = Результат[ИмяУзла];
				Если ТипЗнч(Массив) <> Тип("Массив") Тогда
					Массив = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Массив);
				КонецЕсли;
				ОбщегоНазначенияБЗК.ДобавитьЗначениеВМассив(Массив, ВложенныйЭлементDOM);
				Результат[ИмяУзла] = Массив;
			Иначе
				Результат.Вставить(ИмяУзла, ВложенныйЭлементDOM);
			КонецЕсли;
		ИначеЕсли Результат.Свойство(ИмяУзла) Тогда
			Результат[ИмяУзла] = ВложенныйЭлементDOM;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Получает дочерние узлы элемента DOM по перечисленным именам и регистрирует необработанные узлы.
//
// Параметры:
//   ЭлементDOM      - ЭлементDOM
//   ИменаРеквизитов - Строка - Если имена не указаны, то будут получены все узлы.
//
// Возвращаемое значение:
//   Структура - Найденные узлы.
//       * Ключ     - Строка     - Имя узла.
//       * Значение - ЭлементDOM - Дочерний узел.
//
Функция УзлыЭлементаDOMСКонтролем(ЭлементDOM, ИменаРеквизитов) Экспорт
	НеобработанныеУзлыDOM = Новый Массив;
	Результат = Новый Структура(ИменаРеквизитов);
	Для Каждого ВложенныйЭлементDOM Из ЭлементDOM.ДочерниеУзлы Цикл
		Если ВложенныйЭлементDOM.ТипУзла = ТипУзлаDOM.Элемент Тогда
			Если Результат.Свойство(ВложенныйЭлементDOM.ЛокальноеИмя) Тогда
				Результат[ВложенныйЭлементDOM.ЛокальноеИмя] = ВложенныйЭлементDOM;
			Иначе
				НеобработанныеУзлыDOM.Добавить(СтрШаблон(НСтр("ru = 'Узел ""%1"", содержимое: ""%3"" (тип: ""%2"").';
																|en = 'Node ""%1"", content: ""%3"" (type: ""%2"").'"),
					ВложенныйЭлементDOM.ИмяУзла,
					ВложенныйЭлементDOM.ТипУзла,
					ВложенныйЭлементDOM.ТекстовоеСодержимое));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Результат.Вставить("ПредставленияНеобработанныхУзловDOM", НеобработанныеУзлыDOM);
	Возврат Результат;
КонецФункции

// Получает атрибуты элемента DOM по перечисленным именам.
//
// Параметры:
//   ЭлементDOM     - ЭлементDOM
//   ИменаАтрибутов - Строка - Если имена не указаны, то будут получены все атрибуты.
//
// Возвращаемое значение:
//   Структура - Значения атрибутов.
//       * Ключ     - Строка - Имя атрибута.
//       * Значение - Строка - XML-текст атрибута.
//
Функция АтрибутыЭлементаDOM(ЭлементDOM, ИменаАтрибутов = "") Экспорт
	Все = ПустаяСтрока(ИменаАтрибутов);
	Если Все Тогда
		Результат = Новый Структура;
	Иначе
		Результат = Новый Структура(ИменаАтрибутов);
	КонецЕсли;
	Для Каждого АтрибутDOM Из ЭлементDOM.Атрибуты Цикл
		Если АтрибутDOM.ТипУзла <> ТипУзлаDOM.Атрибут Тогда
			Продолжить;
		КонецЕсли;
		Если Все Тогда
			Результат.Вставить(АтрибутDOM.ЛокальноеИмя, АтрибутDOM.ТекстовоеСодержимое);
		ИначеЕсли Результат.Свойство(АтрибутDOM.ЛокальноеИмя) Тогда
			Результат[АтрибутDOM.ЛокальноеИмя] = АтрибутDOM.ТекстовоеСодержимое;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область XDTO

// Получает (десериализует) объект XDTO из строки в формате XML.
//
// Параметры:
//   СтрокаXML - Строка
//
// Возвращаемое значение:
//   ОбъектXDTO
//
Функция ОбъектXDTOИзСтрокиXML(СтрокаXML) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	ЧтениеXML.Закрыть();
	Возврат ОбъектXDTO;
КонецФункции

// Получает значение списочного свойства объекта XDTO.
//
// Параметры:
//   ОбъектXDTO - ОбъектXDTO
//   ПутьКСвойству - Строка
//
// Возвращаемое значение:
//   Массив
//
Функция СписокXDTO(ОбъектXDTO, ПутьКСвойству) Экспорт
	Если ОбъектXDTO = Неопределено Тогда
		Возврат Новый Массив;
	КонецЕсли;
	Значение = ОбщегоНазначенияБЗК.ЗначениеСвойства(ОбъектXDTO, ПутьКСвойству);
	Если Значение = Неопределено Тогда
		Возврат Новый Массив;
	ИначеЕсли ТипЗнч(Значение) = Тип("СписокXDTO") Тогда
		Возврат Значение;
	Иначе
		Массив = Новый Массив;
		Массив.Добавить(Значение);
		Возврат Массив;
	КонецЕсли;
КонецФункции

// Записывает (сериализует) объект XDTO в строку в формате XML.
//
// Параметры:
//   ОбъектXDTO - ОбъектXDTO
//   ИмяКорневогоУзла - Строка
//   ЗаписатьОбъявлениеXML - Булево
//
// Возвращаемое значение:
//   Строка - Строка XML.
//
Функция ОбъектXDTOВСтрокуXML(ОбъектXDTO, ИмяКорневогоУзла, ЗаписатьОбъявлениеXML = Ложь) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку("UTF-8");
	Если ЗаписатьОбъявлениеXML Тогда
		ЗаписьXML.ЗаписатьОбъявлениеXML();
	КонецЕсли;
	ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбъектXDTO, ИмяКорневогоУзла);
	Возврат ЗаписьXML.Закрыть();
КонецФункции

#КонецОбласти

#Область XML

// Преобразует строку XML (полученную из текста элемента или значения атрибута XML) в значение указанного типа.
//
// Параметры:
//   * СтрокаXML - Строка, Неопределено - Строка, полученная из XML.
//   * Тип - Тип - Тип ожидаемого значения.
//
// Возвращаемое значение:
//   Произвольный - В соответствии с указанным типом.
//       Если параметр "СтрокаXML" не заполнен, то значение параметра СтрокаXML возвращается без приведения к типу.
//       Например, если передать Неопределено, то на выходе тоже будет Неопределено.
//
Функция ЗначениеИзXML(ЗначениеXML, ТипВозвращаемогоЗначения) Экспорт
	ТипЗначенияXML = ТипЗнч(ЗначениеXML);
	Если ТипЗначенияXML = Тип("ЭлементDOM") Тогда
		Возврат ЗначениеИзXML(ЗначениеXML.ТекстовоеСодержимое, ТипВозвращаемогоЗначения);
	ИначеЕсли ТипЗначенияXML = ТипВозвращаемогоЗначения Тогда
		Возврат ЗначениеXML;
	ИначеЕсли ТипЗначенияXML = Тип("Строка") И Не ПустаяСтрока(ЗначениеXML) Тогда
		Возврат XMLЗначение(ТипВозвращаемогоЗначения, ЗначениеXML);
	ИначеЕсли ЗначениеXML = Неопределено Или ТипЗначенияXML = Тип("ОбъектXDTO") Или ТипЗначенияXML = Тип("СписокXDTO") Тогда
		Возврат Неопределено;
	Иначе
		Возврат ЗначениеXML;
	КонецЕсли;
КонецФункции

// Преобразует строку XML (полученную из текста элемента или значения атрибута XML) в значение типа Строка.
//
// Параметры:
//   ЗначениеXML - Строка, Неопределено, ОбъектXDTO - Значение свойства объекта, полученное из XML.
//
// Возвращаемое значение:
//   Строка
//
Функция СтрокаИзXML(ЗначениеXML) Экспорт
	ТипЗначенияXML = ТипЗнч(ЗначениеXML);
	Если ТипЗначенияXML = Тип("Строка") Тогда
		Возврат СокрЛП(ЗначениеXML);
	ИначеЕсли ТипЗначенияXML = Тип("ЭлементDOM") Тогда
		Возврат СокрЛП(ЗначениеXML.ТекстовоеСодержимое);
	ИначеЕсли ЗначениеXML = Неопределено Или ТипЗначенияXML = Тип("ОбъектXDTO") Тогда
		Возврат "";
	Иначе
		Возврат СокрЛП(Строка(ЗначениеXML));
	КонецЕсли;
КонецФункции

// Преобразует строку XML (полученную из текста элемента или значения атрибута XML) в значение типа Булево.
//
// Параметры:
//   ЗначениеXML - Строка, Неопределено, ОбъектXDTO - Значение свойства объекта, полученное из XML.
//
// Возвращаемое значение:
//   Булево, Неопределено
//
Функция БулевоИзXML(ЗначениеXML) Экспорт
	Возврат ЗначениеИзXML(ЗначениеXML, Тип("Булево"));
КонецФункции

// Преобразует строку XML (полученную из текста элемента или значения атрибута XML) в значение типа Дата.
//
// Параметры:
//   ЗначениеXML - Строка, Неопределено, ОбъектXDTO - Значение свойства объекта, полученное из XML.
//
// Возвращаемое значение:
//   Дата, Неопределено
//
Функция ДатаИзXML(ЗначениеXML) Экспорт
	Возврат ЗначениеИзXML(ЗначениеXML, Тип("Дата"));
КонецФункции

// Преобразует строку XML (полученную из текста элемента или значения атрибута XML) в значение типа Число.
//
// Параметры:
//   ЗначениеXML - Строка, Неопределено, ОбъектXDTO - Значение свойства объекта, полученное из XML.
//
// Возвращаемое значение:
//   Число, Неопределено
//
Функция ЧислоИзXML(ЗначениеXML) Экспорт
	Возврат ЗначениеИзXML(ЗначениеXML, Тип("Число"));
КонецФункции

// Возвращает Истина если ЭлементDOM = Неопределено или у элемента нет содержимого и есть атрибут xsi:nil="true".
Функция ЭтоЭлементТипаНеопределено(ЭлементDOM) Экспорт
	Если ЭлементDOM = Неопределено Тогда
		Возврат Истина;
	ИначеЕсли ТипЗнч(ЭлементDOM) = Тип("ЭлементDOM") И ЭлементDOM.ТекстовоеСодержимое = "" Тогда
		Для Каждого АтрибутDOM Из ЭлементDOM.Атрибуты Цикл
			Если АтрибутDOM.ТипУзла = ТипУзлаDOM.Атрибут
				И СтрСравнить(АтрибутDOM.ЛокальноеИмя, "nil") = 0 Тогда
				Возврат БулевоИзXML(АтрибутDOM.ТекстовоеСодержимое);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

// Преобразует строку XML (полученную из текста элемента или значения атрибута XML) в значение типа Строка.
//
// Параметры:
//   ОбъектXDTO - Неопределено, ОбъектXDTO - Объект XML.
//   ПутьКСвойству - Строка - Путь к свойству.
//
// Возвращаемое значение:
//   Строка
//
Функция СтроковыйРеквизитОбъекта(ОбъектXDTO, ПутьКСвойству) Экспорт
	Возврат СтрокаИзXML(ОбщегоНазначенияБЗК.ЗначениеСвойства(ОбъектXDTO, ПутьКСвойству));
КонецФункции

// Получает строку XML из значения типа "Строка" или "ДвоичныеДанные", размещенного во временном хранилище.
Функция СтрокаXMLИзВременногоХранилища(Адрес) Экспорт
	
	СтрокаИлиДвоичныеДанные = ПолучитьИзВременногоХранилища(Адрес);
	Тип = ТипЗнч(СтрокаИлиДвоичныеДанные);
	
	Если Тип = Тип("ДвоичныеДанные") Тогда
		
		Возврат СтрокаXMLИзДвоичныхДанных(СтрокаИлиДвоичныеДанные);
		
	ИначеЕсли Тип = Тип("Строка") Тогда
		
		Возврат СтрокаИлиДвоичныеДанные;
		
	Иначе
		
		ТекстОшибки = СтрШаблон(
			НСтр("ru = 'Функция %1 не поддерживает получение строки XML из типа %2';
				|en = 'The %1 function does not support getting XML string from %2 type'"),
			"СтрокаXMLИзВременногоХранилища",
			Тип);
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецФункции

// Получает строку XML из значения типа "Строка" или "ДвоичныеДанные", размещенного в хранилище значения.
Функция СтрокаXMLИзХранилищаЗначения(ХранилищеЗначения) Экспорт
	
	Если ТипЗнч(ХранилищеЗначения) <> Тип("ХранилищеЗначения") Тогда
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СериализацияБЗК.СтрокаXMLИзХранилищаЗначения",
			"ХранилищеЗначения",
			ХранилищеЗначения,
			Тип("ХранилищеЗначения"));
	КонецЕсли;
	
	СтрокаИлиДвоичныеДанные = ХранилищеЗначения.Получить();
	Тип = ТипЗнч(СтрокаИлиДвоичныеДанные);
	
	Если ТипЗнч(СтрокаИлиДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		
		Возврат СтрокаXMLИзДвоичныхДанных(СтрокаИлиДвоичныеДанные);
		
	ИначеЕсли Тип = Тип("Строка") Тогда
		
		Возврат СтрокаИлиДвоичныеДанные;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Получает строку XML из значения типа "ДвоичныеДанные", размещенного во временном хранилище.
Функция СтрокаXMLИзДвоичныхДанных(ДвоичныеДанные) Экспорт
	
	// Определение кодировки.
	Кодировка = КодировкаДвоичныхДанных(ДвоичныеДанные);
	Если Не ЗначениеЗаполнено(Кодировка) Тогда
		Кодировка = "UTF-8";
	КонецЕсли;
	
	// Получение строки.
	Возврат ПолучитьСтрокуИзДвоичныхДанных(ДвоичныеДанные, Кодировка);
	
КонецФункции

// Возвращает Истина если указанный ТипДанныхXML принадлежит объекту (СправочникОбъект, ДокументОбъект, ...).
Функция ЭтоТипОбъекта(ТипДанныхXML) Экспорт
	Возврат ТипДанныхXML <> Неопределено И СтрНайти(ТипДанныхXML.ИмяТипа, "Object.") > 0;
КонецФункции

// Возвращает Истина если указанный ТипДанныхXML принадлежит ссылке объекта (СправочникСсылка, ДокументСсылка, ...).
Функция ЭтоТипСсылки(ТипДанныхXML) Экспорт
	Возврат ТипДанныхXML <> Неопределено И СтрНайти(ТипДанныхXML.ИмяТипа, "Ref.") > 0;
КонецФункции

#КонецОбласти

#Область JSON

// Преобразует (сериализует) значение в строку в формате JSON.
// Внимание. В формат JSON допускается записывать только значения следующих типов:
//     * Строка,
//     * Число,
//     * Булево,
//     * Дата (преобразованная в строку),
//     * Массив,
//     * ФиксированныйМассив,
//     * Структура,
//     * ФиксированнаяСтруктура,
//     * Соответствие,
//     * ФиксированноеСоответствие.
//   Данное требование рекурсивно.
//
// Параметры:
//   Значение - Булево, Число, Строка, Массив, Структура, Соответствие - Объект, сериализуемый в JSON.
//   ПорядокКлючейВКоллекциях - Соответствие - Определяет порядок записи ключей коллекций в JSON.
//
// Возвращаемое значение:
//   Строка
//
Функция ЗначениеВСтрокуJSON(Значение, ПорядокКлючейВКоллекциях = Неопределено) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON());
	
	Если ПорядокКлючейВКоллекциях <> Неопределено Тогда
		ПродолжитьЗаписьЗначенияВJSON(ЗаписьJSON, Значение, ПорядокКлючейВКоллекциях);
	Иначе
		ЗаписатьJSON(ЗаписьJSON, Значение);
	КонецЕсли;
	
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

// Получает (десериализует) объект значение из строки в формате JSON.
//
// Параметры:
//   СтрокаJSON - Строка
//   ПрочитатьВСоответствие - Булево - Если Истина, то коллекции с ключами и значениями будут получены в Соответствие.
//       Если Ложь, то в Структуру.
//       Подробнее см. в синтакс-помощнике описание одноименного параметра метода глобального контекста "ПрочитатьJSON".
//   ПорядокКлючейВКоллекциях - Соответствие - Используется в случае, если важно запомнить порядок прочитанных ключей,
//       например, для использования в параметрах метода ЗначениеВСтрокуJSON.
//       На входе передается пустое соответствие.
//       После выполнения функции в ключи соответствия помещаются коллекции типа Структура и Соответствие,
//       а в значение порядок их ключей в виде массива.
//       Внимание. При удалении ключей из коллекции их также необходимо удалить и из порядка ключей.
//   ИменаСвойствСоЗначениямиДата - Массив, Строка, ФиксированныйМассив - Имена свойств, которые должны загружаться как
//       тип "Дата". Подробнее см. в синтакс-помощнике описание одноименного параметра метода глобального контекста "ПрочитатьJSON".
//
// Возвращаемое значение:
//   Булево, Число, Строка, Массив, Структура, Соответствие
//
Функция ЗначениеИзСтрокиJSON(СтрокаJSON, ПрочитатьВСоответствие = Ложь, ПорядокКлючейВКоллекциях = Неопределено, ИменаСвойствСоЗначениямиДата = "") Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	
	Если ПорядокКлючейВКоллекциях = Неопределено Тогда
		Возврат ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие, ИменаСвойствСоЗначениямиДата);
	Иначе
		Возврат ПродолжитьЧтениеЗначенияИзJSON(ЧтениеJSON, ПрочитатьВСоответствие, Неопределено, ПорядокКлючейВКоллекциях);
	КонецЕсли;
КонецФункции

#КонецОбласти

#Область УстаревшиеПроцедурыИФункции

// Устарела. Следует использовать СтрокаИзXML.
Функция ЗначениеXMLТипаСтрока(ЗначениеXML) Экспорт
	Возврат СтрокаИзXML(ЗначениеXML);
КонецФункции

// Устарела. Следует использовать ЗначениеИзXML или другие функции *ИзXML.
Функция ЗначениеXML(ЗначениеXML, ТипВозвращаемогоЗначения) Экспорт
	Возврат ЗначениеИзXML(ЗначениеXML, ТипВозвращаемогоЗначения);
КонецФункции

#КонецОбласти


#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПараметрыЗаписиJSON()
	Возврат Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Unix, "  ");
КонецФункции

Процедура ПродолжитьЗаписьЗначенияВJSON(ЗаписьJSON, Значение, ПорядокКлючейВКоллекциях)
	
	Если ТипЗнч(Значение) = Тип("Массив") Тогда
		
		ЗаписьJSON.ЗаписатьНачалоМассива();
		Для Каждого ВложенноеЗначение Из Значение Цикл
			ПродолжитьЗаписьЗначенияВJSON(ЗаписьJSON, ВложенноеЗначение, ПорядокКлючейВКоллекциях);
		КонецЦикла;
		ЗаписьJSON.ЗаписатьКонецМассива();
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Структура")
		Или ТипЗнч(Значение) = Тип("Соответствие") Тогда
		
		ЗаписьJSON.ЗаписатьНачалоОбъекта();
		ПорядокКлючейТекущейКоллекции = ПорядокКлючейВКоллекциях[Значение];
		Для Каждого Ключ Из ПорядокКлючейТекущейКоллекции Цикл
			ЗаписьJSON.ЗаписатьИмяСвойства(Ключ);
			ПродолжитьЗаписьЗначенияВJSON(ЗаписьJSON, Значение[Ключ], ПорядокКлючейВКоллекциях);
		КонецЦикла;
		ЗаписьJSON.ЗаписатьКонецОбъекта();
		
	Иначе
		
		ЗаписьJSON.ЗаписатьЗначение(Значение);
		
	КонецЕсли;
	
КонецПроцедуры

Функция ПродолжитьЧтениеЗначенияИзJSON(ЧтениеJSON, ПрочитатьВСоответствие, ТекущаяКоллекция, ПорядокКлючейВКоллекциях, ПорядокКлючейТекущейКоллекции = Неопределено)
	Значение = Неопределено;
	КлючУзлаJSON = Неопределено;
	
	Пока ЧтениеJSON.Прочитать() Цикл
		ТипУзлаJSON = ЧтениеJSON.ТипТекущегоЗначения;
		
		Если ТипУзлаJSON = ТипЗначенияJSON.КонецОбъекта Или ТипУзлаJSON = ТипЗначенияJSON.КонецМассива Тогда
			
			Возврат ТекущаяКоллекция;
			
		ИначеЕсли ТипУзлаJSON = ТипЗначенияJSON.ИмяСвойства Тогда
			
			КлючУзлаJSON = ЧтениеJSON.ТекущееЗначение;
			
			Если ПорядокКлючейТекущейКоллекции <> Неопределено Тогда
				ПорядокКлючейТекущейКоллекции.Добавить(КлючУзлаJSON);
			КонецЕсли;
			
		Иначе
			
			Если ТипУзлаJSON = ТипЗначенияJSON.НачалоОбъекта Тогда
				
				// Упорядоченное соответствие.
				Значение = ?(ПрочитатьВСоответствие, Новый Соответствие, Новый Структура);
				ПорядокКлючейВложеннойКоллекции = Новый Массив;
				ПорядокКлючейВКоллекциях.Вставить(Значение, ПорядокКлючейВложеннойКоллекции);
				ПродолжитьЧтениеЗначенияИзJSON(ЧтениеJSON, ПрочитатьВСоответствие, Значение, ПорядокКлючейВКоллекциях, ПорядокКлючейВложеннойКоллекции);
				
			ИначеЕсли ТипУзлаJSON = ТипЗначенияJSON.НачалоМассива Тогда
				
				// Вложенный массив.
				Значение = Новый Массив;
				ПродолжитьЧтениеЗначенияИзJSON(ЧтениеJSON, ПрочитатьВСоответствие, Значение, ПорядокКлючейВКоллекциях);
				
			Иначе
				
				Значение = ЧтениеJSON.ТекущееЗначение;
				
			КонецЕсли;
			
			Если ТипЗнч(ТекущаяКоллекция) = Тип("Массив") Тогда
				ТекущаяКоллекция.Добавить(Значение);
			ИначеЕсли ТекущаяКоллекция <> Неопределено Тогда
				ТекущаяКоллекция.Вставить(КлючУзлаJSON, Значение);
			Иначе
				Возврат Значение;
			КонецЕсли;
			
			КлючУзлаJSON = Неопределено;
			
		КонецЕсли;
	КонецЦикла;
	
КонецФункции

Функция КодировкаДвоичныхДанных(ДвоичныеДанные)
	// Если есть BOM, то это первичная информация о том, в каком формате записан текст.
	КодировкаBOM = КодировкаBOM(ДвоичныеДанные);
	Если ЗначениеЗаполнено(КодировкаBOM) Тогда
		Возврат КодировкаBOM;
	КонецЕсли;
	Возврат КодировкаXML(ДвоичныеДанные);
КонецФункции

Функция КодировкаXML(XMLСтрокаИлиДвоичныеДанные) Экспорт
	// Список кодировок XML см. в https://msdn.microsoft.com/en-us/library/dd317756.aspx
	Если ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		БуферДвоичныхДанных = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(XMLСтрокаИлиДвоичныеДанные);
		ПотокВПамяти = Новый ПотокВПамяти(БуферДвоичныхДанных);
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.ОткрытьПоток(ПотокВПамяти);
	ИначеЕсли ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("Строка") Тогда
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XMLСтрокаИлиДвоичныеДанные);
	КонецЕсли;
	
	Попытка
		ЧтениеXML.ПерейтиКСодержимому();
		КодировкаXML = ЧтениеXML.КодировкаXML;
	Исключение
		КодировкаXML = "";
	КонецПопытки;
	
	ЧтениеXML.Закрыть();
	
	Если ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		ПотокВПамяти.Закрыть();
	КонецЕсли;
	
	Возврат КодировкаXML;
КонецФункции

Функция КодировкаBOM(ДвоичныеДанные)
	ЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанные);
	БуферДвоичныхДанных = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(5);
	ПрочитанныеБайты = Новый Массив(5);
	
	ВГраница = БуферДвоичныхДанных.Размер - 1;
	Для Индекс = 0 По 4 Цикл
		Если Индекс < БуферДвоичныхДанных.Размер Тогда
			ПрочитанныеБайты[Индекс] = БуферДвоичныхДанных[Индекс];
		Иначе // Неинициализированные байты считаем равными 0xA5, чтобы в случае меньшего размера файла не ошибиться в кодировке.
			ПрочитанныеБайты[Индекс] = ЧислоИзШестнадцатеричнойСтроки("0xA5");
		КонецЕсли;
	КонецЦикла;
	
	Если ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xFE")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xFF") Тогда
		КодировкаBOM = "UTF-16BE";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xFF")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xFE") Тогда
		Если ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0x00")
			И ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x00") Тогда
			КодировкаBOM = "UTF-32LE";
		Иначе
			КодировкаBOM = "UTF-16LE";
		КонецЕсли;
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xEF")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xBB")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0xBF") Тогда
		КодировкаBOM = "UTF-8";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0x00")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0x00")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0xFE")
		И ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0xFF") Тогда
		КодировкаBOM = "UTF-32BE";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0x0E")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xFE")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0xFF") Тогда
		КодировкаBOM = "SCSU";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xFB")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xEE")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0x28") Тогда
		КодировкаBOM = "BOCU-1";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0x2B")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0x2F")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0x76")
		И (ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x38")
			Или ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x39")
			Или ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x2B")
			Или ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x2F")) Тогда
		КодировкаBOM = "UTF-7";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xDD")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0x73")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0x66")
		И ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x73") Тогда
		КодировкаBOM = "UTF-EBCDIC";
	Иначе
		КодировкаBOM = "";
	КонецЕсли;
	
	Возврат КодировкаBOM;
КонецФункции

#КонецОбласти

