////////////////////////////////////////////////////////////////////////////////
// Подсистема "Криптография".
//  
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

Функция ЭкспортироватьСертификатВBase64(Сертификат) Экспорт
	
	ДанныеСертификата = КриптографияЭДКО.НайтиСертификат(Сертификат);
	Если Не ЗначениеЗаполнено(ДанныеСертификата) Тогда
		Возврат "";
	КонецЕсли;
	
	ДвоичныеДанныеСертификата = ДанныеСертификата.Сертификат;
	
	Возврат Base64Строка(ДвоичныеДанныеСертификата);
	
КонецФункции

Функция ПроверитьСертификат(Сертификат, ПроверятьСрокДействия = Истина) Экспорт
	
	Возврат СервисКриптографии.ПроверитьСертификат(Сертификат);
		
КонецФункции

Процедура СохранитьНайденныеСертификаты(Сертификаты) Экспорт
	
	СертификатыДляСохранения = ПолучитьСохраненныеСертификаты();
	
	Для Каждого Сертификат Из Сертификаты Цикл
		СертификатыДляСохранения.Вставить(
			"Отпечаток_" + Сертификат.Отпечаток,
			Новый Структура("СерийныйНомер, Поставщик", Сертификат.СерийныйНомер, Сертификат.Поставщик));
	КонецЦикла;	
	
	ХранилищеОбщихНастроек.Сохранить("ДокументооборотСКО/Криптография", "Сертификаты", СертификатыДляСохранения);
	
КонецПроцедуры

Функция ПолучитьСохраненныеСертификаты() Экспорт
	
	Сертификаты =  ХранилищеОбщихНастроек.Загрузить("ДокументооборотСКО/Криптография", "Сертификаты");
	Если Не ЗначениеЗаполнено(Сертификаты) Тогда
		Сертификаты = Новый Структура;
	КонецЕсли;
	
	Возврат Сертификаты;
	
КонецФункции

Функция НайтиСертификатыВЗащищенномХранилищеНаСервере(Сертификаты, ВыполнятьПроверку) Экспорт
	
	НайденныеСертификаты = Новый Массив;
	НенайденныеСертификаты = Новый Массив;
	
	Для Каждого Сертификат Из Сертификаты Цикл
		НайденныйСертификат = КриптографияЭДКО.НайтиСертификат(Сертификат, ВыполнятьПроверку);
		Если НайденныйСертификат = Неопределено Тогда
			НенайденныеСертификаты.Добавить(Сертификат);
		Иначе
			НайденныеСертификаты.Добавить(НайденныйСертификат);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Сертификаты,НенайденныеСертификаты", НайденныеСертификаты, НенайденныеСертификаты);
	
КонецФункции

Функция НайтиОблачныйСертификат(Сертификат) Экспорт
	
	Результат = КриптографияЭДКО.НайтиОблачныйСертификат(Сертификат);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьСертификаты(Знач Хранилище) Экспорт
	
	Если ТипЗнч(Хранилище) <> Тип("Массив") Тогда
		Хранилище = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Хранилище);
	КонецЕсли;
	
	ОбщийСписок = Новый Соответствие;

	Сертификаты = Новый Массив;
	Для Каждого ЗначениеХранилища Из Хранилище Цикл
		ТипХранилища = ПривестиКЕдиномуТипуХранилища(ЗначениеХранилища);
		
		Если ЭлектроннаяПодписьВМоделиСервисаКлиентСервер.ИспользованиеВозможно() Тогда
			МассивСертификатов = ХранилищеСертификатов.Получить(ТипХранилища);
			МестоХраненияКлюча = КриптографияЭДКОКлиентСервер.ОпределитьМестоХраненияКлюча(Перечисления.МодельХраненияЗакрытогоКлюча.ВМоделиСервиса); 
			ДополнитьСертификатыСервера(Сертификаты, МассивСертификатов, ЗначениеХранилища, КриптографияЭДКОКлиентСервер.КонтекстМоделиХраненияКлюча(Истина));
		КонецЕсли;
		
		Если ТипХранилища = Перечисления.ТипХранилищаСертификатов.ПерсональныеСертификаты 
			И КриптографияЭДКО.ИспользованиеОблачнойПодписиВозможно() Тогда
			МодульСервисКриптографииDSS = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSS");
			ВсеСертификаты = МодульСервисКриптографииDSS.ПолучитьВсеСертификатыСервиса(Истина);
			МассивСертификатов = Новый Массив;
			Для Каждого СтрокаТаблицы Из ВсеСертификаты Цикл
				МестоХраненияКлюча = КриптографияЭДКОКлиентСервер.ОпределитьМестоХраненияКлюча(Перечисления.МодельХраненияЗакрытогоКлюча.ОблачнаяПодпись, СтрокаТаблицы.УчетнаяЗапись); 
				НовыйСертификат = МодульСервисКриптографииDSS.ПолучитьОбъектСертификата(СтрокаТаблицы.ДанныеСертификата.Получить());
				НовыйСертификат = ЭлектроннаяПодписьВМоделиСервисаБРОВызовСервера.ПодготовитьСертификатОблачнойПодписи(НовыйСертификат);
				ДополнитьСертификатыСервера(Сертификаты,
					НовыйСертификат,
					ЗначениеХранилища,
					МестоХраненияКлюча);
			КонецЦикла;
		КонецЕсли;
		
		Если ТипХранилища <> Перечисления.ТипХранилищаСертификатов.ПерсональныеСертификаты
			И КриптографияЭДКО.ИспользованиеОблачнойПодписиВозможно() Тогда 
			СертификатыОблака = КриптографияЭДКО.ПолучитьСертификатыПолучателей(ЗначениеХранилища);
			МестоХраненияКлюча = КриптографияЭДКОКлиентСервер.ОпределитьМестоХраненияКлюча(Перечисления.МодельХраненияЗакрытогоКлюча.ОблачнаяПодпись); 
			ДополнитьСертификатыСервера(Сертификаты, СертификатыОблака, ЗначениеХранилища, МестоХраненияКлюча);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ИзвлечьИнформациюОКриптопровайдереПоСертификату(Знач Сертификаты, Знач ПроанализироватьАлгоритм = Ложь) Экспорт
	
	Для Каждого Сертификат Из Сертификаты Цикл
		Сертификат.Вставить("Криптопровайдер", ИзвлечьКриптопровайдер(Сертификат.Сертификат, ПроанализироватьАлгоритм));
		Сертификат.Удалить("Сертификат");
	КонецЦикла;
	
	Возврат Сертификаты;
	
КонецФункции

// Выполняет проверку подписи.
//
// Параметры:
//	Подпись             - ДвоичныеДанные, Строка - подпись, 
//                                которую необходимо проверить, или ее адрес во временном хранилище.
//	ИсходныеДанные      - ДвоичныеДанные, Строка - данные или адрес во временном хранилище.
//	Сертификаты         - Неопределено - извлечь сертификаты из подписи и поместить в параметр,
//                        проверка подписи в этом случае выполняется согласно извлекаемым подписантам.
//                      - Массив - массив двоичных данных сертификатов.
//	Подписанты          - Массив - возвращаемые подписанты при извлечении сертификатов из подписи.
//                        * СерийныйНомер  - Строка - серийный номер сертификата.
//                        * Поставщик      - Строка - издатель сертификата.
//                        * Отпечаток      - Строка - отпечаток сертификата.
//                        * Выполнено      - Булево - если Истина, то проверка подписи была выполнена для подписанта.
//                        * ПодписьВалидна - Булево - результат проверки подписи для подписанта.
//	КомментарийПоОшибке - Строка - может возвращаться причина неудачи проверки подписи.
//
// Возвращаемое значение:
//	Булево - Истина - подпись соответствует владельцам всех сертификатов.
//
Функция ПроверитьПодписьPKCS7(Подпись, ИсходныеДанные, Сертификаты = Неопределено, Подписанты = Неопределено, КомментарийПоОшибке = "") Экспорт
	
	Если ТипЗнч(Подпись) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанныеПодписи = Подпись;
	Иначе
		ДвоичныеДанныеПодписи = ПолучитьИзВременногоХранилища(Подпись);
	КонецЕсли;
	
	Если ТипЗнч(ИсходныеДанные) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанныеИсходныхДанных = ИсходныеДанные;
	Иначе
		ДвоичныеДанныеИсходныхДанных = ПолучитьИзВременногоХранилища(ИсходныеДанные);
	КонецЕсли;
	
	Если Сертификаты = Неопределено Тогда
		СвойстваКриптосообщения = СервисКриптографии.ПолучитьСвойстваКриптосообщения(ДвоичныеДанныеПодписи);
		
		Сертификаты = ?(СвойстваКриптосообщения.Свойство("Сертификаты"), СвойстваКриптосообщения.Сертификаты, Новый Массив);
		СвойстваСертификатов = Новый Массив;
		Для каждого Сертификат Из Сертификаты Цикл
			СвойстваСертификата = СервисКриптографии.ПолучитьСвойстваСертификата(Сертификат);
			СвойстваСертификатов.Добавить(СвойстваСертификата);
		КонецЦикла;
		
		Подписанты = ?(СвойстваКриптосообщения.Свойство("Подписанты"),
			ОбщегоНазначения.СкопироватьРекурсивно(СвойстваКриптосообщения.Подписанты, Ложь), Новый Массив);
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			Подписанты[ИндексПодписанта] = ОбщегоНазначения.СкопироватьРекурсивно(Подписанты[ИндексПодписанта], Ложь);
			Подписанты[ИндексПодписанта].Вставить("Отпечаток", "");
			Подписанты[ИндексПодписанта].Вставить("Выполнено", Ложь);
			Подписанты[ИндексПодписанта].Вставить("ПодписьВалидна", Ложь);
			Подписанты[ИндексПодписанта].Вставить("Сертификат", Неопределено);
			ИздательСтрокой = ПреобразоватьВСтроку(Подписанты[ИндексПодписанта].Издатель);
			Подписанты[ИндексПодписанта].Вставить("Поставщик", ИздательСтрокой); // для совместимости
			
			Для ИндексСертификата = 0 По Сертификаты.Количество() - 1 Цикл
				Если СвойстваСертификатов[ИндексСертификата] <> Неопределено
					И СокрЛП(Подписанты[ИндексПодписанта].СерийныйНомер) = СокрЛП(СвойстваСертификатов[ИндексСертификата].СерийныйНомер)
					И ИздателиИлиСубъектыОдинаковые(Подписанты[ИндексПодписанта].Издатель,
					СвойстваСертификатов[ИндексСертификата].Издатель) Тогда
					
					Подписанты[ИндексПодписанта].Отпечаток = СтрЗаменить(СвойстваСертификатов[ИндексСертификата].Отпечаток, " ", "");
					Подписанты[ИндексПодписанта].Отпечаток = нрег(Подписанты[ИндексПодписанта].Отпечаток);
					Подписанты[ИндексПодписанта].Сертификат = Сертификаты[ИндексСертификата];
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		// дополнительный поиск на случай отличий написания издателя
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			Если НЕ ЗначениеЗаполнено(Подписанты[ИндексПодписанта].Отпечаток) Тогда
				Для ИндексСертификата = 0 По Сертификаты.Количество() - 1 Цикл
					Если СокрЛП(Подписанты[ИндексПодписанта].СерийныйНомер) = СокрЛП(СвойстваСертификатов[ИндексСертификата].СерийныйНомер) Тогда
						Подписанты[ИндексПодписанта].Издатель = СвойстваСертификатов[ИндексСертификата].Издатель;
						Подписанты[ИндексПодписанта].Поставщик = ПреобразоватьВСтроку(Подписанты[ИндексПодписанта].Издатель);
						Подписанты[ИндексПодписанта].Отпечаток = СтрЗаменить(СвойстваСертификатов[ИндексСертификата].Отпечаток, " ", "");
						Подписанты[ИндексПодписанта].Отпечаток = нрег(Подписанты[ИндексПодписанта].Отпечаток);
						Подписанты[ИндексПодписанта].Сертификат = Сертификаты[ИндексСертификата];
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		ПодписантыДляПоискаВХранилище = Новый Массив;
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			ПодписантыДляПоискаВХранилище.Добавить(Подписанты[ИндексПодписанта]);
		КонецЦикла;
		
		Если ПодписантыДляПоискаВХранилище.Количество() > 0 Тогда
			РезультатыПоиска = НайтиСертификатыВЗащищенномХранилищеНаСервере(ПодписантыДляПоискаВХранилище, Ложь);
			
			Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
				Если НЕ ЗначениеЗаполнено(Подписанты[ИндексПодписанта].Отпечаток) Тогда
					Для каждого НайденныйСертификат Из РезультатыПоиска.Сертификаты Цикл
						Если СокрЛП(Подписанты[ИндексПодписанта].СерийныйНомер) = СокрЛП(НайденныйСертификат.СерийныйНомер)
							И ИздателиИлиСубъектыОдинаковые(Подписанты[ИндексПодписанта].Издатель, НайденныйСертификат.Издатель) Тогда
							
							Подписанты[ИндексПодписанта].Отпечаток = СокрЛП(НайденныйСертификат.Отпечаток);
							Подписанты[ИндексПодписанта].Сертификат = НайденныйСертификат.Сертификат;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
			
			Для каждого НенайденныйСертификат Из РезультатыПоиска.НенайденныеСертификаты Цикл
				Если ЗначениеЗаполнено(НенайденныйСертификат.Отпечаток) И ЗначениеЗаполнено(НенайденныйСертификат.Сертификат)
					И ПравоДоступа("Изменение", Метаданные.РегистрыСведений.ХранилищеСертификатов) Тогда
					
					ХранилищеСертификатов.Добавить(НенайденныйСертификат.Сертификат, Перечисления.ТипХранилищаСертификатов.СертификатыПолучателей);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			Если НЕ ЗначениеЗаполнено(Подписанты[ИндексПодписанта].Отпечаток) Тогда
				ТекстСообщения = НСтр("ru = 'При проверке подписи не найден сертификат поставщика ""%1"" с серийным номером ""%2"".';
										|en = 'При проверке подписи не найден сертификат поставщика ""%1"" с серийным номером ""%2"".'");
				КомментарийПоОшибке = СтрШаблон(
					ТекстСообщения,
					Подписанты[ИндексПодписанта].Поставщик,
					Подписанты[ИндексПодписанта].СерийныйНомер);
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		Подписанты = Новый Массив;
		Для ИндексСертификата = 0 По Сертификаты.Количество() - 1 Цикл
			ПодписантПоСертификату = Новый Структура;
			ПодписантПоСертификату.Вставить("Выполнено", Ложь);
			ПодписантПоСертификату.Вставить("ПодписьВалидна", Ложь);
			ПодписантПоСертификату.Вставить("Сертификат", Сертификаты[ИндексСертификата]);
			Подписанты.Добавить(ПодписантПоСертификату);
		КонецЦикла;
	КонецЕсли;
	
	Если Подписанты.Количество() = 0 Тогда
		КомментарийПоОшибке = НСтр("ru = 'Отсутствует информация о подписантах, проверка подписи невозможна.';
									|en = 'Отсутствует информация о подписантах, проверка подписи невозможна.'");
		Возврат Ложь;
	КонецЕсли;
	
	ПодписьВалидна = Истина;
	Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
		ПараметрыПодписания = Новый Структура("ОтсоединеннаяПодпись, Сертификат", Истина, Подписанты[ИндексПодписанта].Сертификат);
		Подписанты[ИндексПодписанта].ПодписьВалидна =
			СервисКриптографии.ПроверитьПодпись(ДвоичныеДанныеПодписи, ДвоичныеДанныеИсходныхДанных, "CMS", ПараметрыПодписания);
		
		Если Подписанты[ИндексПодписанта].ПодписьВалидна
			И Подписанты[ИндексПодписанта].Свойство("СерийныйНомер")
			И Подписанты[ИндексПодписанта].Свойство("Поставщик")
			И НЕ ПроверитьСертификат(Подписанты[ИндексПодписанта].Сертификат, Ложь) Тогда
			
			КомментарийПоОшибке = СтрШаблон(
				НСтр("ru = 'Невалидный сертификат поставщика ""%1"" с серийным номером ""%2"" при проверке подписи.';
					|en = 'Невалидный сертификат поставщика ""%1"" с серийным номером ""%2"" при проверке подписи.'"),
				Подписанты[ИндексПодписанта].Поставщик,
				Подписанты[ИндексПодписанта].СерийныйНомер);
			Возврат Ложь;
		КонецЕсли;
		
		Подписанты[ИндексПодписанта].Выполнено = Истина;
		Если НЕ Подписанты[ИндексПодписанта].ПодписьВалидна Тогда
			ПодписьВалидна = Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПодписьВалидна;
	
КонецФункции

Функция ИзвлечьИнформациюОПодписантахИзJSON(ПодписантыJSON) Экспорт
	
	ЧтениеПодписантовJSON = Новый ЧтениеJSON;
	ЧтениеПодписантовJSON.УстановитьСтроку(ПодписантыJSON);
	
	Подписанты = ПрочитатьJSON(ЧтениеПодписантовJSON);
	Если Подписанты <> Неопределено Тогда
		Если ТипЗнч(Подписанты) = Тип("Структура") Тогда
			Подписанты = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Подписанты); // создаем массив, помещаем туда подписанта
		КонецЕсли;
		
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			Подписанты[ИндексПодписанта] = Новый ФиксированнаяСтруктура("СерийныйНомер, Поставщик",
				Подписанты[ИндексПодписанта].serial_number, Подписанты[ИндексПодписанта].issuer);
		КонецЦикла;
		Подписанты = Новый ФиксированныйМассив(Подписанты);
	КонецЕсли;
	
	Возврат Подписанты;
	
КонецФункции

Функция ПреобразоватьВСтроку(Издатель) Экспорт
	
	СтрокаИздателя = "";
	
	Для Каждого Тег Из Издатель Цикл 
		СтрокаИздателя = СтрокаИздателя + ?(СтрокаИздателя = "", "", ",") + Тег.Ключ + "=" + Тег.Значение;
	КонецЦикла;
	
	Возврат СтрокаИздателя;
	
КонецФункции

Функция ИдентификаторСертификата(Знач Сертификат) Экспорт
	
	Если ТипЗнч(Сертификат) = Тип("СертификатКриптографии") ИЛИ Сертификат.Свойство("СерийныйНомер") Тогда
		СерийныйНомер = Сертификат.СерийныйНомер;
		Издатель = Сертификат.Издатель;
	Иначе
		СертификатКриптографии = Новый СертификатКриптографии(Сертификат.Сертификат);
		СерийныйНомер = СертификатКриптографии.СерийныйНомер;
		Издатель = СертификатКриптографии.Издатель;
	КонецЕсли;		
	
	СписокOID = Новый СписокЗначений;
	Для Каждого OID Из Издатель Цикл
		Если Не СтрНачинаетсяС(OID.Ключ, "OID") Тогда
			Продолжить;
		КонецЕсли;
		СписокOID.Добавить(OID.Значение, СтрЗаменить(Сред(OID.Ключ, 4), "_", "."));
	КонецЦикла;
	
	Ключи = СтрРазделить("2.5.4.3,2.5.4.4,2.5.4.6,2.5.4.7,2.5.4.8,2.5.4.10,2.5.4.11,2.5.4.12,2.5.4.42,1.2.840.113549.1.9.1", ",");
	Свойства = Новый СписокЗначений;
	Для Каждого Элемент Из СписокOID Цикл
		Если Ключи.Найти(Элемент.Представление) <> Неопределено Тогда
			Свойства.Добавить(Элемент.Значение, Элемент.Представление);
		КонецЕсли;
	КонецЦикла;
	
	СерийныйНомерСтрока = НРег(СтрЗаменить(СерийныйНомер, " ", ""));
	
	Свойства.СортироватьПоПредставлению(НаправлениеСортировки.Возр);
	
	МассивЗначений = Свойства.ВыгрузитьЗначения();
	
	МассивЗначений.Добавить(СерийныйНомерСтрока);
	
	ИздательИСерийныйНомер = СтрСоединить(МассивЗначений, "#");
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA1);
	Хеширование.Добавить(ИздательИСерийныйНомер);
	
	Возврат НРег(СтрЗаменить(Хеширование.ХешСумма, " ", ""));	
	
КонецФункции

// Возвращает свойства криптосообщения в формате PKCS #7 в соответствии с https://tools.ietf.org/html/rfc2315.
//
// Параметры:
//   Криптосообщение - ДвоичныеДанные, Строка - файл (двоичные данные, адрес во временном хранилище или строка Base64
//                                              при Настройки.ЭтоСтрокаBase64 = Истина) в формате PKCS #7.
//   Настройки - Неопределено - настройки по умолчанию.
//             - Структура:
//     ПрочитатьПодписанныеДанные          - Булево - по умолчанию Истина, для типа SignedData возвращать Содержимое.
//     ПрочитатьПодпись                    - Булево - по умолчанию Ложь, для типа SignedData возвращать Подпись.
//     ПрочитатьИздателяИСерийныйНомер     - Булево - по умолчанию Истина, для типа SignedData в Подписанты возвращать
//                                                    Идентификатор, Издатель, СерийныйНомер, Сертификат,
//                                                    для типа EnvelopedData в Получатели возвращать Идентификатор,
//                                                    Издатель, СерийныйНомер.
//     ПрочитатьАлгоритмПубличногоКлюча    - Булево - по умолчанию Ложь, для типа EnvelopedData в Получатели возвращать
//                                                    АлгоритмПубличногоКлюча.
//     ПрочитатьСтруктуру                  - Булево - по умолчанию Ложь, для типа SignedData прочитать структуру
//                                                    для пересборки функцией "СформироватьКриптосообщение".
//     МестоХраненияКлюча 				   - Булево, Структура - по умолчанию Истина, влияет на имя события при записи
//                                                               в журнал регистрации.
//     ЭтоСтрокаBase64                     - Булево - по умолчанию Ложь, при Истина Криптосообщение задает
//                                                    строку Base64.
//     ВозвращатьИсключения                - Булево - по умолчанию Истина, генерировать исключения при неверной
//                                                    структуре данных.
//
// Возвращаемое значение:
//   Структура - свойства криптосообщения.
//    Общие свойства:
//    * Тип - Строка - Unknown - файл неподдерживаемого формат, EnvelopedData - зашифрованные данные,
//                               SignedData - подпись.
//    * Размер - Число - размер файла в байтах.
//    
//    Свойства для типа SignedData:
//    * Подписанты - Массив - подписанты сообщения.
//       ** Идентификатор - Строка - идентификатор сертификата
//       ** Издатель - Структура - издатель сертификата
//           *** OID<X1>_<X2>_..._<XN>, где X<i> - это компонента идентификатора OID
//       ** СерийныйНомер - ДвоичныеДанные - серийный номер сертификата
//       ** Сертификат - ДвоичныеДанные - файл сертификата
//       ** АлгоритмХеширования - Строка - название алгоритма или OID нераспознанного алгоритма
//       ** АлгоритмПодписи - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                     или OID нераспознанного алгоритма
//       ** Подпись - ДвоичныеДанные - содержимое подписи, возвращается при "ПрочитатьПодпись" равном Истина
//                                     в параметре "Настройки"
//       ** Подписанты - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина в параметре "Настройки"
//       ** СвойстваБлокаПолейПодписанта - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                          в параметре "Настройки"
//       ** БлокВерсии - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина в параметре "Настройки"
//       ** БлокИздателяИСерийногоНомера - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                          в параметре "Настройки"
//       ** БлокАлгоритмаХеширования - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                      в параметре "Настройки"
//       ** БлокАутентифицированныхАтрибутов - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                              в параметре "Настройки"
//       ** БлокАлгоритмаПодписи - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                  в параметре "Настройки"
//       ** БлокПодписи - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина в параметре "Настройки"
//       ** БлокНеаутентифицированныхАтрибутов - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                                в параметре "Настройки".
//    * Сертификаты - Массив - файлы сертификатов.
//    * СпискиОтзываСертификатов - Массив - файлы списков отзыва сертификатов.
//    * Содержимое - ДвоичныеДанные - подписанные данные для прикрепленной подписи.
//    * СвойстваОсновногоБлока - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                в параметре "Настройки".
//    * БлокТипаСодержимого - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                             в параметре "Настройки".
//    * СвойстваБлокаПодписанныхДанных - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                        в параметре "Настройки".
//    * СвойстваБлокаПолейПодписанныхДанных - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                            в параметре "Настройки".
//    * БлокВерсии - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина в параметре "Настройки".
//    * БлокАлгоритмовХеширования - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                   в параметре "Настройки".
//    * БлокСодержимого - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина в параметре "Настройки".
//    * БлокСертификатов - ДвоичныеДанные - присутствие необязтельное, возвращается при "ПрочитатьСтруктуру" равном Истина
//                                          в параметре "Настройки".
//    * БлокСписковОтзывовСертификатов - ДвоичныеДанные - присутствие необязтельное, возвращается
//                                                        при "ПрочитатьСтруктуру" равном Истина в параметре "Настройки".
//    * СвойстваБлокаПодписантов - ДвоичныеДанные - возвращается при "ПрочитатьСтруктуру" равном Истина
//                                                  в параметре "Настройки".
//
//    Свойства для типа EnvelopedData:
//    * Получатели - Массив - получатели зашифрованного сообщения.
//       ** Идентификатор - Строка - идентификатор сертификата
//       ** Издатель - Структура - издатель сертификата
//           *** OID<X1>_<X2>_..._<XN>, где X<i> - это компонента идентификатора OID
//       ** СерийныйНомер - ДвоичныеДанные - серийный номер сертификата
//       ** АлгоритмПубличногоКлюча - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                             или OID нераспознанного алгоритма, возвращается при задании
//                                             Настройки.ПрочитатьАлгоритмПубличногоКлюча = Истина.
//
Функция ПолучитьСвойстваКриптосообщения(Знач Криптосообщение, Настройки = Неопределено) Экспорт
	
	НастройкиВызова = Новый Структура;
	КриптографияЭДКОКлиентСервер.КонтекстМоделиХраненияКлюча(Истина, НастройкиВызова);
	НастройкиВызова.Вставить("ПрочитатьПодписанныеДанные", 			Истина);
	НастройкиВызова.Вставить("ПрочитатьПодпись", 					Ложь);
	НастройкиВызова.Вставить("ПрочитатьИздателяИСерийныйНомер", 	Истина);
	НастройкиВызова.Вставить("ПрочитатьАлгоритмПубличногоКлюча", 	Ложь);
	НастройкиВызова.Вставить("ПрочитатьСтруктуру", 					Ложь);
	НастройкиВызова.Вставить("ЭтоСтрокаBase64", 					Ложь);
	НастройкиВызова.Вставить("ВозвращатьИсключения", 				Истина);
	Если Настройки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиВызова, Настройки);
	КонецЕсли;
	
	СвойстваКриптосообщения = Новый Структура;
	СвойстваКриптосообщения.Вставить("Тип", "Unknown");
	
	Если НастройкиВызова.ЭтоСтрокаBase64 Тогда
		Криптосообщение = Base64Значение(Криптосообщение);
	ИначеЕсли ТипЗнч(Криптосообщение) = Тип("Строка") И ЭтоАдресВременногоХранилища(Криптосообщение) Тогда
		Криптосообщение = ПолучитьИзВременногоХранилища(Криптосообщение);
	КонецЕсли;
	СвойстваКриптосообщения.Вставить("Размер", Криптосообщение.Размер());
	
	Если Не ЗначениеЗаполнено(СвойстваКриптосообщения.Размер) Тогда
		Возврат СвойстваКриптосообщения;
	КонецЕсли;
	
	ЧтениеДанных = Новый ЧтениеДанных(Криптосообщение);
	Попытка
		ЗаписьДанных = Неопределено;
		Если НастройкиВызова.ПрочитатьСтруктуру Тогда
			ПотокДанных = Новый ПотокВПамяти();
			ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
		КонецЕсли;
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		Если НастройкиВызова.ПрочитатьСтруктуру Тогда
			ЗаписьДанных.Закрыть();
			ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
			СвойстваКриптосообщения.Вставить("СвойстваОсновногоБлока", ПрочитанныеДанные);
			ПотокДанных = Новый ПотокВПамяти();
			ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
		КонецЕсли;
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных); // contentType
		Если Свойства.РазмерБлока > 100 ИЛИ Свойства.РазмерБлока = 0 Тогда // Защита от считывания лишних данных
			ЧтениеДанных.Закрыть();
			Возврат СвойстваКриптосообщения;
		КонецЕсли;
		
		Тип = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства, ЗаписьДанных);
		Если НастройкиВызова.ПрочитатьСтруктуру Тогда
			ЗаписьДанных.Закрыть();
			ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
			СвойстваКриптосообщения.Вставить("БлокТипаСодержимого", ПрочитанныеДанные);
		КонецЕсли;
		
		// PKCS #7: EnvelopedData https://tools.ietf.org/html/rfc2315#section-10.1
		Если Тип = "1.2.840.113549.1.7.3" Тогда
			СвойстваКриптосообщения = ПрочитатьEnvelopedData(ЧтениеДанных, СвойстваКриптосообщения, НастройкиВызова);
			
		// PKCS #7: SignedData https://tools.ietf.org/html/rfc2315#section-9.1
		ИначеЕсли Тип = "1.2.840.113549.1.7.2" Тогда
			СвойстваКриптосообщения = ПрочитатьSignedData(ЧтениеДанных, СвойстваКриптосообщения, НастройкиВызова);
		КонецЕсли;
	Исключение
		ИмяСобытия = ?(КриптографияЭДКОКлиентСервер.ЭтоПодписьСервиса(НастройкиВызова.МестоХраненияКлюча),
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение PKCS7';
				|en = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение PKCS7'", ОбщегоНазначения.КодОсновногоЯзыка()),
			НСтр("ru = 'Сервис криптографии.Чтение PKCS7';
				|en = 'Сервис криптографии.Чтение PKCS7'", ОбщегоНазначения.КодОсновногоЯзыка()));
		ЗаписьЖурналаРегистрации(
			ИмяСобытия,
			УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если НастройкиВызова.ВозвращатьИсключения Тогда
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ЧтениеДанных.Закрыть();
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

// Возвращает отдельные свойства сертификата в формате X.509 в соответствие с https://tools.ietf.org/html/rfc5280.
//
// Параметры:
//   ДанныеСертификата - ДвоичныеДанные, Строка - файл (двоичные данные, адрес во временном хранилище или строка Base64
//                                                при Настройки.ЭтоСтрокаBase64 = Истина) в формате X.509.
//   Настройки - Неопределено - настройки по умолчанию.
//             - Структура:
//     МестоХраненияКлюча                  - Булево, Структура - по умолчанию Истина, влияет на имя события при записи в журнал регистрации.
//     ЭтоСтрокаBase64                     - Булево - по умолчанию Ложь, при Истина ДанныеСертификата задает строку Base64.
//     ВозможенФорматBase64                - Булево - по умолчанию Ложь, при Истина двоичные данные в ДанныеСертификата
//                                                    могут быть в формате Base64, в том числе с заголовками сертификата,
//                                                    корректность чтения определяется по прочитанному алгоритму
//     ПрочитатьПоляПоставщика             - Булево - по умолчанию Ложь,
//     ВозвращатьИсключения                - Булево - по умолчанию Истина, генерировать исключения при неверной структуре данных.
//
// Возвращаемое значение:
//   Структура - свойства криптосообщения.
//     Размер                       - Число          - размер файла в байтах.
//     Версия                       - Число          - версия формата сертификата, 0 - v1, 1 - v2, 2 - v3.
//     СерийныйНомер                - ДвоичныеДанные - серийный номер сертификата.
//     АлгоритмПубличногоКлюча      - Строка         - "GOST R 34.10-2001", "GOST R 34.10-2012-256",
//                                                     "GOST R 34.10-2012-512" или OID нераспознанного алгоритма.
//     ИдентификаторКлючаСубъекта   - Строка или Неопределено - хеш SHA-1 публичного ключа.
//     ИдентификаторКлючаУЦ         - Строка или Неопределено - хеш SHA-1 публичного ключа удостоверяющего центра.
//     ТипКриптопровайдераВладельца - Перечисления.ТипыКриптоПровайдеров или Неопределено - определяет
//                                                     Перечисления.ТипыКриптоПровайдеров.CryptoPro и
//                                                     Перечисления.ТипыКриптоПровайдеров.VipNet.
//     ТипИдентификации             - Число или Неопределено
//                                         - 1 - Без личного присутствия        
//                                         - 0 - При личном присутствии
//                                         - Неопределено - Не удалось определить
//     СерийныйНомерСертификатаУЦ   - ДвоичныеДанные или Неопределено - серийный номер сертификата УЦ.
//     ПоляПоставщика               - Массив структур - заполняется при Настройки.ПрочитатьПоляПоставщика = Истина:
//       ИдентификаторПоля            - Строка - OID.
//       ДанныеПоля                   - ДвоичныеДанные - значение ASN поля.
//     КлючДействителенС            - Дата или Неопределено - дата приведена к местному времени на сервере
//     КлючДействителенПо           - Дата или Неопределено - дата приведена к местному времени на сервере
//
Функция ПолучитьСвойстваСертификата(Знач ДанныеСертификата, Настройки = Неопределено) Экспорт
	
	Типы = Типы();
	
	НастройкиВызова = ШаблонНастроек();
	КриптографияЭДКОКлиентСервер.КонтекстМоделиХраненияКлюча(Истина, НастройкиВызова);
	Если Настройки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиВызова, Настройки);
	КонецЕсли;
	
	СвойстваСертификата = ШаблонРезультата();
	ДвДанные = ДвДанныеСертификата(ДанныеСертификата, НастройкиВызова);
	
	СвойстваСертификата.Размер = ДвДанные.Размер();
	
	Если НастройкиВызова.ВозможенФорматBase64 И СвойстваСертификата.Размер < 65536 Тогда
		ПолучитьСвойстваСертификатаЕслиВозможенФорматBase64(ДвДанные, НастройкиВызова, СвойстваСертификата);
		Возврат СвойстваСертификата;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СвойстваСертификата.Размер) Тогда
		Возврат СвойстваСертификата;
	КонецЕсли;
	
	ОбъектЧтениеДанных = Новый ЧтениеДанных(ДвДанные);
	Попытка
		// https://tools.ietf.org/html/rfc5280#section-4
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда // Certificate ::= SEQUENCE...
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда // TBSCertificate ::= SEQUENCE...
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> Типы.INTEGER Тогда
			Если СвойстваБлока.Класс <> "CONTEXT-SPECIFIC" ИЛИ СвойстваБлока.Тег <> 0 Тогда // version [0] EXPLICIT Version DEFAULT v1
				ОбъектЧтениеДанных.Закрыть();
				Возврат СвойстваСертификата;
			КонецЕсли;
			
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		КонецЕсли;
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> Типы.INTEGER Тогда // Version ::= INTEGER {v1(0), v2(1), v3(2)}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		ВерсияСертификата = ПрочитатьЦелоеЧисло(ОбъектЧтениеДанных, СвойстваБлока);
		Если ВерсияСертификата < 0 ИЛИ ВерсияСертификата > 2 Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		СвойстваСертификата.Версия = ВерсияСертификата;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		СвойстваСертификата.СерийныйНомер = ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных,
			СвойстваБлока); // serialNumber CertificateSerialNumber ::= INTEGER
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда // signature AlgorithmIdentifier = SEQUENCE {...}
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда // issuer RDNSequence ::= SEQUENCE {...}
			Возврат СвойстваСертификата;
		КонецЕсли;
		Если НастройкиВызова.ПрочитатьПоляПоставщика Тогда
			КонецБлока = СвойстваБлока.РазмерБлока + ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
			СвойстваСертификата.ПоляПоставщика = ПрочитатьПоляRDN(ОбъектЧтениеДанных, СвойстваСертификата, КонецБлока);
		Иначе
			ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда // validity Validity ::= SEQUENCE {...}
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда // subject RDNSequence ::= SEQUENCE {...}
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда // subjectPublicKeyInfo SubjectPublicKeyInfo ::= SEQUENCE...
			Возврат СвойстваСертификата;
		КонецЕсли;
		КонецБлока = СвойстваБлока.РазмерБлока + ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда // algorithm AlgorithmIdentifier = SEQUENCE...
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		АлгоритмПубличногоКлюча = ПрочитатьAlgorithmIdentifier(ОбъектЧтениеДанных, СвойстваСертификата, СвойстваБлока, Истина);
		Если АлгоритмПубличногоКлюча = Неопределено Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		СвойстваСертификата.АлгоритмПубличногоКлюча = АлгоритмПубличногоКлюча;
		ПропуститьБлок(ОбъектЧтениеДанных, КонецБлока - ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = Типы.BOOLEAN Тогда
			// issuerUniqueID IMPLICIT UniqueIdentifier OPTIONAL
			ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		КонецЕсли;
		
		Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = Типы.INTEGER Тогда
			// subjectUniqueID IMPLICIT UniqueIdentifier OPTIONAL
			ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		КонецЕсли;
		
		Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = Типы.BIT_STRING Тогда
			// extensions EXPLICIT Extensions OPTIONAL
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
			Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда
				Возврат СвойстваСертификата;
			КонецЕсли;
			
			ТипКриптопровайдераВладельцаНайден 	= Ложь;
			ИдентификаторКлючаУЦНайден 			= Ложь;
			ИдентификаторКлючаСубъектаНайден 	= Ложь;
			ТипИдентификацииНайден 				= Ложь;
			СерийныйНомерСертификатаУЦНайден 	= Ложь;
			СрокДействияКлючаНайден 			= Ложь;
			
			Пока Истина Цикл
				СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
				Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных) Тогда
					Возврат СвойстваСертификата;
				КонецЕсли;
				
				КонецБлока = СвойстваБлока.РазмерБлока + ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
				
				СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
				Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> Типы.OBJECT_IDENTIFIER Тогда // algorithm OBJECT IDENTIFIER
					ОбъектЧтениеДанных.Закрыть();
					Возврат СвойстваСертификата;
				КонецЕсли;
				ИдентификаторРасширения = ПрочитатьОбъектныйИдентификатор(ОбъектЧтениеДанных, СвойстваБлока);
				Если ИдентификаторРасширения = "1.2.643.100.111" Тогда
					
					Успешно = ПрочитатьOID1_2_643_100_111(ОбъектЧтениеДанных, СвойстваСертификата);
					Если Успешно Тогда
						ТипКриптопровайдераВладельцаНайден = Истина;
					Иначе
						Возврат СвойстваСертификата;
					КонецЕсли;
					
				ИначеЕсли ИдентификаторРасширения = "1.2.643.100.114" Тогда
					
					Успешно = ПрочитатьOID1_2_643_100_114(ОбъектЧтениеДанных, СвойстваСертификата);
					Если Успешно Тогда
						ТипИдентификацииНайден = Истина;
					Иначе
						Возврат СвойстваСертификата;
					КонецЕсли;
					
				ИначеЕсли ИдентификаторРасширения = "2.5.29.35" Тогда
					
					Успешно = ПрочитатьOID2_5_29_35(ОбъектЧтениеДанных, СвойстваСертификата);
					Если Успешно Тогда
						ИдентификаторКлючаУЦНайден = Истина;
						СерийныйНомерСертификатаУЦНайден = Истина;
					Иначе
						Возврат СвойстваСертификата;
					КонецЕсли;
					
				ИначеЕсли ИдентификаторРасширения = "2.5.29.14" Тогда
					Успешно = ПрочитатьOID2_5_29_14(ОбъектЧтениеДанных, СвойстваСертификата);
					Если Успешно Тогда
						ИдентификаторКлючаСубъектаНайден = Истина;
					Иначе
						Возврат СвойстваСертификата;
					КонецЕсли;
					
				ИначеЕсли ИдентификаторРасширения = "2.5.29.16" Тогда
					Успешно = ПрочитатьOID2_5_29_16(ОбъектЧтениеДанных, СвойстваСертификата);
					Если Успешно Тогда
						СрокДействияКлючаНайден = Истина;
					Иначе
						Возврат СвойстваСертификата;
					КонецЕсли;
				КонецЕсли;
				
				ВсеНайдено = ТипКриптопровайдераВладельцаНайден 
					И ИдентификаторКлючаУЦНайден 
					И ИдентификаторКлючаСубъектаНайден
					И ТипИдентификацииНайден
					И СерийныйНомерСертификатаУЦНайден
					И СрокДействияКлючаНайден;
					
				Если ВсеНайдено Тогда
					ОбъектЧтениеДанных.Закрыть();
					Возврат СвойстваСертификата;
				КонецЕсли;
				ПропуститьБлок(ОбъектЧтениеДанных, КонецБлока - ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
				
			КонецЦикла;
		КонецЕсли;
	Исключение
		ИмяСобытия = ?(КриптографияЭДКОКлиентСервер.ЭтоПодписьСервиса(НастройкиВызова.МестоХраненияКлюча),
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата';
				|en = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()),
			НСтр("ru = 'Сервис криптографии.Чтение сертификата';
				|en = 'Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()));
		ЗаписьЖурналаРегистрации(
			ИмяСобытия,
			УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если НастройкиВызова.ВозвращатьИсключения Тогда
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ОбъектЧтениеДанных.Закрыть();
	
	Возврат СвойстваСертификата;
	
КонецФункции

Функция СформироватьКриптосообщение(СвойстваКриптосообщения, БлокиНеаутентифицированныхАтрибутов = Неопределено)
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	ИндексПодписанта = 0;
	Для каждого Подписант Из СвойстваКриптосообщения.Подписанты Цикл
		БлокНеаутентифицированныхАтрибутов = Подписант.БлокНеаутентифицированныхАтрибутов;
		Если ТипЗнч(БлокиНеаутентифицированныхАтрибутов) = Тип("Массив")
			ИЛИ ТипЗнч(БлокиНеаутентифицированныхАтрибутов) = Тип("ФиксированныйМассив") Тогда
			
			Если ИндексПодписанта < БлокиНеаутентифицированныхАтрибутов.Количество() Тогда
				БлокНеаутентифицированныхАтрибутов = БлокиНеаутентифицированныхАтрибутов[ИндексПодписанта];
			КонецЕсли;
			
		ИначеЕсли БлокиНеаутентифицированныхАтрибутов <> Неопределено Тогда
			БлокНеаутентифицированныхАтрибутов = БлокиНеаутентифицированныхАтрибутов;
		КонецЕсли;
		
		РазмерДанных = Подписант.БлокВерсии.Размер()
			+ Подписант.БлокИздателяИСерийногоНомера.Размер()
			+ Подписант.БлокАлгоритмаХеширования.Размер()
			+ Подписант.БлокАутентифицированныхАтрибутов.Размер()
			+ Подписант.БлокАлгоритмаПодписи.Размер()
			+ Подписант.БлокПодписи.Размер()
			+ БлокНеаутентифицированныхАтрибутов.Размер();
		ЗаписатьСвойстваБлока(ЗаписьДанных, Подписант.СвойстваБлокаПолейПодписанта, РазмерДанных);
		
		ЗаписьДанных.Записать(Подписант.БлокВерсии);
		ЗаписьДанных.Записать(Подписант.БлокИздателяИСерийногоНомера);
		ЗаписьДанных.Записать(Подписант.БлокАлгоритмаХеширования);
		ЗаписьДанных.Записать(Подписант.БлокАутентифицированныхАтрибутов);
		ЗаписьДанных.Записать(Подписант.БлокАлгоритмаПодписи);
		ЗаписьДанных.Записать(Подписант.БлокПодписи);
		ЗаписьДанных.Записать(БлокНеаутентифицированныхАтрибутов);
		
		ИндексПодписанта = ИндексПодписанта + 0;
	КонецЦикла;
	ЗаписьДанных.Закрыть();
	БлокПолейПодписантов = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	РазмерДанных = БлокПолейПодписантов.Размер();
	ЗаписатьСвойстваБлока(ЗаписьДанных, СвойстваКриптосообщения.СвойстваБлокаПодписантов, РазмерДанных);
	ЗаписьДанных.Записать(БлокПолейПодписантов);
	ЗаписьДанных.Закрыть();
	БлокПодписантов = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	РазмерДанных = СвойстваКриптосообщения.БлокВерсии.Размер()
		+ СвойстваКриптосообщения.БлокАлгоритмовХеширования.Размер()
		+ СвойстваКриптосообщения.БлокСодержимого.Размер()
		+ ?(СвойстваКриптосообщения.Свойство("БлокСертификатов"), СвойстваКриптосообщения.БлокСертификатов.Размер(), 0)
		+ ?(СвойстваКриптосообщения.Свойство("БлокСписковОтзывовСертификатов"),
		СвойстваКриптосообщения.БлокСписковОтзывовСертификатов.Размер(), 0)
		+ БлокПодписантов.Размер();
	ЗаписатьСвойстваБлока(ЗаписьДанных, СвойстваКриптосообщения.СвойстваБлокаПолейПодписанныхДанных, РазмерДанных);
	
	ЗаписьДанных.Записать(СвойстваКриптосообщения.БлокВерсии);
	ЗаписьДанных.Записать(СвойстваКриптосообщения.БлокАлгоритмовХеширования);
	ЗаписьДанных.Записать(СвойстваКриптосообщения.БлокСодержимого);
	Если СвойстваКриптосообщения.Свойство("БлокСертификатов") Тогда
		ЗаписьДанных.Записать(СвойстваКриптосообщения.БлокСертификатов);
	КонецЕсли;
	Если СвойстваКриптосообщения.Свойство("БлокСписковОтзывовСертификатов") Тогда
		ЗаписьДанных.Записать(СвойстваКриптосообщения.БлокСписковОтзывовСертификатов);
	КонецЕсли;
	ЗаписьДанных.Записать(БлокПодписантов);
	ЗаписьДанных.Закрыть();
	БлокПолейПодписанныхДанных = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	РазмерДанных = БлокПолейПодписанныхДанных.Размер();
	ЗаписатьСвойстваБлока(ЗаписьДанных, СвойстваКриптосообщения.СвойстваБлокаПодписанныхДанных, РазмерДанных);
	ЗаписьДанных.Записать(БлокПолейПодписанныхДанных);
	ЗаписьДанных.Закрыть();
	БлокПодписанныхДанных = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	РазмерДанных = СвойстваКриптосообщения.БлокТипаСодержимого.Размер()
		+ БлокПодписанныхДанных.Размер();
	ЗаписатьСвойстваБлока(ЗаписьДанных, СвойстваКриптосообщения.СвойстваОсновногоБлока, РазмерДанных);
	
	ЗаписьДанных.Записать(СвойстваКриптосообщения.БлокТипаСодержимого);
	ЗаписьДанных.Записать(БлокПодписанныхДанных);
	ЗаписьДанных.Закрыть();
	Возврат ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
КонецФункции

Функция УстановитьСертификаты(Сертификаты) Экспорт
	
	Ошибки = Новый Массив;
	Для Каждого Сертификат ИЗ Сертификаты Цикл
		Попытка
			ХранилищеСертификатов.Добавить(
				Сертификат.Сертификат, 
				ПривестиКЕдиномуТипуХранилища(Сертификат.Хранилище.Хранилище));
		Исключение
			Ошибка = Новый Структура;
			Ошибка.Вставить("Сертификат", Сертификат);
			ОШибка.Вставить("Ошибка", КриптографияЭДКОСлужебныйКлиентСервер.ОшибкаУстановкиСертификатаСервисомКриптографии(ИнформацияОбОшибке()));
			Ошибки.Добавить(Ошибка);
		КонецПопытки;
	КонецЦикла;
	
	Возврат Ошибки;
	
КонецФункции

Функция ПреобразоватьФорматСвойствСертификата(ИсходныйСертификат, Хранилище)
	
	Сертификат = Новый Структура;
	Сертификат.Вставить("Наименование", ИсходныйСертификат.Наименование);
	Сертификат.Вставить("Версия", ИсходныйСертификат.Версия);
	Сертификат.Вставить("СерийныйНомер", НРег(ИсходныйСертификат.СерийныйНомер));
	Сертификат.Вставить("Поставщик", ПреобразоватьВСтроку(ИсходныйСертификат.Издатель));
	Сертификат.Вставить("Владелец", ПреобразоватьВСтроку(ИсходныйСертификат.Субъект));
	Сертификат.Вставить("Отпечаток", СтрЗаменить(НРег(ИсходныйСертификат.Отпечаток), " ", ""));
	Сертификат.Вставить("ИспользоватьДляПодписи", ИсходныйСертификат.ИспользоватьДляПодписи);
	Сертификат.Вставить("ИспользоватьДляШифрования", ИсходныйСертификат.ИспользоватьДляШифрования);
	Сертификат.Вставить("ДействителенС", МестноеВремя(ИсходныйСертификат.ДатаНачала, ЧасовойПоясСеанса()));
	Сертификат.Вставить("ДействителенПо", МестноеВремя(ИсходныйСертификат.ДатаОкончания, ЧасовойПоясСеанса()));
	Сертификат.Вставить("Хранилище", Новый Структура("Хранилище, ЭтоЛокальноеХранилище", ВРег(Хранилище), Ложь));

	Возврат Сертификат;
	
КонецФункции

Функция ПреобразоватьСертификатыНаСервере(Json) Экспорт
	
	Возврат КриптографияЭДКОСлужебныйПовтИсп.ПреобразоватьСертификатыНаСервере(Json);
	
КонецФункции

Функция ИспользованиеКриптосервисаВозможно() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);	
	Возврат Константы.ИспользоватьЭлектроннуюПодписьВМоделиСервиса.Получить();
	
КонецФункции

Функция ПодписиСертификатовДокументооборотаВJSON(ОтпечатокСертификата = Неопределено) Экспорт
	
	МассивПодписей = ПодписиСертификатовДокументооборота(ОтпечатокСертификата);
	Если МассивПодписей.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат ОбщегоНазначенияЭДКОСлужебныйВызовСервера.СтруктураВJson(МассивПодписей);
	
КонецФункции

Функция ПодписиСертификатовДокументооборота(ОтпечатокСертификата = Неопределено) Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ПодписиСертификатовДокументооборота.ОтпечатокСертификата КАК ОтпечатокСертификата,
		|	ПодписиСертификатовДокументооборота.Данные КАК Данные
		|ИЗ
		|	РегистрСведений.ПодписиСертификатовДокументооборота КАК ПодписиСертификатовДокументооборота"
		+ ?(ОтпечатокСертификата = Неопределено, "", "
		|ГДЕ
		|	ПодписиСертификатовДокументооборота.ОтпечатокСертификата = &ОтпечатокСертификата"));
	
	Если ОтпечатокСертификата <> Неопределено Тогда
		Запрос.УстановитьПараметр("ОтпечатокСертификата", нрег(ОтпечатокСертификата));
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Результат = Новый Массив;
	Пока Выборка.Следующий() Цикл
		ДвоичныеДанныеПодписи = Выборка.Данные.Получить();
		ДанныеПодписи64 = Base64Строка(ДвоичныеДанныеПодписи);
		ДанныеПодписи64 = СтрЗаменить(ДанныеПодписи64, Символы.ВК, "");
		ДанныеПодписи64 = СтрЗаменить(ДанныеПодписи64, Символы.ПС, "");
		
		ПодписьСертификатаДокументооборота = Новый Структура;
		ПодписьСертификатаДокументооборота.Вставить("thumbprint", 	Выборка.ОтпечатокСертификата);
		ПодписьСертификатаДокументооборота.Вставить("signature", 	ДанныеПодписи64);
		Результат.Добавить(ПодписьСертификатаДокументооборота);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
	
Функция ПроверитьСертификатОблачнойПодписи(УчетнаяЗаписьОблачнойПодписи, Сертификат) Экспорт
	
	МодульСервисКриптографииDSS = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSS");
	Возврат МодульСервисКриптографииDSS.ПроверитьСертификат(УчетнаяЗаписьОблачнойПодписи, Сертификат);
		
КонецФункции

Функция НайтиСертификатВХранилищеПолучателей(Сертификат) Экспорт
	
	// вызвать менеджер регистра
	Результат = КриптографияЭДКО.НайтиСертификатПолучателя(Сертификат);
	
	Возврат Результат;
	
КонецФункции

//	MY, AddressBook, CA, ROOT
Функция ПолучитьСертификатыПолучателей(ТипСертификата = "") Экспорт
	
	Возврат КриптографияЭДКО.ПолучитьСертификатыПолучателей(ТипСертификата);

КонецФункции

Функция НайтиСертификатыОблачнойПодписи(Сертификаты, УчетнаяЗаписьОблачнойПодписи = Неопределено, ВыполнятьПроверку = Ложь) Экспорт
	
	НайденныеСертификаты = Новый Массив;
	НенайденныеСертификаты = Новый Массив;
	МодульСервисКриптографииDSS = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSS");
	
	Для Каждого Сертификат Из Сертификаты Цикл
		УчетнаяЗаписьОблачнойПодписи = КриптографияЭДКОКлиентСервер.ПолучитьУчетнуюЗаписьПодписи(Сертификат);
		
		РезультатВызова = МодульСервисКриптографииDSS.НайтиСертификат(Сертификат);
		ДанныеСертификата = Неопределено;
		Если РезультатВызова.Выполнено Тогда
			ДанныеСертификата = РезультатВызова.ДанныеСертификата;
			УчетнаяЗаписьОблачнойПодписи = ?(УчетнаяЗаписьОблачнойПодписи = Неопределено, РезультатВызова.УчетнаяЗапись, УчетнаяЗаписьОблачнойПодписи);
			Хранилище = "MY";
		Иначе
			ДанныеСертификата = КриптографияЭДКО.НайтиСертификатПолучателя(Сертификат);
			Если ЗначениеЗаполнено(ДанныеСертификата) Тогда
				Хранилище = ДанныеСертификата.Хранилище;
			КонецЕсли;
		КонецЕсли;
		
		НашлиСертификат = Неопределено;
		Если ЗначениеЗаполнено(ДанныеСертификата) Тогда
			НашлиСертификат = ЭлектроннаяПодписьВМоделиСервисаБРОВызовСервера.ПодготовитьСертификатОблачнойПодписи(ДанныеСертификата);
			НашлиСертификат.Вставить("Поставщик", НашлиСертификат.Издатель);
			НашлиСертификат.Вставить("Владелец", НашлиСертификат.Субъект);
			НашлиСертификат.Вставить("ДействителенС", НашлиСертификат.ДатаНачала);
			НашлиСертификат.Вставить("ДействителенПо", НашлиСертификат.ДатаОкончания);
			НашлиСертификат.Вставить("Валиден", Истина);
			НашлиСертификат.Вставить("Хранилище", Хранилище);
			НайденныеСертификаты.Добавить(НашлиСертификат);
		Иначе
			НенайденныеСертификаты.Добавить(Сертификат);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ДанныеСертификата) И ВыполнятьПроверку Тогда
			Если НЕ ЗначениеЗаполнено(УчетнаяЗаписьОблачнойПодписи) Тогда
				Отбор = Новый Соответствие;
				Отбор.Вставить("Методы.СервисПроверки", "Заполнено");
				МодульСервисКриптографииDSSСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSSСлужебныйВызовСервера");
				ВсеНастройки = МодульСервисКриптографииDSSСлужебныйВызовСервера.ПодобратьНастройкиПользователя(Отбор);
				Если ВсеНастройки.Количество() > 0 Тогда
					УчетнаяЗаписьОблачнойПодписи = ВсеНастройки[0];	
				КонецЕсли;	
			КонецЕсли;
			
			Если ЗначениеЗаполнено(УчетнаяЗаписьОблачнойПодписи) Тогда
				РезультатВызова = МодульСервисКриптографииDSS.ПроверитьСертификат(УчетнаяЗаписьОблачнойПодписи, ДанныеСертификата.Сертификат);
				НашлиСертификат.Валиден = РезультатВызова.Выполнено И РезультатВызова.Результат;
			КонецЕсли;	
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Новый Структура("Сертификаты,НенайденныеСертификаты", НайденныеСертификаты, НенайденныеСертификаты);
	
КонецФункции

// Выполняет проверку подписи в сервисе облачной подписи.
//
// Параметры:
//	УчетнаяЗаписьОблачнойПодписи - Структура, СправочникСсылка.УчетныеЗаписиDSS
//	Подпись             - ДвоичныеДанные, Строка - подпись, 
//                                которую необходимо проверить, или ее адрес во временном хранилище.
//	ИсходныеДанные      - ДвоичныеДанные, Строка - данные или адрес во временном хранилище.
//	Сертификаты         - Неопределено - извлечь сертификаты из подписи и поместить в параметр,
//                        проверка подписи в этом случае выполняется согласно извлекаемым подписантам.
//                      - Массив - массив двоичных данных сертификатов, необходим для проверки "голой" подписи ГОСТ
//	Подписанты          - Массив Из Структура - возвращаемые подписанты при извлечении сертификатов из подписи:
//                        * СерийныйНомер  - Строка - серийный номер сертификата.
//                        * Поставщик      - Строка - издатель сертификата.
//                        * Отпечаток      - Строка - отпечаток сертификата.
//                        * Выполнено      - Булево - если Истина, то проверка проверка сертификат была выполнена для подписанта.
//                        * ПодписьВалидна - Булево - результат проверки подписи для подписанта.
//	КомментарийПоОшибке - Строка - может возвращаться причина неудачи проверки подписи.
//
// Возвращаемое значение:
//	Булево - Истина - подпись соответствует владельцам всех сертификатов.
//
Функция ПроверитьПодписьОблачнаяПодпись(УчетнаяЗаписьОблачнойПодписи, Подпись, ИсходныеДанные, Сертификаты = Неопределено, Подписанты = Неопределено, КомментарийПоОшибке = "") Экспорт
	
	ПодписьВалидна = Ложь;
	
	Если ТипЗнч(Подпись) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанныеПодписи = Подпись;
	Иначе
		ДвоичныеДанныеПодписи = ПолучитьИзВременногоХранилища(Подпись);
	КонецЕсли;
	
	Если ТипЗнч(ИсходныеДанные) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанныеИсходныхДанных = ИсходныеДанные;
	Иначе
		ДвоичныеДанныеИсходныхДанных = ПолучитьИзВременногоХранилища(ИсходныеДанные);
	КонецЕсли;
	
	Подписанты 				= Новый Массив;
	
	МодульСервисКриптографииDSS = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSS");
	
	Если Сертификаты <> Неопределено Тогда
		РезультатВыполнения = Новый Структура("Выполнено", Истина);
		
		Для Каждого СтрокаМассива Из Сертификаты Цикл
			РезультатПроверки = МодульСервисКриптографииDSS.ПроверитьПодпись(УчетнаяЗаписьОблачнойПодписи, ДвоичныеДанныеПодписи, ДвоичныеДанныеИсходныхДанных, "CMS", Неопределено, СтрокаМассива);
			ПодписьПроверена = Истина;
			Если РезультатПроверки.Выполнено И НЕ РезультатПроверки.Результат Тогда
				ПодписьПроверена = Ложь;
			ИначеЕсли НЕ РезультатПроверки.Выполнено Тогда
				РезультатВыполнения.Выполнено = Ложь; 
				ПодписьПроверена = Ложь;
			Иначе
				ПодписьПроверена = Ложь;
			КонецЕсли;
			
			ДополнитьПодписанта(СтрокаМассива, Подписанты, ПодписьПроверена);	
		КонецЦикла;
		
	Иначе
		РезультатВыполнения = МодульСервисКриптографииDSS.ПроверитьПодпись(УчетнаяЗаписьОблачнойПодписи, ДвоичныеДанныеПодписи, ДвоичныеДанныеИсходныхДанных, "CMS", Неопределено);
		Если РезультатВыполнения.Выполнено Тогда
			Сертификаты = Новый Массив;
			Для каждого СтрокаМассива Из РезультатВыполнения.Сертификаты Цикл
				ДополнитьПодписанта(СтрокаМассива.Сертификат, Подписанты, СтрокаМассива.ПодписьВалидна);	
				Сертификаты.Добавить(СтрокаМассива.Сертификат);
			КонецЦикла;	
		КонецЕсли;
		
	КонецЕсли;
	
	Если НЕ РезультатВыполнения.Выполнено Тогда
		КомментарийПоОшибке = НСтр("ru = 'Ошибка при запросе сервиса проверки подписи.';
									|en = 'Ошибка при запросе сервиса проверки подписи.'");
		Возврат Ложь;
	КонецЕсли;	
	
	Если Подписанты.Количество() = 0 Тогда
		КомментарийПоОшибке = НСтр("ru = 'Отсутствует информация о подписантах, проверка подписи невозможна.';
									|en = 'Отсутствует информация о подписантах, проверка подписи невозможна.'");
		Возврат Ложь;
	КонецЕсли;
	
	ПодписьВалидна = Истина;
	Для Каждого СтрокаМассива Из Подписанты Цикл
		СтрокаПоиска = Новый Структура("Отпечаток", СтрокаМассива.Отпечаток);
		Если НайтиСертификатВХранилищеПолучателей(СтрокаПоиска) = Неопределено Тогда
			ДобавитьСертификатПолучателя(СтрокаМассива.Сертификат, "AddressBook");
		КонецЕсли;
		
		РезультатВыполнения = МодульСервисКриптографииDSS.ПроверитьСертификат(УчетнаяЗаписьОблачнойПодписи, СтрокаМассива.Сертификат);
		Если РезультатВыполнения.Выполнено И РезультатВыполнения.Результат Тогда
			СтрокаМассива.Выполнено = Истина;
		Иначе
			КомментарийПоОшибке = РезультатВыполнения.Ошибка;
		КонецЕсли;
		
		ПодписьВалидна = ПодписьВалидна И СтрокаМассива.Выполнено;
		
	КонецЦикла;
	
	Возврат ПодписьВалидна;
	
КонецФункции

Функция ПолучитьНастройкиОблачнойПодписиПоСертификату(Сертификат) Экспорт
	
	МодульСервисКриптографииDSS = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSS");
	Результат = МодульСервисКриптографииDSS.НайтиСертификат(Сертификат);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьТипОблачнойПодписи() Экспорт
	
	Результат = Неопределено;
	
	Если ИспользованиеОблачнойПодписиВозможно() Тогда
		МодульСервисКриптографииDSSКлиентСервер = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSSКлиентСервер");
		Результат = МодульСервисКриптографииDSSКлиентСервер.ПолучитьТипОблачнойПодписи();
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИспользованиеОблачнойПодписиВозможно() Экспорт
	
	Результат = КриптографияЭДКО.ИспользованиеОблачнойПодписиВозможно();
	
	Возврат Результат;
	
КонецФункции

// Извлекает информацию о типе криптопровайдера (программе) и возвращает его криптопровайдер по умолчанию
Функция ИзвлечьКриптопровайдер(Сертификат, ПроанализироватьАлгоритм = Ложь) Экспорт
	
	Если Сертификат = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("cer");
	Сертификат.Записать(ИмяВременногоФайла);
	
	Байты = ПрочитатьФайлВМассив(ИмяВременногоФайла);
	
	БайтыСигнатурыПоиска = Новый Массив; // Ищем OID 1.2.643.100.111
	БайтыСигнатурыПоиска.Добавить(6);
	БайтыСигнатурыПоиска.Добавить(5);
	БайтыСигнатурыПоиска.Добавить(42);
	БайтыСигнатурыПоиска.Добавить(133);
	БайтыСигнатурыПоиска.Добавить(3);
	БайтыСигнатурыПоиска.Добавить(100);
	БайтыСигнатурыПоиска.Добавить(111);
	
	Индекс = 0;
	ИндексНачалаСигнатуры = 0;
	СигнатураНайдена = Ложь;
	Для Каждого Байт Из Байты Цикл
		Если Байт = БайтыСигнатурыПоиска[0] Тогда
			СигнатураНайдена = Истина;
			Для Индекс2 = 1 По 6 Цикл
				Если Байты[Индекс2 + Индекс] <> БайтыСигнатурыПоиска[Индекс2] Тогда
					СигнатураНайдена = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если СигнатураНайдена Тогда
				ИндексНачалаСигнатуры = Индекс;
				Прервать;
			КонецЕсли;
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Криптопровайдер = "";
	Если СигнатураНайдена Тогда
		КоличествоБайтПодТекст = Байты[ИндексНачалаСигнатуры + БайтыСигнатурыПоиска.Количество() + 1];
		НачалоТекста = ИндексНачалаСигнатуры + БайтыСигнатурыПоиска.Количество() + 4;
		
		БайтыДляЗаписи = Новый Массив;
		Для Индекс = НачалоТекста По НачалоТекста + КоличествоБайтПодТекст - 3 Цикл
			БайтыДляЗаписи.Добавить(Байты[Индекс]);
		КонецЦикла;
		
		ИмяФайла = ПолучитьИмяВременногоФайла("txt");
		ЗаписатьФайлИзМассива(ИмяФайла, БайтыДляЗаписи);
		
		ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, "utf-8");
		Криптопровайдер = ЧтениеТекста.Прочитать();
		ЧтениеТекста.Закрыть();
		
		ОперацииСФайламиЭДКО.УдалитьВременныйФайл(ИмяФайла);
	КонецЕсли;
	ОперацииСФайламиЭДКО.УдалитьВременныйФайл(ИмяВременногоФайла);
	
	Если СтрНайти(НРег(Криптопровайдер), "cryptopro") ИЛИ СтрНайти(НРег(Криптопровайдер), "криптопро") Тогда
		Криптопровайдер = КриптографияЭДКОКлиентСервер.КриптопровайдерCryptoPro();
	ИначеЕсли СтрНайти(НРег(Криптопровайдер), "vipnet") ИЛИ СтрНайти(НРег(Криптопровайдер), "випнет") Тогда
		Криптопровайдер = КриптографияЭДКОКлиентСервер.КриптопровайдерViPNet();
	Иначе
		Криптопровайдер = Неопределено;
	КонецЕсли;
	
	Если ПроанализироватьАлгоритм И Криптопровайдер <> Неопределено Тогда
		Настройки = Новый Структура;
		Настройки.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", 	Ложь);
		Настройки.Вставить("ЭтоСтрокаBase64", 						Ложь);
		Настройки.Вставить("ВозможенФорматBase64", 					Ложь);
		Настройки.Вставить("ВозвращатьИсключения", 					Ложь);
		СвойстваСертификата = КриптографияЭДКОСлужебныйВызовСервера.ПолучитьСвойстваСертификата(
			Сертификат, Настройки);
		
		ПутьМодуляКриптографии = ?(ОбщегоНазначенияЭДКО.ЭтоКриптопровайдерLinux(),
			ЭлектронныйДокументооборотСКонтролирующимиОрганамиКлиентСервер.ПутьМодуляКриптографии(), "");
		СвойстваКриптопровайдера = КриптографияЭДКОКлиентСервер.СвойстваКриптопровайдераПоУмолчанию(
			Криптопровайдер.ТипКриптопровайдера,
			СвойстваСертификата.АлгоритмПубличногоКлюча,
			ПутьМодуляКриптографии);
		Если ЗначениеЗаполнено(СвойстваКриптопровайдера.Имя) Тогда
			Криптопровайдер = СвойстваКриптопровайдера;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Криптопровайдер;
	
КонецФункции

Функция ПоставщикДляXAdES(Поставщик, ДанныеСертификата = Неопределено) Экспорт
	
	Результат = "";
	
	// заполнить список полей
	
	ИмяПоOID = СоответствиеOIDИмя();
	OIDПоИмени = Новый Соответствие;
	Для каждого OIDИИмя Из ИмяПоOID Цикл
		OIDПоИмени.Вставить(OIDИИмя.Значение, OIDИИмя.Ключ);
	КонецЦикла;
	ИменаПолейXAdES = СтрРазделить("CN,C,STREET,ST,L,O,OU", ",");
	ТипПоOID = СоответствиеOIDТип();
	
	МассивПолей = Новый Массив;
	МассивИменПолей = Новый Массив;
	ДлинаСтроки = СтрДлина(Поставщик);
	ПозицияЗапятой = 0;
	ПозицияРавно = 0;
	ИмяПоля = "";
	ЭтоOID = Ложь;
	
	Для НомерСимвола = 1 По ДлинаСтроки Цикл
		ТекущийСимвол = Сред(Поставщик, НомерСимвола, 1);
		Если ТекущийСимвол = "," Тогда
			ПозицияЗапятой = НомерСимвола;
			
		ИначеЕсли ТекущийСимвол = "=" Тогда
			ВозможноеИмяПоля = Сред(Поставщик, ПозицияЗапятой + 1, НомерСимвола - ПозицияЗапятой - 1);
			ВозможноеИмяПоля = СокрЛП(ВозможноеИмяПоля);
			ВозможноеИмяПоля = ВРег(ВозможноеИмяПоля);
			OIDИмени = ?(ЗначениеЗаполнено(ВозможноеИмяПоля), OIDПоИмени[ВозможноеИмяПоля], "");
			Если ЗначениеЗаполнено(OIDИмени) Тогда
				ЭтоВозможныйOID = Ложь;
			ИначеЕсли Лев(ВозможноеИмяПоля, 3) = "OID" И СтрДлина(ВозможноеИмяПоля) > 3 Тогда
				OIDИмени = Сред(ВозможноеИмяПоля, 4);
				ИмяOID = ИмяПоOID[OIDИмени];
				ВозможноеИмяПоля = ?(ЗначениеЗаполнено(ИмяOID), ИмяOID, OIDИмени);
				ЭтоВозможныйOID = НЕ ЗначениеЗаполнено(ИмяOID);
			Иначе
				ВозможноеИмяПоля = ""; // неизвестное имя поля, но не OID, пропускаем
				ЭтоВозможныйOID = Ложь;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(ВозможноеИмяПоля) И НЕ ЭтоВозможныйOID
				И ИменаПолейXAdES.Найти(ВозможноеИмяПоля) = Неопределено Тогда
				
				ВозможноеИмяПоля = OIDИмени;
				ЭтоВозможныйOID = Истина;
			КонецЕсли;
			Если ЭтоВозможныйOID Тогда
				ВозможноеИмяПоля = СтрЗаменить(ВозможноеИмяПоля, "_", ".");
			Конецесли;
			
			Если ЗначениеЗаполнено(ВозможноеИмяПоля) Тогда
				Если ЗначениеЗаполнено(ИмяПоля) Тогда
					ЗначениеПоля = Сред(Поставщик, ПозицияРавно + 1, ПозицияЗапятой - ПозицияРавно - 1);
					СведенияОПоле = Новый Структура;
					СведенияОПоле.Вставить("ИмяПоля", 		ИмяПоля);
					СведенияОПоле.Вставить("ЗначениеПоля", 	ЗначениеПоля);
					СведенияОПоле.Вставить("ЭтоOID", 		ЭтоOID);
					Если МассивИменПолей.Найти(ИмяПоля) = Неопределено Тогда
						МассивПолей.Добавить(СведенияОПоле);
						МассивИменПолей.Добавить(ИмяПоля);
					КонецЕсли;
				КонецЕсли;
				
				ПозицияРавно = НомерСимвола;
				
				ИмяПоля = ВозможноеИмяПоля;
				ЭтоOID 	= ЭтоВозможныйOID;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоля = Сред(Поставщик, ПозицияРавно + 1, ДлинаСтроки - ПозицияРавно);
		СведенияОПоле = Новый Структура;
		СведенияОПоле.Вставить("ИмяПоля", 		ИмяПоля);
		СведенияОПоле.Вставить("ЗначениеПоля", 	ЗначениеПоля);
		СведенияОПоле.Вставить("ЭтоOID", 		ЭтоOID);
		Если МассивИменПолей.Найти(ИмяПоля) = Неопределено Тогда
			МассивПолей.Добавить(СведенияОПоле);
			МассивИменПолей.Добавить(ИмяПоля);
		КонецЕсли;
	КонецЕсли;
	
	// сформировать результат
	
	МассивПолейСИменами = Новый Массив;
	МассивПолейСOID = Новый Массив;
	Если ДанныеСертификата <> Неопределено Тогда
		ЭтоДвоичныеДанные = (ТипЗнч(ДанныеСертификата) = Тип("ДвоичныеДанные"));
		
		НастройкиВызова = Новый Структура;
		НастройкиВызова.Вставить("ЭтоСтрокаBase64", НЕ ЭтоДвоичныеДанные);
		НастройкиВызова.Вставить("ПрочитатьПоляПоставщика", Истина);
		НастройкиВызова.Вставить("ВозвращатьИсключения", Ложь);
		
		СвойстваСертификата = ПолучитьСвойстваСертификата(ДанныеСертификата, НастройкиВызова);
		
		Для каждого ПолеПоставщика Из СвойстваСертификата.ПоляПоставщика Цикл
			OIDИмени = СтрЗаменить(ПолеПоставщика.ИдентификаторПоля, ".", "_");
			ИмяOID = ИмяПоOID[OIDИмени];
			ЭтоOID = (ИменаПолейXAdES.Найти(ИмяOID) = Неопределено);
			ИмяПоля = ?(ЭтоOID, ПолеПоставщика.ИдентификаторПоля, ИмяOID);
			ИндексПоля = МассивИменПолей.Найти(ИмяПоля);
			
			Если ЭтоOID ИЛИ ИндексПоля = Неопределено Тогда
				ЗначениеПоля = ПолучитьHexСтрокуИзДвоичныхДанных(ПолеПоставщика.ДанныеПоля);
				ЗначениеПоля = "#" + нрег(ЗначениеПоля);
				
			Иначе
				ЗначениеПоля = СтрЗаменить(МассивПолей[ИндексПоля].ЗначениеПоля, "\", "\\");
				ЗначениеПоля = СтрЗаменить(ЗначениеПоля, """", "\""");
				ЗначениеПоля = СтрЗаменить(ЗначениеПоля, ",", "\,");
			КонецЕсли;
			
			Если ЭтоOID Тогда
				МассивПолейСOID.Добавить(OIDИмени + "=" + ЗначениеПоля);
			Иначе
				МассивПолейСИменами.Добавить(ИмяOID + "=" + ЗначениеПоля);
			КонецЕсли;
			Если ИндексПоля <> Неопределено Тогда
				МассивИменПолей[ИндексПоля] = "";
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	МассивПолейИЗначений = МассивПолейСИменами;
	
	Для каждого ПолеИЗначение Из МассивПолейСOID Цикл
		МассивПолейИЗначений.Добавить(ПолеИЗначение);
	КонецЦикла;
	
	Для ИндексПоля = 0 По МассивПолей.Количество() - 1 Цикл
		Если ЗначениеЗаполнено(МассивИменПолей[ИндексПоля]) Тогда
			СведенияОПоле = МассивПолей[ИндексПоля];
			Если СведенияОПоле.ЭтоOID Тогда
				ПотокДанных = Новый ПотокВПамяти();
				ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
				OIDИмени = СтрЗаменить(СведенияОПоле.ИмяПоля, ".", "_");
				ЗаписатьСтроку(ЗаписьДанных, СведенияОПоле.ЗначениеПоля, ТипПоOID[OIDИмени]);
				ЗаписьДанных.Закрыть();
				ДанныеПоля = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
				ЗначениеПоля = ПолучитьHexСтрокуИзДвоичныхДанных(ДанныеПоля);
				ЗначениеПоля = "#" + нрег(ЗначениеПоля);
			Иначе
				ЗначениеПоля = СтрЗаменить(СведенияОПоле.ЗначениеПоля, "\", "\\");
				ЗначениеПоля = СтрЗаменить(ЗначениеПоля, """", "\""");
				ЗначениеПоля = СтрЗаменить(ЗначениеПоля, ",", "\,");
			КонецЕсли;
			МассивПолейИЗначений.Добавить(СведенияОПоле.ИмяПоля + "=" + ЗначениеПоля);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(МассивПолейИЗначений, ",");
	
КонецФункции

Функция ШтампВремени(
		АдресСервисаИлиМассив = Неопределено,
		ХешДанных64ШестнадцатеричныхСимвола = "",
		Случайные16ШестнадцатеричныхСимволов = "") Экспорт
	
	// https://datatracker.ietf.org/doc/html/rfc3161
	// TimeStampReq ::= SEQUENCE  {
	//    version                      INTEGER  { v1(1) },
	//    messageImprint               MessageImprint,
	//      --a hash algorithm OID and the hash value of the data to be
	//      --time-stamped
	//    reqPolicy             TSAPolicyId              OPTIONAL,
	//    nonce                 INTEGER                  OPTIONAL,
	//    certReq               BOOLEAN                  DEFAULT FALSE,
	//    extensions            [0] IMPLICIT Extensions  OPTIONAL  }
	// MessageImprint ::= SEQUENCE  {
	//    hashAlgorithm                AlgorithmIdentifier,
	//    hashedMessage                OCTET STRING  }
	
	Если АдресСервисаИлиМассив = Неопределено Тогда
		АдресаСерверов = ДокументооборотСКОВызовСервера.АдресаСерверовМетокВремени();
	Иначе
		АдресаСерверов = ДокументооборотСКОВызовСервера.АдресаСерверовМетокВремени(АдресСервисаИлиМассив);
	КонецЕсли;
	
	Для каждого АдресСервиса Из АдресаСерверов Цикл
		ДанныеЗапроса = ПолучитьДвоичныеДанныеИзHexСтроки("3040020101302E300A06082A850307010102020420"
			+ ХешДанных64ШестнадцатеричныхСимвола + "0208" + Случайные16ШестнадцатеричныхСимволов + "0101FF");
		
		ОписаниеОшибкиУстановкиСоединения = "";
		Таймаут = 120;
		СоединениеHTTP = ДокументооборотСКО.УстановитьСоединениеССерверомИнтернета(
			АдресСервиса,
			ОписаниеОшибкиУстановкиСоединения,
			Таймаут);
		Если СоединениеHTTP = Неопределено Тогда
			ТекстОшибки = НСтр("ru = 'Не удалось установить соединение с центром штампов времени:
									 |%1';
									 |en = 'Не удалось установить соединение с центром штампов времени:
									 |%1'");
			ТекстОшибки = СтрШаблон(
				ТекстОшибки,
				ОписаниеОшибкиУстановкиСоединения);
			ДлительнаяОтправкаКлиентСервер.ВывестиОшибку(ТекстОшибки);
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Электронный документооборот с контролирующими органами. Получение штампа времени';
					|en = 'Электронный документооборот с контролирующими органами. Получение штампа времени'"),
				УровеньЖурналаРегистрации.Ошибка,,,
				ТекстОшибки);
			Продолжить;
		КонецЕсли;
		
		// Формируем заголовки запроса SOAP.
		АдресРесурса = "/" + ОбщегоНазначенияКлиентСервер.СтруктураURI(АдресСервиса).ПутьНаСервере;
		
		HTTPЗапрос = Новый HTTPЗапрос(АдресРесурса);
		HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/timestamp-query");
		HTTPЗапрос.Заголовки.Вставить("Proxy-Connection", "Keep-Alive");
		
		HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДанныеЗапроса);
		
		// Посылаем запрос.
		Попытка
			Ответ = СоединениеHTTP.ОтправитьДляОбработки(HTTPЗапрос);
		Исключение
			ОписаниеОшибкиОтправки = ОписаниеОшибки();
			ТекстОшибки = НСтр("ru = 'Не удалось установить соединение с центром штампов времени:
									 |%1';
									 |en = 'Не удалось установить соединение с центром штампов времени:
									 |%1'");
			ТекстОшибки = СтрШаблон(
				ТекстОшибки,
				ОписаниеОшибкиОтправки);
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
			ЗаписьЖурналаРегистрации(
				НСтр("ru = 'Электронный документооборот с контролирующими органами. Получение штампа времени';
					|en = 'Электронный документооборот с контролирующими органами. Получение штампа времени'"),
				УровеньЖурналаРегистрации.Ошибка,,,
				ТекстОшибки);
			Продолжить;
		КонецПопытки;
		
		ДанныеОтвета = Ответ.ПолучитьТелоКакДвоичныеДанные();
		
		БуферДанныхОтвета = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДанныеОтвета);
		БуферДанныхОтвета = БуферДанныхОтвета.ПолучитьСрез(9);
		Возврат ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(БуферДанныхОтвета);
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция ДобавитьШтампВремени(Криптосообщение, ХешСтрока) Экспорт
	
	СлучайноеЧислоОт8Байт = ТекущаяУниверсальнаяДатаВМиллисекундах() * (256 * 256 * 256 * 256)
		+ ТекущаяУниверсальнаяДатаВМиллисекундах();
	ХешСтрокаЗначенияПодписиБезПробелов = СтрЗаменить(ХешСтрока, " ", "");
	Случайные16ШестнадцатеричныхСимволов = ДокументооборотСКОВызовСервера.ЧислоВШестнадцатеричномПредставлении(
		СлучайноеЧислоОт8Байт, 8);
	
	ДанныеШтампаВремени = ШтампВремени(,
		ХешСтрокаЗначенияПодписиБезПробелов,
		Случайные16ШестнадцатеричныхСимволов);
	
	Настройки = Новый Структура("ПрочитатьСтруктуру", Истина);
	СвойстваКриптосообщения = ПолучитьСвойстваКриптосообщения(Криптосообщение, Настройки);
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	ЗаписатьUnauthenticatedAttributes(ЗаписьДанных, ДанныеШтампаВремени);
	ЗаписьДанных.Закрыть();
	БлокиНеаутентифицированныхАтрибутов = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	Возврат СформироватьКриптосообщение(СвойстваКриптосообщения, БлокиНеаутентифицированныхАтрибутов);
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ДополнитьСертификатыСервера(Сертификаты, МассивСертификатов, ЗначениеХранилища, МестоХраненияКлюча)
	
	ОбшийСписок = Новый Соответствие;
	Для Каждого СледующийСертификат Из Сертификаты Цикл
		ОбшийСписок.Вставить(СледующийСертификат.Отпечаток);
	КонецЦикла;
	
	Если ТипЗнч(МассивСертификатов) <> Тип("Массив") Тогда
		НовыеСертификаты = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(МассивСертификатов);
	Иначе
		НовыеСертификаты = МассивСертификатов;
	КонецЕсли;
	
	Для Каждого ПолученныйСертификат Из НовыеСертификаты Цикл
		Сертификат = ПреобразоватьФорматСвойствСертификата(ПолученныйСертификат, ЗначениеХранилища);
		Если ОбшийСписок[Сертификат.Отпечаток] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ОбшийСписок.Вставить(ПолученныйСертификат.Отпечаток);
		КриптографияЭДКОКлиентСервер.ЗаполнитьМестоХраненияКлюча(МестоХраненияКлюча, Сертификат);
		
		Сертификат.Вставить(
			"ПоставщикСтруктура", 
			ОбщегоНазначения.СкопироватьРекурсивно(ПолученныйСертификат.Издатель));
		Сертификат.Вставить(
			"ВладелецСтруктура", 
			ОбщегоНазначения.СкопироватьРекурсивно(ПолученныйСертификат.Субъект));
		Сертификаты.Добавить(Сертификат);
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПрочитатьФайлВМассив(ИмяФайла)
	
	Результат = Новый Массив;
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, "ISO-8859-1", Символы.ПС, Символы.ПС);
	
	Пока Истина Цикл
		СимволТекста = ЧтениеТекста.Прочитать(1);
		Если СимволТекста = Неопределено Тогда
			Прервать;
		КонецЕсли;
		КодСимволаТекста = КодСимвола(СимволТекста);
		
		Результат.Добавить(КодСимволаТекста);
	КонецЦикла;
	ЧтениеТекста.Закрыть();
	
	Возврат Результат;
	
КонецФункции

Процедура ЗаписатьФайлИзМассива(ИмяФайла, Массив)
	
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, "ISO-8859-1", Символы.ПС,, Символы.ПС);
	
	Для ИндексВМассиве = 0 По Массив.ВГраница() Цикл
		СимволИзМассива = Символ(Массив[ИндексВМассиве]);
		ЗаписьТекста.Записать(СимволИзМассива);
	КонецЦикла;
	ЗаписьТекста.Закрыть();
	
КонецПроцедуры

Процедура ЗаписатьСобытиеВЖурнал(Имя, Уровень = "Ошибка", Комментарий) Экспорт
	
	Уровни = Новый Соответствие;
	Уровни.Вставить("Информация", 		УровеньЖурналаРегистрации.Информация);
	Уровни.Вставить("Ошибка", 			УровеньЖурналаРегистрации.Ошибка);
	Уровни.Вставить("Предупреждение", 	УровеньЖурналаРегистрации.Предупреждение);
	Уровни.Вставить("Примечание", 		УровеньЖурналаРегистрации.Примечание);
	
	УровеньЖР = Уровни.Получить(Уровень);
	
	ЗаписьЖурналаРегистрации(Имя, УровеньЖР,,, Комментарий);
	
КонецПроцедуры

Функция ПривестиКЕдиномуТипуХранилища(Знач ТипХранилища)
	
	СоответствиеТиповХранилищ = Новый Соответствие;
	СоответствиеТиповХранилищ.Вставить("MY", Перечисления.ТипХранилищаСертификатов.ПерсональныеСертификаты);
	СоответствиеТиповХранилищ.Вставить("ADDRESSBOOK", Перечисления.ТипХранилищаСертификатов.СертификатыПолучателей);
	СоответствиеТиповХранилищ.Вставить("CA", Перечисления.ТипХранилищаСертификатов.СертификатыУдостоверяющихЦентров);
	СоответствиеТиповХранилищ.Вставить("ROOT", Перечисления.ТипХранилищаСертификатов.КорневыеСертификаты);
	
	Если ТипЗнч(ТипХранилища) = Тип("Строка") Тогда		
		Возврат СоответствиеТиповХранилищ.Получить(ВРег(ТипХранилища));
	ИначеЕсли ТипЗнч(ТипХранилища) = Тип("ПеречислениеСсылка.ТипХранилищаСертификатов") Тогда
		Возврат ТипХранилища;	
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ТипХранилища;
	
КонецФункции

Функция ИздателиИлиСубъектыОдинаковые(ИздательИлиСубъект1, ИздательИлиСубъект2)
	
	Для каждого ЭлементИздателяИлиСубъекта1 Из ИздательИлиСубъект1 Цикл
		ЗначениеЭлементаИздателяИлиСубъекта2 = Неопределено;
		Если ЗначениеЗаполнено(ЭлементИздателяИлиСубъекта1.Значение)
			И ИздательИлиСубъект2.Свойство(ЭлементИздателяИлиСубъекта1.Ключ, ЗначениеЭлементаИздателяИлиСубъекта2)
			И ЗначениеЗаполнено(ЗначениеЭлементаИздателяИлиСубъекта2)
			И СокрЛП(ЭлементИздателяИлиСубъекта1.Значение) <> СокрЛП(ЗначениеЭлементаИздателяИлиСубъекта2) Тогда
			
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ПрочитатьПоляRDN(ЧтениеДанных, СвойстваКриптосообщения, КонецБлока)
	
	Результат = Новый Массив;
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < КонецБлока Цикл
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		ИдентификаторПоля = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
		
		Поток = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(Поток);
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока, ЗаписьДанных);
		ЗаписьДанных.Закрыть();
		ДанныеПоля = Поток.ЗакрытьИПолучитьДвоичныеДанные();
		
		СведенияОПоле = Новый Структура;
		СведенияОПоле.Вставить("ИдентификаторПоля", ИдентификаторПоля);
		СведенияОПоле.Вставить("ДанныеПоля", 		ДанныеПоля);
		
		Результат.Добавить(СведенияОПоле);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
//	ДанныеСертификата - ДвоичныеДанные
//
Процедура ДобавитьСертификатПолучателя(ДанныеСертификата, ТипХранилища)
	
	// вызвать менеджер регистра
	КриптографияЭДКО.ДобавитьСертификатПолучателя(ДанныеСертификата, ТипХранилища);
	
КонецПроцедуры

Процедура ДополнитьПодписанта(ТекущийСертификат, Подписанты, РезультатПроверки)
	
	НайденСертификат = Ложь;
	
	МодульСервисКриптографииDSS = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSS");
	СвойстваСертификата = МодульСервисКриптографииDSS.ПолучитьОбъектСертификата(ТекущийСертификат);
	
	Для Каждого СтрокаМассива Из Подписанты Цикл
		Если СвойстваСертификата.Отпечаток = СтрокаМассива.Отпечаток Тогда
			СтрокаМассива.ПодписьВалидна = РезультатПроверки;
			СтрокаМассива.Сертификат = ТекущийСертификат;
			НайденСертификат = Истина;
		КонецЕсли;	
	КонецЦикла;
	
	Если НЕ НайденСертификат Тогда
		НоваяСтрока = Новый Структура;
		НоваяСтрока.Вставить("ПодписьВалидна", РезультатПроверки);
		НоваяСтрока.Вставить("Сертификат", ТекущийСертификат);
		НоваяСтрока.Вставить("Отпечаток", СвойстваСертификата.Отпечаток);
		НоваяСтрока.Вставить("СерийныйНомер", СвойстваСертификата.СерийныйНомер);
		НоваяСтрока.Вставить("Выполнено", Ложь);
		НоваяСтрока.Вставить("Поставщик", ПреобразоватьСтруктуруВСтроку(СвойстваСертификата.Издатель)); // для совместимости
		Подписанты.Добавить(НоваяСтрока);
	КонецЕсли;
	
КонецПроцедуры

#Область ФункцииЧтенияPKCS7

Функция ПрочитатьEnvelopedData(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); 
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	
	СвойстваКриптосообщения.Вставить("Получатели", ПрочитатьRecipientInfos(ЧтениеДанных, СвойстваКриптосообщения, Настройки));
	СвойстваКриптосообщения.Вставить("Тип", "EnvelopedData");
	
	Возврат СвойстваКриптосообщения;

КонецФункции

Функция ПрочитатьSignedData(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	ПотокДанных = Неопределено;
	ЗаписьДанных = Неопределено;
	Если Настройки.ПрочитатьСтруктуру Тогда
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		СвойстваКриптосообщения.Вставить("СвойстваБлокаПодписанныхДанных", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		СвойстваКриптосообщения.Вставить("СвойстваБлокаПолейПодписанныхДанных", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, Свойства, ЗаписьДанных);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		СвойстваКриптосообщения.Вставить("БлокВерсии", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	// DigestAlgorithmIdentifiers
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока, ЗаписьДанных);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		СвойстваКриптосообщения.Вставить("БлокАлгоритмовХеширования", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	Если Настройки.ПрочитатьПодписанныеДанные Тогда
		ПодписанныеДанные = ПрочитатьContentInfo(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			ЗаписьДанных);
		СвойстваКриптосообщения.Вставить("Содержимое", ПодписанныеДанные);
	Иначе
		СвойстваПоследовательности = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		ПропуститьБлок(ЧтениеДанных, СвойстваПоследовательности.РазмерБлока, ЗаписьДанных);
	КонецЕсли;
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		СвойстваКриптосообщения.Вставить("БлокСодержимого", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	
	СвойстваКриптосообщения.Вставить("Сертификаты",
		ПрочитатьCertificates(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			Свойства,
			Настройки,
			ЗаписьДанных,
			ПотокДанных));
	
	СвойстваКриптосообщения.Вставить("СпискиОтзываСертификатов",
		ПрочитатьCertificateRevocationLists(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			Свойства,
			Настройки,
			ЗаписьДанных,
			ПотокДанных));
	
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		СвойстваКриптосообщения.Вставить("СвойстваБлокаПодписантов", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	СвойстваКриптосообщения.Вставить("Подписанты",
		ПрочитатьSignerInfos(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			Свойства,
			Настройки,
			ЗаписьДанных,
			ПотокДанных));
	
	СвойстваКриптосообщения.Вставить("Тип", "SignedData");
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

Функция ПрочитатьAlgorithmIdentifier(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		Свойства = Неопределено,
		ПроверитьТип = Ложь,
		ЗаписьДанных = Неопределено)
	
	Если Свойства = Неопределено Тогда
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	КонецЕсли;
	КонецБлока = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Если ПроверитьТип И (Свойства.Класс <> "UNIVERSAL" ИЛИ Свойства.Тег <> 6) Тогда // algorithm OBJECT IDENTIFIER
		Возврат Неопределено;
	КонецЕсли;
	ИдентификаторАлгоритма = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства, ЗаписьДанных);
	
	ПропуститьБлок(ЧтениеДанных, КонецБлока - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция(), ЗаписьДанных);
	
	ОбъектныеИдентификаторы = Новый Соответствие;
	ОбъектныеИдентификаторы.Вставить("1.2.643.2.2.9", "GOST R 34.11-94");
	ОбъектныеИдентификаторы.Вставить("1.2.643.2.2.19", "GOST R 34.10-2001");
	
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.1.1", "GOST R 34.10-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.1.2", "GOST R 34.10-2012-512");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.2.2", "GOST R 34.11-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.2.3", "GOST R 34.11-2012-512");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.3.2", "GOST R 34.10-2012-256 + GOST R 34.11-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.3.3", "GOST R 34.10-2012-512 + GOST R 34.11-2012-512");
	
	Идентификатор = ОбъектныеИдентификаторы.Получить(ИдентификаторАлгоритма);
	Если Идентификатор = Неопределено Тогда
		Идентификатор = ИдентификаторАлгоритма;
	КонецЕсли;
	
	Возврат Идентификатор;
	
КонецФункции

Функция ПрочитатьIssuerAndSerialNumber(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		КонецБлока,
		ЗаписьДанных = Неопределено)
	
	Издатель = Новый Структура;
	
	// https://tools.ietf.org/html/rfc5652#section-10.2.4
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Граница = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		Идентификатор = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства, ЗаписьДанных);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		Значение = ПрочитатьСтроку(ЧтениеДанных, Свойства, ЗаписьДанных);
		
		Издатель.Вставить("OID" + СтрЗаменить(Идентификатор, ".", "_"), Значение);
	КонецЦикла;
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	
	ИздательСерийныйНомер = Новый Структура;
	ИздательСерийныйНомер.Вставить("СерийныйНомер", ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства, ЗаписьДанных));
	ИздательСерийныйНомер.Вставить("Издатель", Издатель);
	ИздательСерийныйНомер.Вставить("Идентификатор", ИдентификаторСертификата(ИздательСерийныйНомер));
	
	ПропуститьБлок(ЧтениеДанных, КонецБлока - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция(), ЗаписьДанных);
	
	Возврат ИздательСерийныйНомер;
	
КонецФункции

Функция ПрочитатьRecipientInfos(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	Получатели = Новый Массив;
		
	СвойстваНабора = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Граница = СвойстваНабора.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		Получатели.Добавить(ПрочитатьRecipientInfo(ЧтениеДанных, СвойстваКриптосообщения, Настройки));
	КонецЦикла;
	
	Возврат Получатели;
	
КонецФункции

Функция ПрочитатьRecipientInfo(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецБлокаRecipientInfo = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Получатель = ПрочитатьIssuerAndSerialNumber(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
	Иначе
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока);
		Получатель = Новый Структура;
	КонецЕсли;
	
	Если Настройки.ПрочитатьАлгоритмПубличногоКлюча Тогда
		Получатель.Вставить("АлгоритмПубличногоКлюча", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения));
	КонецЕсли;
	ПропуститьБлок(ЧтениеДанных, КонецБлокаRecipientInfo - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	Возврат Получатель;
	
КонецФункции

Функция ПрочитатьContentInfo(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		ЗаписьДанных = Неопределено)
	
	Содержимое = Base64Значение("");
	
	СвойстваПоследовательности = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Если СвойстваПоследовательности.РазмерБлока > 11 Тогда
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		Тип = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства, ЗаписьДанных);
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		Содержимое = ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства, ЗаписьДанных);
	Иначе
		ПропуститьБлок(ЧтениеДанных, СвойстваПоследовательности.РазмерБлока, ЗаписьДанных);
	КонецЕсли;
	
	Возврат Содержимое;
	
КонецФункции

Функция ПрочитатьSignerInfos(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		СвойстваНабора,
		Настройки,
		ЗаписьДанных = Неопределено,
		ПотокДанных = Неопределено)
	
	СертификатыСИдентификаторами = Новый Соответствие;
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Для Каждого Сертификат Из СвойстваКриптосообщения.Сертификаты Цикл
			СертификатыСИдентификаторами.Вставить(ИдентификаторСертификата(Новый Структура("Сертификат", Сертификат)), Сертификат);
		КонецЦикла;
	КонецЕсли;

	Подписанты = Новый Массив;
	
	Граница = СвойстваНабора.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		Подписант = ПрочитатьSignerInfo(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			СертификатыСИдентификаторами,
			Настройки,
			ЗаписьДанных,
			ПотокДанных);
		Подписанты.Добавить(Подписант);
	КонецЦикла;
	
	Возврат Подписанты;
	
КонецФункции

Функция ПрочитатьSignerInfo(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		СертификатыСИдентификаторами,
		Настройки,
		ЗаписьДанных = Неопределено,
		ПотокДанных = Неопределено)
	
	Подписант = Новый Структура;
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		Подписант.Вставить("СвойстваБлокаПолейПодписанта", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	КонецБлокаSignerInfo = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, Свойства, ЗаписьДанных);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		Подписант.Вставить("БлокВерсии", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		ИздательСерийныйНомер = ПрочитатьIssuerAndSerialNumber(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция(),
			ЗаписьДанных);
		
		Подписант.Вставить("Сертификат", ИздательСерийныйНомер);
		
		Сертификат = СертификатыСИдентификаторами.Получить(Подписант.Сертификат.Идентификатор);
		Если ЗначениеЗаполнено(Сертификат) Тогда
			Подписант.Сертификат.Вставить("Сертификат", Сертификат);
		КонецЕсли;
		
	Иначе
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока, ЗаписьДанных);
	КонецЕсли;
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		Подписант.Вставить("БлокИздателяИСерийногоНомера", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	АлгоритмХеширования = ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения,,, ЗаписьДанных);
	Подписант.Вставить("АлгоритмХеширования", АлгоритмХеширования);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		Подписант.Вставить("БлокАлгоритмаХеширования", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	ПодписанныеАтрибуты = ПрочитатьAuthenticatedAttributes(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		Свойства,
		Настройки,
		ЗаписьДанных);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		Подписант.Вставить("БлокАутентифицированныхАтрибутов", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Подписант.Вставить("ПодписанныеАтрибуты", ПодписанныеАтрибуты);
	КонецЕсли;
	
	АлгоритмПодписи = ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения, Свойства,, ЗаписьДанных);
	Подписант.Вставить("АлгоритмПодписи", АлгоритмПодписи);
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		Подписант.Вставить("БлокАлгоритмаПодписи", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	Подпись = ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства, ЗаписьДанных);
	Если Настройки.ПрочитатьПодпись Тогда
		Подписант.Вставить("Подпись", Подпись);
	КонецЕсли;
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		Подписант.Вставить("БлокПодписи", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	НеподписанныеАтрибуты = ПрочитатьUnauthenticatedAttributes(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		Свойства,
		ЗаписьДанных);
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Подписант.Вставить("НеподписанныеАтрибуты", НеподписанныеАтрибуты);
	КонецЕсли;
	Если Настройки.ПрочитатьСтруктуру Тогда
		ЗаписьДанных.Закрыть();
		ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		Подписант.Вставить("БлокНеаутентифицированныхАтрибутов", ПрочитанныеДанные);
		ПотокДанных = Новый ПотокВПамяти();
		ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
	КонецЕсли;
	
	Возврат Подписант;
	
КонецФункции

Функция ПрочитатьCertificates(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		СвойстваБлока,
		Настройки,
		ЗаписьДанных = Неопределено,
		ПотокДанных = Неопределено)
	
	Граница = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Сертификаты = Новый Массив;
	
	// certificates [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 0 Тогда
		Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
			ДанныеСертификатов = ПрочитатьДвоичныеДанные(ЧтениеДанных, СвойстваБлока, ЗаписьДанных);
			РазмерДанныхСертификатов = ДанныеСертификатов.Размер();
			
			ЧтениеДанныхСертификатов = Новый ЧтениеДанных(ДанныеСертификатов);
			
			Пока ЧтениеДанныхСертификатов.ИсходныйПоток().ТекущаяПозиция() < РазмерДанныхСертификатов - 1 Цикл
				ПотокДанныхСертификата = Новый ПотокВПамяти();
				ЗаписьДанныхСертификата = Новый ЗаписьДанных(ПотокДанныхСертификата);
				
				СвойстваБлокаСертификата = ПрочитатьСвойстваБлока(ЧтениеДанныхСертификатов, РазмерДанныхСертификатов,
					ЗаписьДанныхСертификата);
				ПропуститьБлок(ЧтениеДанныхСертификатов, СвойстваБлокаСертификата.РазмерБлока, ЗаписьДанныхСертификата);
				
				ЗаписьДанныхСертификата.Закрыть();
				Сертификат = ПотокДанныхСертификата.ЗакрытьИПолучитьДвоичныеДанные();
				Сертификаты.Добавить(Сертификат);
			КонецЦикла;
			
			ЧтениеДанныхСертификатов.Закрыть();
		КонецЦикла;
		
		Если Настройки.ПрочитатьСтруктуру Тогда
			ЗаписьДанных.Закрыть();
			ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
			СвойстваКриптосообщения.Вставить("БлокСертификатов", ПрочитанныеДанные);
			ПотокДанных = Новый ПотокВПамяти();
			ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	КонецЕсли;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ПрочитатьCertificateRevocationLists(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		СвойстваБлока,
		Настройки,
		ЗаписьДанных = Неопределено,
		ПотокДанных = Неопределено)
	
	Граница = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();

	СпискиОтзываСертификатов = Новый Массив;
	
	// crls  [1] IMPLICIT CertificateRevocationLists OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = Типы().BOOLEAN Тогда
		Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл 
			СписокОтзываСертификатов = ПрочитатьДвоичныеДанные(ЧтениеДанных, СвойстваБлока, ЗаписьДанных);
			СпискиОтзываСертификатов.Добавить(СписокОтзываСертификатов);
		КонецЦикла;
		
		Если Настройки.ПрочитатьСтруктуру Тогда
			ЗаписьДанных.Закрыть();
			ПрочитанныеДанные = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
			СвойстваКриптосообщения.Вставить("БлокСписковОтзывовСертификатов", ПрочитанныеДанные);
			ПотокДанных = Новый ПотокВПамяти();
			ЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	КонецЕсли;
	
	Возврат СпискиОтзываСертификатов;
	
КонецФункции

Функция ПрочитатьAuthenticatedAttributes(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		СвойстваБлока,
		Настройки,
		ЗаписьДанных = Неопределено)
	
	ПодписанныеАтрибуты = Новый Структура;
	СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	
	// authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 0 Тогда
		ГраницаБлока = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
		Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
			Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < ГраницаБлока Цикл
				СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
				КонецБлока = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() + СвойстваБлока.РазмерБлока;
				СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
				Идентификатор = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, СвойстваБлока, ЗаписьДанных);
				Если Идентификатор = "1.2.840.113549.1.9.5" Тогда // signingTime
					ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
					СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
					ПодписанныеАтрибуты.Вставить("ВремяПодписания", ПрочитатьДату(ЧтениеДанных, СвойстваБлока, ЗаписьДанных));
				Иначе
					ПропуститьДо(ЧтениеДанных, КонецБлока, ЗаписьДанных);
				КонецЕсли;
			КонецЦикла;
			
		Иначе
			ПропуститьДо(ЧтениеДанных, ГраницаБлока, ЗаписьДанных);
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	КонецЕсли;
	
	Возврат ПодписанныеАтрибуты;
	
КонецФункции

Функция ПрочитатьUnauthenticatedAttributes(
		ЧтениеДанных,
		СвойстваКриптосообщения,
		СвойстваБлока,
		ЗаписьДанных = Неопределено)
	
	НеподписанныеАтрибуты = Новый Структура;
	
	Если ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() >= СвойстваКриптосообщения.Размер Тогда
		Возврат НеподписанныеАтрибуты;
	КонецЕсли;
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
	
	// unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = Типы().BOOLEAN Тогда
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер, ЗаписьДанных);
		ПропуститьБлок(ЧтениеДанных, СвойстваБлока.РазмерБлока, ЗаписьДанных);
	КонецЕсли;
	
	Возврат НеподписанныеАтрибуты;
	
КонецФункции

#КонецОбласти

#Область БазовыеФункцииЧтенияASN1

Функция ПрочитатьДату(ЧтениеДанных, Свойства, ЗаписьДанных = Неопределено)
	
	Если Свойства.Тег = 23 Тогда // UTCTime https://www.obj-sys.com/asn1tutorial/node15.html
		Возврат Дата("20" + Сред(ПрочитатьСтроку(ЧтениеДанных, Свойства, ЗаписьДанных), 1, 12));
	Иначе
		Возврат '0001-01-01';
	КонецЕсли;
	
КонецФункции

Функция ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства, ЗаписьДанных = Неопределено)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Если ЗаписьДанных <> Неопределено Тогда
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	Поток = Новый ПотокВПамяти(Буфер);
	
	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
КонецФункции

Функция ПрочитатьСтроку(ЧтениеДанных, Свойства, ЗаписьДанных = Неопределено)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Если ЗаписьДанных <> Неопределено Тогда
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	Поток = Новый ПотокВПамяти(Буфер);
	
	Если Свойства.Тег = 30 Тогда // BMPString
		Кодировка = "utf-16";
	ИначеЕсли Свойства.Тег = 28 Тогда // UniversalString
		Кодировка = "utf-32";
	Иначе
		Кодировка = "utf-8";
	КонецЕсли;
	
	ЧтениеТекста = Новый ЧтениеТекста(Поток, Кодировка);
	Строка = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	Поток.Закрыть();
	
	// Дополнительная защита от ошибок сериализации из-за нечитаемых символов
	Возврат ОбщегоНазначенияЭДКОКлиентСервер.ЗаменитьНечитаемыеСимволы(Строка);
	
КонецФункции

Функция ПрочитатьЦелоеЧисло(ЧтениеДанных, Свойства, ЗаписьДанных = Неопределено)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Если ЗаписьДанных <> Неопределено Тогда
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	Значение = 0;
	Для Каждого Байт Из Буфер Цикл
		Значение = Значение * 256 + Байт;
	КонецЦикла;
	
	Возврат Значение;
	
КонецФункции

Функция ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства, ЗаписьДанных = Неопределено)
	
	ОбъектныйИдентификатор = Новый Массив;
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Если ЗаписьДанных <> Неопределено Тогда
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	Если Буфер[0] < 40 Тогда
		SID1 = 0;
	ИначеЕсли Буфер[0] < 80 Тогда
		SID1 = 1;
	Иначе
		SID1 = 2;
	КонецЕсли;
	ОбъектныйИдентификатор.Добавить(Формат(SID1, "ЧРГ=; ЧГ="));
	
	// SID2
	ОбъектныйИдентификатор.Добавить(Буфер[0] - SID1 * 40);
	
	// Остальные SID
	Для Индекс = 1 По Буфер.Размер - 1 Цикл
		СоставляющаяОбъектногоИдентификатора = ПрочитатьСоставляющуюОбъектногоИдентификатора(Буфер, Индекс);
		ОбъектныйИдентификатор.Добавить(Формат(СоставляющаяОбъектногоИдентификатора, "ЧРГ=; ЧГ="));
	КонецЦикла;
	
	Возврат СтрСоединить(ОбъектныйИдентификатор, ".");
	
КонецФункции

Функция ПрочитатьСоставляющуюОбъектногоИдентификатора(Буфер, ТекущийБайт)
	
	МаскаЗначащиеБиты = 127; // 0111 1111
	МаскаСтаршийБит = 128;   // 1000 0000
	
	Множители = Новый Массив;
	Пока Истина Цикл
		Байт = Буфер[ТекущийБайт];
		ДлинныйРазмер = Булево(ОперацияПобитовоеИ(Буфер[ТекущийБайт], МаскаСтаршийБит));
		Если ДлинныйРазмер Тогда
			Множители.Добавить(ОперацияПобитовоеИ(Буфер[ТекущийБайт], МаскаЗначащиеБиты))
		Иначе
			Множители.Добавить(Байт);
			Прервать;
		КонецЕсли;
		
		ТекущийБайт = ТекущийБайт + 1;
		Если ТекущийБайт > Буфер.Размер Тогда
			ВызватьИсключение("Ошибка разбора OID");
		КонецЕсли;
	КонецЦикла;
	
	Результат = 0;
	Для Индекс = 0 По Множители.ВГраница() Цикл
		Показатель = Множители.ВГраница() - Индекс;
		Результат = Результат + Множители[Индекс] * Pow(128, Показатель);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьНаименованиеСертификата(МассивOID) Экспорт
	
	Наименование = "";
	
	Для Каждого ЭлементOID Из МассивOID Цикл
		Если ЭлементOID.oid = "OID2_5_4_3" Тогда
			Наименование = ОбщегоНазначенияЭДКОКлиентСерверПовтИсп.ЗаменитьНечитаемыеСимволы2(ЭлементOID.value);
			Возврат Наименование;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементOID Из МассивOID Цикл
		Если ЭлементOID.oid = "CN" Тогда
			Наименование = ОбщегоНазначенияЭДКОКлиентСерверПовтИсп.ЗаменитьНечитаемыеСимволы2(ЭлементOID.value);
			Возврат Наименование;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Наименование;
	
КонецФункции

Функция ПреобразоватьМассивOIDВСтруктуру(МассивOID) Экспорт
	
	СоответствиеOID = СоответствиеOIDИмя();
	
	Результат = Новый Структура;
	
	Для Каждого ЭлементOID Из МассивOID Цикл
		Если СтрНачинаетсяС(ЭлементOID.oid, "OID") Тогда
			OID = СоответствиеOID.Получить(Сред(ЭлементOID.oid, 4));
			Если OID = Неопределено Тогда
				OID = ЭлементOID.oid;
			КонецЕсли;
			Результат.Вставить(OID, ОбщегоНазначенияЭДКОКлиентСерверПовтИсп.ЗаменитьНечитаемыеСимволы2(ЭлементOID.value));
		КонецЕсли;
	КонецЦикла;
	
	МассивИмен = Новый Массив;
	Для каждого ЭлементСоответствия Из СоответствиеOID Цикл
		МассивИмен.Добавить(ЭлементСоответствия.Значение);
	КонецЦикла;
	
	Для каждого ЭлементOID Из МассивOID Цикл
		Если НЕ СтрНачинаетсяС(ЭлементOID.oid, "OID") Тогда
			ИмяЭлемента = СокрЛП(ЭлементOID.oid);
			ИндексИмени = МассивИмен.Найти(ИмяЭлемента);
			Если ИндексИмени = Неопределено Тогда
				ИмяЭлемента = ВРег(ИмяЭлемента);
				ИндексИмени = МассивИмен.Найти(ИмяЭлемента);
			КонецЕсли;
			Если ИндексИмени <> Неопределено Тогда
				ИмяЭлемента = МассивИмен[ИндексИмени];
				Если НЕ Результат.Свойство(ИмяЭлемента) Тогда
					Результат.Вставить(ИмяЭлемента, ОбщегоНазначенияЭДКОКлиентСерверПовтИсп.ЗаменитьНечитаемыеСимволы2(ЭлементOID.value));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПреобразоватьСтруктуруВСтроку(Структура) Экспорт
	
	Компоненты = Новый Массив;
	Для Каждого КлючЗначение Из Структура Цикл
		Компоненты.Добавить(СтрШаблон("%1=%2", КлючЗначение.Ключ, КлючЗначение.Значение));
	КонецЦикла;
	
	Возврат СтрСоединить(Компоненты, ",");
	
КонецФункции

Функция СоответствиеOIDИмя()
	
	СоответствиеOID = Новый Соответствие;
	СоответствиеOID.Вставить("2_5_4_3", "CN"); // commonName
	СоответствиеOID.Вставить("2_5_4_6", "C"); // countryName
	СоответствиеOID.Вставить("2_5_4_8", "ST"); // stateOrProvinceName
	СоответствиеOID.Вставить("2_5_4_7", "L"); // localityName
	СоответствиеOID.Вставить("2_5_4_9", "STREET"); // streetAddress
	СоответствиеOID.Вставить("2_5_4_10", "O"); // organizationName
	СоответствиеOID.Вставить("2_5_4_11", "OU"); // organizationUnitName
	СоответствиеOID.Вставить("2_5_4_12", "T"); // title
	СоответствиеOID.Вставить("1_2_643_100_1", "OGRN"); // ОГРН
	СоответствиеOID.Вставить("1_2_643_100_5", "OGRNIP"); // ОГРНИП
	СоответствиеOID.Вставить("1_2_643_100_3", "SNILS"); // СНИЛС
	СоответствиеOID.Вставить("1_2_643_3_131_1_1", "INN"); // ИНН (ФЛ)
	СоответствиеOID.Вставить("1_2_840_113549_1_9_1", "E"); // emailAddress	
	СоответствиеOID.Вставить("2_5_4_4", "SN"); // surname
	СоответствиеOID.Вставить("2_5_4_42", "GN"); // givenName
	СоответствиеOID.Вставить("1_2_643_100_4", "INNLE"); // ИНН ЮЛ
	
	Возврат СоответствиеOID;
	
КонецФункции

Функция СоответствиеOIDТип()
	
	ТипыASN = Типы();
	СоответствиеOID = Новый Соответствие;
	СоответствиеOID.Вставить("2_5_4_3", 				ТипыASN.UTF8String); // commonName
	СоответствиеOID.Вставить("2_5_4_6", 				ТипыASN.PrintableString); // countryName
	СоответствиеOID.Вставить("2_5_4_8", 				ТипыASN.UTF8String); // stateOrProvinceName
	СоответствиеOID.Вставить("2_5_4_7", 				ТипыASN.UTF8String); // localityName
	СоответствиеOID.Вставить("2_5_4_9", 				ТипыASN.UTF8String); // streetAddress
	СоответствиеOID.Вставить("2_5_4_10", 				ТипыASN.UTF8String); // organizationName
	СоответствиеOID.Вставить("2_5_4_11", 				ТипыASN.UTF8String); // organizationUnitName
	СоответствиеOID.Вставить("2_5_4_12", 				ТипыASN.BMPString); // title
	СоответствиеOID.Вставить("1_2_643_100_1", 			ТипыASN.NumericString); // ОГРН
	СоответствиеOID.Вставить("1_2_643_100_5", 			ТипыASN.NumericString); // ОГРНИП
	СоответствиеOID.Вставить("1_2_643_100_3", 			ТипыASN.NumericString); // СНИЛС
	СоответствиеOID.Вставить("1_2_643_3_131_1_1", 		ТипыASN.NumericString); // ИНН (ФЛ)
	СоответствиеOID.Вставить("1_2_840_113549_1_9_1", 	ТипыASN.IA5String); // emailAddress	
	СоответствиеOID.Вставить("2_5_4_4", 				ТипыASN.BMPString); // surname
	СоответствиеOID.Вставить("2_5_4_42", 				ТипыASN.BMPString); // givenName
	СоответствиеOID.Вставить("1_2_643_100_4", 			ТипыASN.NumericString); // ИНН ЮЛ
	
	Возврат СоответствиеOID;
	
КонецФункции

Функция ЭтоОблачныйСертификат(Сертификат) Экспорт

	Если ЭлектроннаяПодписьВМоделиСервиса.ИспользованиеВозможно() Тогда
		Попытка
			СервисКриптографии.ПолучитьНастройкиПолученияВременныхПаролей(Сертификат.Идентификатор);
			Возврат Истина;
		Исключение
			ТекстИсключения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			Если СтрНайти(ТекстИсключения, "InvalidCertificateIdError") Тогда
				Возврат Ложь;
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецПопытки;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция КлассТегаБлока(Байт)

	МаскаКлассБлока = 192; // 1100 0000
	Класс = ОперацияПобитовоеИ(Байт, МаскаКлассБлока);
	
	Если Класс = 0 Тогда
		Возврат "UNIVERSAL";
	ИначеЕсли Класс = 192 Тогда
		Возврат "PRIVATE";
	ИначеЕсли Класс = 64 Тогда
		Возврат "APPLICATION";
	Иначе
		Возврат "CONTEXT-SPECIFIC";
	КонецЕсли;

КонецФункции

Функция ЭтоСоставнойБлок(Байт)
	
	МаскаТег = 32; // 0010 0000
	Возврат ОперацияПобитовоеИ(Байт, МаскаТег) = МаскаТег;
	
КонецФункции

Функция ТегБлока(Байт)
	
	МаскаТег = 31; // 0001 1111
	Возврат ОперацияПобитовоеИ(Байт, МаскаТег);

КонецФункции

Функция ПрочитатьСвойстваБлока(ЧтениеДанных, РазмерДанных = Неопределено, ЗаписьДанных = Неопределено)
	
	Если ТипЗнч(ЧтениеДанных) = Тип("ДвоичныеДанные") Тогда
		ЧтениеДанныхОбъект = Новый ЧтениеДанных(ЧтениеДанных);
		РазмерДанныхОбъекта = ?(РазмерДанных = Неопределено, ЧтениеДанных.Размер(), РазмерДанных);
	Иначе
		ЧтениеДанныхОбъект = ЧтениеДанных;
		РазмерДанныхОбъекта = РазмерДанных;
	КонецЕсли;
	
	Свойства = СвойстваБлока();
	
	Буфер = ЧтениеДанныхОбъект.ПрочитатьВБуферДвоичныхДанных(1);
	Если ЗаписьДанных <> Неопределено Тогда
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	
	МаскаЗначащиеБиты = 127; // 0111 1111
	МаскаСтаршийБит = 128;   // 1000 0000
	
	Свойства.Класс = КлассТегаБлока(Буфер[0]);
	Свойства.ЭтоСоставнойБлок = ЭтоСоставнойБлок(Буфер[0]);
	Свойства.Тег = ТегБлока(Буфер[0]);
	
	// Прочитать размер блока
	Буфер = ЧтениеДанныхОбъект.ПрочитатьВБуферДвоичныхДанных(1);
	Если ЗаписьДанных <> Неопределено Тогда
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	Если Буфер[0] = 128 Тогда // Используется потоковый способ кодирования, т.е. размер блока не указан (окончание блока 00 00)
		РазмерБлока = -1;
	Иначе
		ДлинныйРазмер = Булево(ОперацияПобитовоеИ(Буфер[0], МаскаСтаршийБит));
		Если ДлинныйРазмер Тогда
			КоличествоБайтовПодРазмер = ОперацияПобитовоеИ(Буфер[0], МаскаЗначащиеБиты);
			Буфер = ЧтениеДанныхОбъект.ПрочитатьВБуферДвоичныхДанных(КоличествоБайтовПодРазмер);
			Если ЗаписьДанных <> Неопределено Тогда
				ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
			КонецЕсли;
			РазмерБлока = 0;
			Для Каждого Байт Из Буфер Цикл
				РазмерБлока = РазмерБлока * 256 + Байт;
				
				Если РазмерБлока > РазмерДанныхОбъекта Тогда
					ВызватьИсключение("Размер блока превышает размер файла");
				КонецЕсли;
			КонецЦикла;
		Иначе
			РазмерБлока = ОперацияПобитовоеИ(Буфер[0], МаскаЗначащиеБиты);	
		КонецЕсли;
	КонецЕсли;
	
	Если РазмерБлока > РазмерДанныхОбъекта Тогда
		ВызватьИсключение("Размер блока превышает размер файла");
	КонецЕсли;
	
	Свойства.РазмерБлока = РазмерБлока;
	
	Возврат Свойства;
	
КонецФункции

Процедура ПропуститьБлок(ЧтениеДанных, СколькоБайт, ЗаписьДанных = Неопределено)
	
	Если СколькоБайт = -1 Тогда
		МаксимальнаяДлинаВЗаголовке = 8192;
		НомерБайта = 1;
		Пока Истина Цикл
			Пока Истина Цикл
				Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
				Если Буфер.Размер = 0 ИЛИ НомерБайта > МаксимальнаяДлинаВЗаголовке Тогда
					Возврат;
				КонецЕсли;
				Если ЗаписьДанных <> Неопределено Тогда
					ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
				КонецЕсли;
				НомерБайта = НомерБайта + 1;
				Если Буфер[0] = 0 Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
			Если Буфер.Размер = 0 ИЛИ НомерБайта > МаксимальнаяДлинаВЗаголовке Тогда
				Возврат;
			КонецЕсли;
			Если ЗаписьДанных <> Неопределено Тогда
				ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
			КонецЕсли;
			НомерБайта = НомерБайта + 1;
			Если Буфер[0] = 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли ЗаписьДанных = Неопределено ИЛИ СколькоБайт = 0 Тогда
		ЧтениеДанных.Пропустить(СколькоБайт);
		
	Иначе
		Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(СколькоБайт);
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПропуститьДо(ЧтениеДанных, Граница, ЗаписьДанных = Неопределено)
	
	ТекущаяПозиция = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Если ТекущаяПозиция >= Граница Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗаписьДанных = Неопределено Тогда
		ЧтениеДанных.Пропустить(Граница - ТекущаяПозиция);
	Иначе
		Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Граница - ТекущаяПозиция);
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(Буфер);
	КонецЕсли;
	
КонецПроцедуры

Функция ОперацияПобитовоеИ(Байт1, Байт2)
	
	Буфер1 = БуферИзБайта(Байт1);
	Буфер2 = БуферИзБайта(Байт2);
	Буфер1.ЗаписатьПобитовоеИ(0, Буфер2);
	
	Возврат Буфер1[0];
	
КонецФункции

Функция БуферИзБайта(Байт)
	
	Буфер = Новый БуферДвоичныхДанных(1);
	Буфер[0] = Байт;
	
	Возврат Буфер;
	
КонецФункции

#КонецОбласти

#Область БазовыеФункцииЗаписиASN1

Функция СвойстваБлока()
	
	Результат = Новый Структура;
	Результат.Вставить("Класс", 			"UNIVERSAL");
	Результат.Вставить("ЭтоСоставнойБлок", 	Ложь);
	Результат.Вставить("Тег", 				0);
	Результат.Вставить("РазмерБлока", 		0);
	
	Возврат Результат;
	
КонецФункции

Процедура ЗаписатьСтроку(ЗаписьДанных, Значение, ТипASN)
	
	ТипыASN = Типы();
	КодировкаЗначения = ?(ТипASN = ТипыASN.IA5String ИЛИ ТипASN = ТипыASN.UTF8String, "utf-8",
		?(ТипASN = ТипыASN.NumericString ИЛИ ТипASN = ТипыASN.PrintableString, "windows-1251",
		?(ТипASN = ТипыASN.BMPString, "utf-16", ТипASN)));
	
	ЗаписьДанных.ЗаписатьБайт(ТипASN);
	ДанныеЗначения = ПолучитьДвоичныеДанныеИзСтроки(Значение, КодировкаЗначения);
	ДлинаЗначения = ДанныеЗначения.Размер();
	ЗаписатьРазмерБлока(ЗаписьДанных, ДлинаЗначения);
	БуферДанныхЗначения = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДанныеЗначения);
	ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(БуферДанныхЗначения);
	
КонецПроцедуры

Процедура ЗаписатьРазмерБлока(ЗаписьДанных, РазмерБлока)
	
	Если РазмерБлока < 128 Тогда
		ЗаписьДанных.ЗаписатьБайт(РазмерБлока);
		
	Иначе
		МассивБайт = Новый Массив;
		ЗаписываемоеЧисло = РазмерБлока;
		Пока ЗаписываемоеЧисло <> 0 Цикл
			МассивБайт.Добавить(ЗаписываемоеЧисло % 256);
			ЗаписываемоеЧисло = Цел(ЗаписываемоеЧисло / 256);
		КонецЦикла;
		
		КоличествоБайт = МассивБайт.Количество();
		ЗаписьДанных.ЗаписатьБайт(128 + КоличествоБайт);
		Для ИндексБайтаСКонца = 0 По КоличествоБайт - 1 Цикл
			ЗаписьДанных.ЗаписатьБайт(МассивБайт[КоличествоБайт - ИндексБайтаСКонца - 1]);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьСвойстваБлока(ЗаписьДанных, СвойстваБлока, РазмерБлока = Неопределено)
	
	Если ТипЗнч(СвойстваБлока) = Тип("ДвоичныеДанные") Тогда
		ЧтениеДанных = Новый ЧтениеДанных(СвойстваБлока);
		Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
		РазмерБлокаДанных = РазмерБлока;
		
	Иначе
		Буфер = ?(СвойстваБлока.Класс = "UNIVERSAL", 0, ?(СвойстваБлока.Класс = "PRIVATE", 192,
			?(СвойстваБлока.Класс = "APPLICATION", 64, 128))) + ?(СвойстваБлока.ЭтоСоставнойБлок, 32, 0) + СвойстваБлока.Тег;
		Буфер = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Буфер);
		РазмерБлокаДанных = ?(РазмерБлока = Неопределено, СвойстваБлока.РазмерБлока, РазмерБлока);
	КонецЕсли;
	
	ЗаписьДанных.ЗаписатьБайт(Буфер[0]);
	
	ЗаписатьРазмерБлока(ЗаписьДанных, РазмерБлокаДанных);
	
КонецПроцедуры

Процедура ЗаписатьОбъектныйИдентификатор(ЗаписьДанных, Значение)
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанныхОбъект = Новый ЗаписьДанных(ПотокДанных);
	
	МассивЗначения = СтрРазделить(Значение, ".");
	
	ЗаписьДанныхОбъект.ЗаписатьБайт(Число(МассивЗначения[0]) * 40 + Число(МассивЗначения[1]));
	
	Для ИндексМассива = 2 По МассивЗначения.Количество() - 1 Цикл
		ЭлементМассива = Число(МассивЗначения[ИндексМассива]);
		
		МассивБайт = Новый Массив;
		Пока ЭлементМассива <> 0 Цикл
			МассивБайт.Добавить(ЭлементМассива % 128);
			ЭлементМассива = Цел(ЭлементМассива / 128);
		КонецЦикла;
		
		Для ИндексБайтаСКонца = 0 По МассивБайт.Количество() - 1 Цикл
			ЗаписьДанныхОбъект.ЗаписатьБайт(?(ИндексБайтаСКонца = МассивБайт.Количество() - 1, 0, 128)
				+ МассивБайт[МассивБайт.Количество() - ИндексБайтаСКонца - 1]);
		КонецЦикла;
	КонецЦикла;
	
	ЗаписьДанныхОбъект.Закрыть();
	БлокПоля = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	СвойстваБлока = СвойстваБлока();
	СвойстваБлока.Тег = Типы().OBJECT_IDENTIFIER;
	СвойстваБлока.РазмерБлока = БлокПоля.Размер();
	ЗаписатьСвойстваБлока(ЗаписьДанных, СвойстваБлока);
	ЗаписьДанных.Записать(БлокПоля);
	
КонецПроцедуры

Процедура ЗаписатьUnauthenticatedAttributes(ЗаписьДанных, ШтампВремени)
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанныхОбъект = Новый ЗаписьДанных(ПотокДанных);
	СвойстваБлока = СвойстваБлока();
	СвойстваБлока.ЭтоСоставнойБлок = Истина;
	СвойстваБлока.Тег = Типы().SET;
	СвойстваБлока.РазмерБлока = ШтампВремени.Размер();
	ЗаписатьСвойстваБлока(ЗаписьДанныхОбъект, СвойстваБлока);
	ЗаписьДанныхОбъект.Записать(ШтампВремени);
	ЗаписьДанныхОбъект.Закрыть();
	БлокСодержимоеШтампаВремени = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанныхОбъект = Новый ЗаписьДанных(ПотокДанных);
	ЗаписатьОбъектныйИдентификатор(ЗаписьДанныхОбъект, "1.2.840.113549.1.9.16.2.14");
	ЗаписьДанныхОбъект.Записать(БлокСодержимоеШтампаВремени);
	ЗаписьДанныхОбъект.Закрыть();
	БлокПоляШтампаВремени = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	ПотокДанных = Новый ПотокВПамяти();
	ЗаписьДанныхОбъект = Новый ЗаписьДанных(ПотокДанных);
	СвойстваБлока = СвойстваБлока();
	СвойстваБлока.ЭтоСоставнойБлок = Истина;
	СвойстваБлока.Тег = Типы().SEQUENCE;
	СвойстваБлока.РазмерБлока = БлокПоляШтампаВремени.Размер();
	ЗаписатьСвойстваБлока(ЗаписьДанныхОбъект, СвойстваБлока);
	ЗаписьДанныхОбъект.Записать(БлокПоляШтампаВремени);
	ЗаписьДанныхОбъект.Закрыть();
	БлокШтампаВремени = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
	
	СвойстваБлока = СвойстваБлока();
	СвойстваБлока.Класс = "CONTEXT-SPECIFIC";
	СвойстваБлока.ЭтоСоставнойБлок = Истина;
	СвойстваБлока.Тег = Типы().BOOLEAN;
	СвойстваБлока.РазмерБлока = БлокШтампаВремени.Размер();
	ЗаписатьСвойстваБлока(ЗаписьДанных, СвойстваБлока);
	ЗаписьДанных.Записать(БлокШтампаВремени);
	
КонецПроцедуры

#КонецОбласти

Функция ПрочитатьOID2_5_29_14(ОбъектЧтениеДанных, СвойстваСертификата)

	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	
	Если ПропуститьИлиПрервать(СвойстваБлока, ОбъектЧтениеДанных, СвойстваСертификата) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	Если НужноПрерватьЧтениеДляOCTET_STRING(СвойстваБлока, ОбъектЧтениеДанных) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Буфер = ОбъектЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(СвойстваБлока.РазмерБлока);
	СвойстваСертификата.ИдентификаторКлючаСубъекта = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
	Возврат Истина;
	
КонецФункции

Функция ПрочитатьOID2_5_29_35(ОбъектЧтениеДанных, СвойстваСертификата)
	
	// Считываем и пропускаем заголовок
	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	
	Если ПропуститьИлиПрервать(СвойстваБлока, ОбъектЧтениеДанных, СвойстваСертификата) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Считываем блок данных, он состоит из 3х частей.
	// Пример блока:
	// [0]Идентификатор ключа=287325ed497f71188834f67de3a08edb6f1879e2
	// [1]Поставщик сертификата:
	//     Адрес каталога:
	//          ОГРН=1024001434049
	//          ИНН=004029017981
	//          STREET="пер. Теренинский, д. 6"
	//          E=ca@astralnalog.ru
	//          L=Калуга
	//          S=40 Калужская область
	//          C=RU
	//          O="АО ""КАЛУГА АСТРАЛ"""
	//          CN="Тестовый УЦ АО ""КАЛУГА АСТРАЛ"""
	// [2]Серийный номер сертификата=01d700733eb5cd600000001903410002

	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = Типы().SEQUENCE Тогда
		
		КонецБлока = ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() + СвойстваБлока.РазмерБлока;
		
		// Считываем блок идентификатора ключа
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Буфер = ОбъектЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(СвойстваБлока.РазмерБлока);
		СвойстваСертификата.ИдентификаторКлючаУЦ = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
		
		Если ДостиглиКонцаБлока(ОбъектЧтениеДанных, КонецБлока) Тогда
			Возврат Истина;
		КонецЕсли;
		
		// Пропускаем блок "Поставщик сертификата"
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		ОбъектЧтениеДанных.Пропустить(СвойстваБлока.РазмерБлока);
		
		Если ДостиглиКонцаБлока(ОбъектЧтениеДанных, КонецБлока) Тогда
			Возврат Истина;
		КонецЕсли;
		
		// Считываем с серийным номером сертификата УЦ
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Буфер = ОбъектЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(СвойстваБлока.РазмерБлока);
		СвойстваСертификата.СерийныйНомерСертификатаУЦ = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
		
	КонецЕсли;

	Возврат Истина;
	
КонецФункции

Функция ДостиглиКонцаБлока(ОбъектЧтениеДанных, КонецБлока)
	
	ТекущаяПозиция = ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Возврат ТекущаяПозиция >= КонецБлока;
	
КонецФункции

Функция ПрочитатьOID1_2_643_100_114(ОбъектЧтениеДанных, СвойстваСертификата)

	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	
	Если ПропуститьИлиПрервать(СвойстваБлока, ОбъектЧтениеДанных, СвойстваСертификата) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = Типы().INTEGER Тогда
		ТипИдентификации = ПрочитатьЦелоеЧисло(ОбъектЧтениеДанных, СвойстваБлока);
		СвойстваСертификата.Вставить("ТипИдентификации", ТипИдентификации);
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция ПрочитатьOID1_2_643_100_111(ОбъектЧтениеДанных, СвойстваСертификата)
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	
	Если ПропуститьИлиПрервать(СвойстваБлока, ОбъектЧтениеДанных, СвойстваСертификата) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = Типы().UTF8String Тогда
		ИмяКриптопровайдера = ПрочитатьСтроку(ОбъектЧтениеДанных, СвойстваБлока);
		ИмяКриптопровайдера = нрег(ИмяКриптопровайдера);
		Если СтрНайти(ИмяКриптопровайдера, "cryptopro") > 0 ИЛИ СтрНайти(ИмяКриптопровайдера, "криптопро") > 0 Тогда
			СвойстваСертификата.ТипКриптопровайдераВладельца = Перечисления.ТипыКриптоПровайдеров.CryptoPro;
		ИначеЕсли СтрНайти(ИмяКриптопровайдера, "vipnet") > 0 ИЛИ СтрНайти(ИмяКриптопровайдера, "випнет") > 0 Тогда
			СвойстваСертификата.ТипКриптопровайдераВладельца = Перечисления.ТипыКриптоПровайдеров.VipNet;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;

КонецФункции

Функция ПрочитатьOID2_5_29_16(ОбъектЧтениеДанных, СвойстваСертификата)
	
	// Считываем и пропускаем заголовок
	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	
	Если ПропуститьИлиПрервать(СвойстваБлока, ОбъектЧтениеДанных, СвойстваСертификата) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = Типы().SEQUENCE Тогда
		КонецБлока = ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() + СвойстваБлока.РазмерБлока;
		Если ДостиглиКонцаБлока(ОбъектЧтениеДанных, КонецБлока) Тогда
			Возврат Истина;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Буфер = ОбъектЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(СвойстваБлока.РазмерБлока);
		КлючДействителенС = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер);
		КлючДействителенС = ?(ЗначениеЗаполнено(КлючДействителенС),
			ДокументооборотСКОВызовСервера.ДатаИзСтрокиРазныхФорматов(КлючДействителенС), "");
		Если ТипЗнч(КлючДействителенС) = Тип("Дата") Тогда
			СвойстваСертификата.КлючДействителенС = МестноеВремя(КлючДействителенС);
		КонецЕсли;
		Если ДостиглиКонцаБлока(ОбъектЧтениеДанных, КонецБлока) Тогда
			Возврат Истина;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Буфер = ОбъектЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(СвойстваБлока.РазмерБлока);
		КлючДействителенПо = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер);
		КлючДействителенПо = ?(ЗначениеЗаполнено(КлючДействителенПо),
			ДокументооборотСКОВызовСервера.ДатаИзСтрокиРазныхФорматов(КлючДействителенПо), "");
		Если ТипЗнч(КлючДействителенПо) = Тип("Дата") Тогда
			СвойстваСертификата.КлючДействителенПо = МестноеВремя(КлючДействителенПо);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция ПропуститьИлиПрервать(СвойстваБлока, ОбъектЧтениеДанных, СвойстваСертификата)

	Нужно = Ложь;
	ПропуститьПриНеобходимости(СвойстваБлока, ОбъектЧтениеДанных, СвойстваСертификата);
	
	Если НужноПрерватьЧтениеДляOCTET_STRING(СвойстваБлока, ОбъектЧтениеДанных) Тогда
		Нужно = Истина;
	КонецЕсли;
	
	Возврат Нужно;
	
КонецФункции

Функция ПропуститьПриНеобходимости(СвойстваБлока, ОбъектЧтениеДанных, СвойстваСертификата)
	
	Нужно = Ложь;
	Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = Типы().BOOLEAN Тогда
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		Нужно = Истина;
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
	КонецЕсли;
	
	Возврат Нужно;
					
КонецФункции

Функция НужноПрерватьЧтениеДляOCTET_STRING(СвойстваБлока, ОбъектЧтениеДанных)
	
	Тип   = Типы().OCTET_STRING;
	Нужно = НужноПрерватьЧтениеДляТипа(СвойстваБлока, ОбъектЧтениеДанных, Тип);
	
	Возврат Нужно;
					
КонецФункции

Функция НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлока, ОбъектЧтениеДанных)
	
	Тип   = Типы().SEQUENCE;
	Нужно = НужноПрерватьЧтениеДляТипа(СвойстваБлока, ОбъектЧтениеДанных, Тип);
	
	Возврат Нужно;
					
КонецФункции

Функция НужноПрерватьЧтениеДляТипа(СвойстваБлока, ОбъектЧтениеДанных, Тип)
	
	Нужно = Ложь;
	Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> Тип Тогда
		Нужно = Истина;
		ОбъектЧтениеДанных.Закрыть();
	КонецЕсли;
	
	Возврат Нужно;
					
КонецФункции

Функция Типы()
	
	// ASN.1
	
	Типы = Новый Структура;
	Типы.Вставить("BOOLEAN", 			1);
	Типы.Вставить("INTEGER", 			2);
	Типы.Вставить("BIT_STRING", 		3); // Модель двоичных данных произвольной длины
	Типы.Вставить("OCTET_STRING", 		4); // Модель двоичных данных, чья длина кратна 8
	Типы.Вставить("NULL", 				5);
	Типы.Вставить("OBJECT_IDENTIFIER", 	6);
	Типы.Вставить("ObjectDescriptor", 	7);
	Типы.Вставить("INSTANCE", 			8);
	Типы.Вставить("REAL", 				9);
	Типы.Вставить("ENUMERATED", 		10); // Модель данных с минимум 3мя состояниями
	Типы.Вставить("EMBEDDED_PDV", 		11);
	Типы.Вставить("UTF8String", 		12);
	Типы.Вставить("RELATIVE_OID", 		13);
	Типы.Вставить("SEQUENCE", 			16);
	Типы.Вставить("SET", 				17);
	Типы.Вставить("NumericString", 		18);
	Типы.Вставить("PrintableString", 	19);
	Типы.Вставить("TeletexString", 		20);
	Типы.Вставить("VideotexString", 	21);
	Типы.Вставить("IA5String", 			22); // Произвольная строка символов IA5 (ASCII)
	Типы.Вставить("UTCTime", 			23);
	Типы.Вставить("GeneralizedTime", 	24);
	Типы.Вставить("GraphicString", 		25);
	Типы.Вставить("VisibleString", 		26);
	Типы.Вставить("GeneralString", 		27);
	Типы.Вставить("UniversalString", 	28);
	Типы.Вставить("CHARACTER_STRING", 	29);
	Типы.Вставить("BMPString", 			30);
	
	Возврат Типы;
	
КонецФункции

Функция ПолучитьСвойстваСертификатаЕслиВозможенФорматBase64(Знач ДвДанные, НастройкиВызова, СвойстваСертификата)
	
	НастройкиВызова.ЭтоСтрокаBase64 		= Ложь;
	НастройкиВызова.ВозможенФорматBase64 	= Ложь;
	СвойстваСертификата = ПолучитьСвойстваСертификата(ДвДанные, НастройкиВызова);
	
	Если НЕ ЗначениеЗаполнено(СвойстваСертификата.АлгоритмПубличногоКлюча) Тогда
		ОбъектЧтениеДанных = Новый ЧтениеДанных(ДвДанные, "windows-1251");
		Попытка
			ТекстСертификата = ОбъектЧтениеДанных.ПрочитатьСимволы();
		Исключение
			ИмяСобытия = ?(КриптографияЭДКОКлиентСервер.ЭтоПодписьСервиса(НастройкиВызова.МестоХраненияКлюча),
				НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата';
					|en = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()),
				НСтр("ru = 'Сервис криптографии.Чтение сертификата';
					|en = 'Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()));
			ЗаписьЖурналаРегистрации(
				ИмяСобытия,
				УровеньЖурналаРегистрации.Ошибка,,,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			Если НастройкиВызова.ВозвращатьИсключения Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
		ОбъектЧтениеДанных.Закрыть();
		
		ТекстСертификата = СокрЛП(ТекстСертификата);
		Если СтрНачинаетсяС(ТекстСертификата, "-----BEGIN CERTIFICATE-----")
			И СтрЗаканчиваетсяНа(ТекстСертификата, "-----END CERTIFICATE-----") Тогда
			ДлинаТекстаСертификата = СтрДлина(ТекстСертификата);
			ТекстСертификата = Сред(ТекстСертификата, 28, ДлинаТекстаСертификата - 52);
			ТекстСертификата = СокрЛП(ТекстСертификата);
		КонецЕсли;
		
		НастройкиВызова.ЭтоСтрокаBase64 		= Истина;
		НастройкиВызова.ВозможенФорматBase64 	= Ложь;
		СвойстваСертификата = ПолучитьСвойстваСертификата(ТекстСертификата, НастройкиВызова);
	КонецЕсли;
	
	Возврат СвойстваСертификата;
	
КонецФункции

Функция ДвДанныеСертификата(ДанныеСертификата, НастройкиВызова) Экспорт
	
	Если НастройкиВызова.ЭтоСтрокаBase64 Тогда
		ДвДанные = Base64Значение(ДанныеСертификата);
	ИначеЕсли ТипЗнч(ДанныеСертификата) = Тип("Строка") И ЭтоАдресВременногоХранилища(ДанныеСертификата) Тогда
		ДвДанные = ПолучитьИзВременногоХранилища(ДанныеСертификата);
	Иначе
		ДвДанные = ДанныеСертификата;
	КонецЕсли;
	
	Возврат ДвДанные;
	
КонецФункции

Функция ШаблонРезультата()
	
	СвойстваСертификата = Новый Структура;
	СвойстваСертификата.Вставить("Размер", 							0);
	СвойстваСертификата.Вставить("Версия", 							0);
	СвойстваСертификата.Вставить("СерийныйНомер", 					0);
	СвойстваСертификата.Вставить("АлгоритмПубличногоКлюча", 		"");
	СвойстваСертификата.Вставить("ИдентификаторКлючаСубъекта", 		Неопределено);
	СвойстваСертификата.Вставить("ИдентификаторКлючаУЦ", 			Неопределено);
	СвойстваСертификата.Вставить("ТипКриптопровайдераВладельца", 	Неопределено);
	СвойстваСертификата.Вставить("ТипИдентификации", 				Неопределено);
	СвойстваСертификата.Вставить("СерийныйНомерСертификатаУЦ", 		Неопределено);
	СвойстваСертификата.Вставить("ПоляПоставщика", 					Новый Массив);
	СвойстваСертификата.Вставить("КлючДействителенС", 				Неопределено);
	СвойстваСертификата.Вставить("КлючДействителенПо", 				Неопределено);
	
	Возврат СвойстваСертификата;
	
КонецФункции

Функция ШаблонНастроек()
	
	НастройкиВызова = Новый Структура;
	НастройкиВызова.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", Истина);
	НастройкиВызова.Вставить("ЭтоСтрокаBase64", 					Ложь);
	НастройкиВызова.Вставить("ВозможенФорматBase64", 				Ложь);
	НастройкиВызова.Вставить("ПрочитатьПоляПоставщика", 			Ложь);
	НастройкиВызова.Вставить("ВозвращатьИсключения", 				Истина);
	
	Возврат НастройкиВызова;
	
КонецФункции

Функция ПолучитьСвойстваИзЗашифрованногоXML(ДвоичныеДанныеСимметричногоКлючаИзXML) Экспорт
	
	Если ДвоичныеДанныеСимметричногоКлючаИзXML.Размер() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("СредняяЧастьСимметричногоКлюча", 	Неопределено);
	Результат.Вставить("ПродолжениеСимметричногоКлюча", 	Неопределено);
	Результат.Вставить("ИдентификаторПараметров", 			"");
	Результат.Вставить("ИдентификаторАлгоритма", 			"");
	Результат.Вставить("ИдентификаторыПубличногоКлюча", 	Неопределено);
	Результат.Вставить("ПубличныйКлюч", 					Неопределено);
	Результат.Вставить("НачалоСимметричногоКлюча", 			Неопределено);
	
	ТипыASN = Типы();
	
	ОбъектЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанныеСимметричногоКлючаИзXML);
	Попытка
		СвойстваКорневогоБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, ДвоичныеДанныеСимметричногоКлючаИзXML.Размер());
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваКорневогоБлока, ОбъектЧтениеДанных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		СвойстваБлокаКлюча = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваКорневогоБлока.РазмерБлока);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлокаКлюча, ОбъектЧтениеДанных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаКлюча.РазмерБлока);
		Если НужноПрерватьЧтениеДляOCTET_STRING(СвойстваБлока, ОбъектЧтениеДанных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		Результат.СредняяЧастьСимметричногоКлюча = ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных, СвойстваБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаКлюча.РазмерБлока);
		Если НужноПрерватьЧтениеДляOCTET_STRING(СвойстваБлока, ОбъектЧтениеДанных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		Результат.ПродолжениеСимметричногоКлюча = ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных, СвойстваБлока);
		
		СвойстваБлокаИдентификаторов = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваКорневогоБлока.РазмерБлока);
		Если НЕ СвойстваБлокаИдентификаторов.ЭтоСоставнойБлок Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат Неопределено;
		КонецЕсли;
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаИдентификаторов.РазмерБлока);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> ТипыASN.OBJECT_IDENTIFIER Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат Неопределено;
		КонецЕсли;
		Результат.ИдентификаторПараметров = ПрочитатьОбъектныйИдентификатор(ОбъектЧтениеДанных, СвойстваБлока);
		
		СвойстваБлокаПараметров = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаИдентификаторов.РазмерБлока);
		Если НЕ СвойстваБлокаПараметров.ЭтоСоставнойБлок Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат Неопределено;
		КонецЕсли;
		СвойстваБлокаОбщегоАлгоритма = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаПараметров.РазмерБлока);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлокаОбщегоАлгоритма, ОбъектЧтениеДанных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаОбщегоАлгоритма.РазмерБлока);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> ТипыASN.OBJECT_IDENTIFIER Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат Неопределено;
		КонецЕсли;
		Результат.ИдентификаторАлгоритма = ПрочитатьОбъектныйИдентификатор(ОбъектЧтениеДанных, СвойстваБлока);
		
		ПотокДанных = Новый ПотокВПамяти();
		ОбъектЗаписьДанных = Новый ЗаписьДанных(ПотокДанных);
		СвойстваБлокаАлгоритмов = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаОбщегоАлгоритма.РазмерБлока,
			ОбъектЗаписьДанных);
		Если НужноПрерватьЧтениеДляSEQUENCE(СвойстваБлокаАлгоритмов, ОбъектЧтениеДанных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных, СвойстваБлокаАлгоритмов, ОбъектЗаписьДанных);
		ОбъектЗаписьДанных.Закрыть();
		Результат.ИдентификаторыПубличногоКлюча = ПотокДанных.ЗакрытьИПолучитьДвоичныеДанные();
		
		СвойстваБлокаПубличногоКлюча = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаПараметров.РазмерБлока);
		Если СвойстваБлокаПубличногоКлюча.Класс <> "UNIVERSAL" ИЛИ СвойстваБлокаПубличногоКлюча.Тег <> ТипыASN.BIT_STRING Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат Неопределено;
		КонецЕсли;
		Буфер = ОбъектЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаПубличногоКлюча.РазмерБлока);
		Если НужноПрерватьЧтениеДляOCTET_STRING(СвойстваБлока, ОбъектЧтениеДанных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		Результат.ПубличныйКлюч = ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных, СвойстваБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваБлокаИдентификаторов.РазмерБлока);
		Если НужноПрерватьЧтениеДляOCTET_STRING(СвойстваБлока, ОбъектЧтениеДанных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		Результат.НачалоСимметричногоКлюча = ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных, СвойстваБлока);
	Исключение
		ИмяСобытия = НСтр("ru = 'Сервис криптографии. Чтение зашифрованного XML';
							|en = 'Сервис криптографии. Чтение зашифрованного XML'", ОбщегоНазначения.КодОсновногоЯзыка());
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);
		Возврат Неопределено;
	КонецПопытки;
	ОбъектЧтениеДанных.Закрыть();
	
	Возврат Результат;
	
КонецФункции

Функция ЭтоСообщениеЗашифрованоОблачнойПодписью(Адрес, СерийныйНомерТекущегоПользователя) Экспорт
	
	Результат = Неопределено;
	
	Если КриптографияЭДКО.ИспользованиеОблачнойПодписиВозможно() Тогда
		
		ДанныеКриптосообщения = ПолучитьИзВременногоХранилища(Адрес);
		Если ДанныеКриптосообщения = Base64Значение("") Тогда 
			Возврат Неопределено;
		КонецЕсли;		
		
		МодульСервисКриптографииDSSASNКлиентСервер = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSSASNКлиентСервер");
		СерийныеНомера = МодульСервисКриптографииDSSASNКлиентСервер.ПолучитьСертификатыШифрования(ДанныеКриптосообщения);
		МассивЗаписей  = Новый Массив;

		Если СерийныеНомера.Количество() > 0 Тогда
			
			МассивНомеров = Новый Массив;
			Для каждого СтрокаМассива Из СерийныеНомера Цикл
				
				// В многопользовательском режиме рег файл шифруется на сертификаты всех подключенных пользователей
				Если Врег(СерийныйНомерТекущегоПользователя) = Врег(СтрокаМассива.СерийныйНомер)
					ИЛИ НЕ ЗначениеЗаполнено(СерийныйНомерТекущегоПользователя) Тогда
					
					МассивНомеров.Добавить(СтрокаМассива.СерийныйНомер);
					
				КонецЕсли;
				
			КонецЦикла;
			
			МодульСервисКриптографииDSSСлужебныйВызовСервера = ОбщегоНазначения.ОбщийМодуль("СервисКриптографииDSSСлужебныйВызовСервера");
			ДанныеСертификатов = МодульСервисКриптографииDSSСлужебныйВызовСервера.ПолучитьСертификатПоСерийномуНомеру(
				Новый Структура("СерийныйНомер", МассивНомеров));
			
			Если ДанныеСертификатов <> Неопределено
				И ДанныеСертификатов.Количество() > 0 Тогда
				
				ТекущийСертификат = ДанныеСертификатов[0];
				Результат = ТекущийСертификат.УчетнаяЗапись;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции

Функция СерийныйНомерСерификата(ДвДанные) Экспорт
	
	СертификатКриптографии = Новый СертификатКриптографии(ДвДанные);
	
	Возврат НРег(ПолучитьHexСтрокуИзДвоичныхДанных(СертификатКриптографии.СерийныйНомер));
	
КонецФункции

#КонецОбласти
