
// Функция проверяет, что две переданные даты находятся между разными элементами 
// упорядоченного массива.
//
// Параметры:
//	Дата1 - Дата - Первая проверяемая дата.
//  Дата2 - Дата - Вторая проверяемая дата.
//	ИнтервалДат - Массив - Упорядоченный массив дат, каждый элемент которого определяет
//							новую границу интервала.
//
// Возвращаемое значение:
//	Булево - Истина, если даты принадлежат разным интервалам.
//
Функция ДатыПринадлежатРазнымИнтервалам(Знач Дата1, Знач Дата2, ИнтервалДат) Экспорт

	Результат = Ложь;

	Индекс1 = -1;
	
	Индекс2 = -1;
	
	Дата1 = НачалоДня(Дата1);
	Дата2 = НачалоДня(Дата2);
	
	ВГраницаИнтервалаДат = ИнтервалДат.ВГраница();
	Для ТекИндекс = 0 По ВГраницаИнтервалаДат Цикл
		ДатаИнтервала = НачалоДня(ИнтервалДат[ТекИндекс]);
	
		Если ДатаИнтервала <= Дата1 Тогда
			Индекс1 = ТекИндекс;
		КонецЕсли;
		
		Если ДатаИнтервала <= Дата2 Тогда
			Индекс2 = ТекИндекс;
		КонецЕсли;
		
	КонецЦикла;

	Если Индекс1 <> Индекс2 Тогда
		Результат = Истина;
	Иначе
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции

#Область УстаревшийПрограммныйИнтерфейс

// Устарела. Следует использовать ОбщегоНазначения.ОписаниеТипаСтрока
// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
//
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  ОписаниеТипов - для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Устарела. Следует использовать ОбщегоНазначения.ОписаниеТипаЧисло.
// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
//
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  ЗнакЧисла				- ДопустимыйЗнак, знак числа.
//
// Возвращаемое значение:
//  ОписаниеТипов - для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Устарела. Следует использовать ОбщегоНазначения.ОписаниеТипаДата.
// Служебная функция, предназначенная для получения описания типов даты.
//
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
//
// Возвращаемое значение:
//	ОписаниеТипов - Описание типов даты.
//
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции // ПолучитьОписаниеТиповДаты()

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.ТекстОшибкиЗаполнения
// Формирует текст сообщения, подставляя значения
// параметров в шаблоны сообщений.
//
// Параметры
//  ВидПоля       - Строка - может принимать значения:
//                  Поле, Колонка, Список.
//  ВидСообщения  - Строка - может принимать значения:
//                  Заполнение, Корректность.
//  Параметр1     - Строка - имя поля.
//  Параметр2     - Строка - номер строки.
//  Параметр3     - Строка - имя списка.
//  Параметр4     - Строка - текст сообщения о некорректности заполнения.
//
// Возвращаемое значение:
//   Строка - Текст сообщения.
//
Функция ПолучитьТекстСообщения(ВидПоля = "Поле", ВидСообщения = "Заполнение",
	Параметр1 = "", Параметр2 = "",	Параметр3 = "", Параметр4 = "") Экспорт

	ТекстСообщения = "";

	Если ВРег(ВидПоля) = "ПОЛЕ" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" не заполнено';
							|en = 'Field %1 is required'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" заполнено некорректно.
                           |
                           |%4';
                           |en = 'The ""%1"" field is populated incorrectly.
                           |
                           |%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "КОЛОНКА" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не заполнена колонка ""%1"" в строке %2 списка ""%3""';
							|en = 'Column ""%1"" in line #%2, list ""%3"" cannot be empty.'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнена колонка ""%1"" в строке %2 списка ""%3"".
                           |
                           |%4';
                           |en = 'Column ""%1"" in line %2 of the ""%3"" list is filled in incorrectly.
                           |
                           |%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "СПИСОК" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не введено ни одной строки в список ""%3""';
							|en = 'The list ""%3"" is blank.'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнен список ""%3"".
                           |
                           |%4';
                           |en = 'The ""%3"" list is filled in incorrectly.
                           |
                           |%4'");
		КонецЕсли;
	КонецЕсли;

	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, Параметр1, Параметр2, Параметр3, Параметр4);

КонецФункции // ПолучитьТекстСообщения()

//++ НЕ УТ

// Устарела. См. ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам().
// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//		ИсхСумма - Число - Распределяемая сумма.
//		МассивКоэф - Массив - Массив коэффициентов распределения.
//		Точность - Число - Точность округления при распределении. Необязателен.
//
//	Возвращаемое значение:
//		МассивСумм - Массив - Массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено.
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт

	Возврат ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(
				ИсхСумма, МассивКоэф, Точность);

КонецФункции // РаспределитьПропорционально()

//-- НЕ УТ

// Дополняет URL параметрами (элемент query rfc 3986)
//
// Параметры:
//  URL          - Строка - URL без элементов query и fragment (без символов ? и #)
//  ПараметрыURL - Массив - имена и значения параметров в виде "key=value".
//                          Они будут включены в URL с разделителями &
// 
// Возвращаемое значение:
//  Строка - дополненный URL
//
Функция ДополнитьURLПараметрами(URL, ПараметрыURL) Экспорт
	
	Если Не ЗначениеЗаполнено(ПараметрыURL) Тогда
		Возврат URL;
	КонецЕсли;
	
	ПараметрыURLСтрокой = СтрСоединить(ПараметрыURL, "&");
	Возврат СтрШаблон("%1?%2", URL, ПараметрыURLСтрокой);
	
КонецФункции

// Параметры UTM (Urchin Tracking Module) для материалов на its.1c.ru
// 
// Возвращаемое значение:
//  Массив из Строка - каждый элемент - имя и значение параметра, разделенные символом "="
//
Функция ИТС_ПараметрыUTM() Экспорт
	
	ПараметрыURL = Новый Массив;
	ПараметрыURL.Добавить("utm_medium=prog");
	ПараметрыURL.Добавить("utm_source=bp30");
	Возврат ПараметрыURL;
	
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Возвращает наименование организации по сокращенному.
//
// Параметры:
//   СокращенноеНаименование - Строка - Сокращенное наименование организации.
//
// Возвращаемое значение: 
//   Наименование - Строка - Наименование организации, полученное из сокращенного.
//
Функция НаименованиеПоСокращенномуНаименованию(СокращенноеНаименование) Экспорт
	
	СтруктураНаименования = РазложитьСтрокуНаименования(СокращенноеНаименование);
	
	Возврат СтруктураНаименования.Наименование
			+ ?(ПустаяСтрока(СтруктураНаименования.ОрганизационноПравоваяФормаСокращенно), "", " ")
			+ СтруктураНаименования.ОрганизационноПравоваяФормаСокращенно;
	
КонецФункции

// Возвращает строковое представление списка, при этом последний элемент отделен союзом, а остальные - пунктуационным разделителем.
// Например: "пурпурную, лиловую, зеленую и лимонную", "правый и левый" или "первая, вторая или четвертая"
//
// Параметры:
//  Список       - Массив, ФиксированныйМассив - представления элементов списка или элементы списка.
//                 При вызове с клиента следует иметь в виду, что представления элементов не всех типов могут быть получены на клиенте
//  Союз         - Строка - нелокализованная строка "И", "ИЛИ" для стандартных союзов; локализованная строка с разделителями слов для остальных
//  Разделитель  - Строка - разделитель элементов списка, кроме последнего
// 
// Возвращаемое значение:
//  Строка - представление списка
//
Функция ПредставлениеСписка(Список, Союз = "И", Разделитель = ",") Экспорт
	
	Если Не ЗначениеЗаполнено(Список) Тогда
		Возврат "";
	КонецЕсли;
	
	Если Список.Количество() = 1 Тогда
		Возврат Список[0];
	КонецЕсли;
	
	Если ВРег(Союз) = "И" Тогда
		ПредставлениеСоюза = НСтр("ru = ' и ';
									|en = ' и '");
	ИначеЕсли ВРег(Союз) = "ИЛИ" Тогда
		ПредставлениеСоюза = НСтр("ru = ' или ';
									|en = ' или '");
	Иначе
		ПредставлениеСоюза = Союз;
	КонецЕсли;
	
	ЭлементыЧерезЗапятую = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(Список);
	ЭлементыЧерезЗапятую.Удалить(ЭлементыЧерезЗапятую.ВГраница());
	
	Если Разделитель = "," Тогда
		ПредставлениеРазделителя = НСтр("ru = ', ';
										|en = ', '");
	Иначе
		ПредставлениеРазделителя = Разделитель;
	КонецЕсли;
	
	ЭлементыЧерезСоюз = Новый Массив;
	ЭлементыЧерезСоюз.Добавить(СтрСоединить(ЭлементыЧерезЗапятую, ПредставлениеРазделителя));
	ЭлементыЧерезСоюз.Добавить(Список[Список.ВГраница()]);
	
	Возврат СтрСоединить(ЭлементыЧерезСоюз, ПредставлениеСоюза);
	
КонецФункции

// Возвращает разницу между двумя датами.
// Аналогично функции языка запросов игнорирует младшие части дат,
// которые меньше, чем параметр Периодичность.
//
// Например:
//	РазностьДат('2019-12-31', '2020-01-01', Перечисления.Периодичность.Год) = 1
//	РазностьДат('2019-08-24', '2020-05-17', Перечисления.Периодичность.Месяц) = 9
//
// Параметры:
//   ДатаНачала - Дата - начальная дата периода
//   ДатаОкончания - Дата - конечная дата периода
//   Периодичность - ПеречислениеСсылка.Периодичность - вариант расчета разности дат.
//
// Возвращаемое значение:
//   Число - количество между двумя датами.
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	Разность = 0;
	
	День = 24 * 60 * 60; // Количество секунд в дне
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год") Тогда
		Разность = Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие") Тогда
		Разность =
			?(Месяц(ДатаОкончания) > 6, 2, 1) - ?(Месяц(ДатаНачала) > 6, 2, 1) + 2 * (Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал") Тогда
		Разность = Цел(Месяц(НачалоКвартала(ДатаОкончания)) / 3) - Цел(Месяц(НачалоКвартала(ДатаНачала)) / 3)
			+ 4 * (Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Месяц") Тогда
		Разность = Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12 * (Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада") Тогда
		Разность = Цел((ДатаОкончания - ДатаНачала) / (10 * День));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		Разность =
			Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала)) / (7 * День));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		Разность = (ДатаОкончания - ДатаНачала) / День;
		
	КонецЕсли;
	
	Возврат Разность;
	
КонецФункции

// Возвращает синоним из имени реквизита объекта. 
//
// Параметры:
//  ИмяРеквизита - Строка - имя реквизита объекта, строки-идентификаторы, разделенные точками 
//                          (например: ОсновноеСредство.ГруппаОС, Номенклатура.Артикул). 
// 
// Возвращаемое значение:
//  Строка - синоним из имени реквизита объекта.
//
Функция СинонимИзИмени(ИмяРеквизита) Экспорт
	
	ДопустимыеАббревиатуры = Новый Массив;
	ДопустимыеАббревиатуры.Добавить("ИНН");
	ДопустимыеАббревиатуры.Добавить("КПП");
	ДопустимыеАббревиатуры.Добавить("НДС");
	ДопустимыеАббревиатуры.Добавить("ОС");
	ДопустимыеАббревиатуры.Добавить("НМА");
	
	СловаСинонима = Новый Массив;
	
	УровниИмени = СтрРазделить(ИмяРеквизита, ".", Истина);
	Для каждого УровеньИмени Из УровниИмени Цикл
		
		ЧастьСинонима = СтрокаСПробеламиИзСтиляТРегБезПробелов(УровеньИмени, ДопустимыеАббревиатуры); 
		
		СловаСинонима.Добавить(КапитализироватьСтроку(ЧастьСинонима));
		
	КонецЦикла;
	
	Возврат СтрСоединить(СловаСинонима, ".");
	
КонецФункции

// Возвращает строку из слов, разделенных пробелами из строки в стиле ТРег без пробелов 
// (когда несколько слов пишутся слитно без пробелов, при этом каждое слово пишется с прописной буквы). 
//
// Параметры:
//  СтрокаВСтилеТРегБезПробелов   - Строка - строка в стиле ТРег без пробелов.
//  МассивАббревиатур             - Массив - массив из строк - аббревиатур, которые не преобразовываются.
//  ДекапитализироватьПервоеСлово - Булево - преобразовать первую букву первого слова строки в нижний 
//                                           регистр, по-умолчанию - Ложь.
// 
// Возвращаемое значение:
//  Строка - строка из слов, разделенных пробелами.
//
Функция СтрокаСПробеламиИзСтиляТРегБезПробелов(СтрокаВСтилеТРегБезПробелов, МассивАббревиатур, ДекапитализироватьПервоеСлово = Ложь)
	
	ПервоеСлово = "";
	ОстатокСлова = СтрокаВСтилеТРегБезПробелов;
	Результат = Новый Массив;
	ДекапитализироватьСлово = ДекапитализироватьПервоеСлово;
	
	Пока ЗначениеЗаполнено(ОстатокСлова) Цикл
		ПервоеСлово = ПолучитьПервоеСловоИзСтрокиВСтилеТРегБезПробелов(ОстатокСлова, МассивАббревиатур, ДекапитализироватьСлово);
		Если СтрДлина(ПервоеСлово) <= СтрДлина(ОстатокСлова) Тогда
			ОстатокСлова = Сред(ОстатокСлова, СтрДлина(ПервоеСлово) + 1);
		Иначе
			ОстатокСлова = "";
		КонецЕсли;
		Результат.Добавить(ПервоеСлово);
		ДекапитализироватьСлово = Истина;
		
	КонецЦикла;
	
	Возврат СтрСоединить(Результат, " ");
	
КонецФункции

// Возвращает количество полных (целых) лет между двумя датами.
//
// Например:
//	КоличествоЦелыхЛет('2019-12-31', '2020-01-01') = 0
//
// Параметры:
//   ДатаНачала - Дата - начальная дата периода
//   ДатаОкончания - Дата - конечная дата периода
//
// Возвращаемое значение:
//	Число - количество полных (целых) лет.
//
Функция КоличествоЦелыхЛет(ДатаНачала, ДатаОкончания) Экспорт

	Если НЕ ЗначениеЗаполнено(ДатаНачала)
		ИЛИ НЕ ЗначениеЗаполнено(ДатаОкончания)
		ИЛИ ДатаОкончания <= ДатаНачала Тогда
		Возврат 0;
	КонецЕсли;
	
	Результат = Год(ДатаОкончания) - Год(ДатаНачала);
	
	Месяц1 = Месяц(ДатаНачала);
	Месяц2 = Месяц(ДатаОкончания);
	
	Если Месяц1 > Месяц2 Тогда
		Результат = Результат - 1;
	ИначеЕсли Месяц1 = Месяц2 
		И День(ДатаНачала) > День(ДатаОкончания) Тогда
		Результат = Результат - 1;
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Возвращает количество полных (целых) месяцев между двумя датами.
//
// Например:
//	КоличествоЦелыхМесяцев('2019-08-24', '2020-05-17') = 8
//
// Параметры:
//   ДатаНачала - Дата - начальная дата периода
//   ДатаОкончания - Дата - конечная дата периода
//
// Возвращаемое значение:
//	Число - количество полных (целых) месяцев.
//
Функция КоличествоЦелыхМесяцев(ДатаНачала, ДатаОкончания) Экспорт

	Если НЕ ЗначениеЗаполнено(ДатаНачала)
		ИЛИ НЕ ЗначениеЗаполнено(ДатаОкончания)
		ИЛИ ДатаОкончания <= ДатаНачала Тогда
		Возврат 0;
	КонецЕсли;

	Результат = (Год(ДатаОкончания) - Год(ДатаНачала)) * 12 + (Месяц(ДатаОкончания) - Месяц(ДатаНачала));

	Если День(ДатаНачала) > День(ДатаОкончания) Тогда
		Результат = Результат - 1;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Возвращает номер квартала, которому принадлежит переданная дата.
//
// Параметры:
//   Дата - Дата - дата, для которой необходимо вычислить номер квартала
//
// Возвращаемое значение:
//   Число - номер квартала
//
Функция НомерКвартала(Дата) Экспорт
	
	Возврат Месяц(КонецКвартала(Дата)) / 3;
	
КонецФункции

//++ НЕ УТ

// Функция убирает из текста сообщения служебную информацию.
//
// Параметры:
//  ТекстСообщения - Строка - Исходный текст сообщения.
//
// Возвращаемое значение:
//   Строка - Текст сообщения без служебной информации.
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = СтрНайти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = СтрНайти(ТекстСообщения, "}:");

	Если ОкончаниеСлужебногоСообщения > 0
		И НачалоСлужебногоСообщения > 0
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда

		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1))
			+ Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));

	КонецЕсли;

	Возврат СокрЛП(ТекстСообщения);

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного.
//
// Параметры:
//	ЗаданныйТип - Тип - Тип, пустое значение которого нужно получить.
//
// Возвращаемое значение:
//	Произвольный - Пустое значение указанного типа.
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт

	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;

	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";

	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';

	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;

	Иначе
		Возврат Новый (ЗаданныйТип);

	КонецЕсли;

КонецФункции // ПустоеЗначениеТипа();

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФУНКЦИОНАЛЬНЫМИ ОПЦИЯМИ

// Процедура устанавливает функциональные опции формы.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - Форма, в которой требуется установить функциональные опции.
//	Организация - СправочникСсылка.Организации - Ссылка на организацию.
//	Период - Дата - Дата установки периодических опций.
//
Процедура УстановитьПараметрОрганизацияФункциональныхОпцийФормы(Форма, Организация, Период = Неопределено) Экспорт

	ПараметрыФО = Новый Структура();
	ПараметрыФО.Вставить("Организация", Организация);
	Если Период <> Неопределено Тогда
		ПараметрыФО.Вставить("Период", НачалоМесяца(Период));
		// Приводим к началу месяца для того, чтобы сократить пространство кэшируемых значений.
		// Параметр "Организация" используется в функциональных опциях, привязанных к регистрам сведений с периодичностью
		// Месяц или реже.
	КонецЕсли;
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(ПараметрыФО);
	
КонецПроцедуры

// Процедура устанавливает функциональные опции формы документа.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - Форма, в которой требуется установить функциональные опции.
//
Процедура УстановитьПараметрыФункциональныхОпцийФормыДокумента(Форма) Экспорт
	
	УстановитьПараметрОрганизацияФункциональныхОпцийФормы(Форма, Форма.Объект.Организация, Форма.Объект.Дата);
	
КонецПроцедуры

// Функция возвращает новую структуру параметров учета.
//
// Возвращаемое значение:
//	Структура - Новая структура параметров учета.
//
Функция СтруктураПараметровУчета() Экспорт

	ПараметрыУчета = Новый Структура(
		"ВестиПартионныйУчет,
		|СкладскойУчет,
		|ИспользоватьОборотнуюНоменклатуру,
		|РазделятьПоСтавкамНДС,
		|ВестиУчетПоСтатьямДДС,
		|ВестиУчетПоРаботникам,
		|УчетЗарплатыИКадровВоВнешнейПрограмме,
		|КадровыйУчет");

	Возврат ПараметрыУчета;

КонецФункции

//-- НЕ УТ

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС ПОЛЯ ВЫБОРА ОРГАНИЗАЦИИ С ОБОСОБЛЕННЫМИ ПОДРАЗДЕЛЕНИЯМИ
//

// Устанавливает значение поля организации.
//
// Параметры:
//	ПолеОрганизация - РеквизитФормы - Реквизит формы, в котором нужно установить значение.
//	Организация - СправочникСсылка.Организации - Организация, для которой нужно установить реквизит.
//	ВключатьОбособленныеПодразделения - Булево - Признак, что нужно включать обособленные подразделения.
//
Процедура УстановитьЗначениеПолеОрганизация(ПолеОрганизация, Организация, ВключатьОбособленныеПодразделения) Экспорт
	
	Ключ = СтрЗаменить(Строка(ВключатьОбособленныеПодразделения) + Организация.УникальныйИдентификатор(), "-", "");
	ПолеОрганизация = Ключ;
	
КонецПроцедуры

// Устанавливает значения выбранных реквизитов при отказе от выбора значения (выборе пустого значения).
//
// Параметры:
//	ПолеОрганизация - РеквизитФормы - Реквизит формы, в котором нужно установить значение.
//	Организация - СправочникСсылка.Организации - Организация, для которой нужно установить реквизит.
//	ВключатьОбособленныеПодразделения - Булево - Признак, что нужно включать обособленные подразделения.
//
Процедура ОбработкаОтменыВыбораОрганизации(ПолеОрганизация, Организация, ВключатьОбособленныеПодразделения) Экспорт
	
	Если ЗначениеЗаполнено(ПолеОрганизация) Тогда 
		Возврат;
	КонецЕсли;
	
	Организация                       = Неопределено;
	ВключатьОбособленныеПодразделения = Ложь;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СТРОКОВЫЕ ФУНКЦИИ

// Капитализирует строку - приводит к принятому в полных предложениях написанию:
// первый символ в верхнем регистре, остальные - без изменения.
// Например:
//  "это тест"      -> "Это тест"
//  "тест Тьюринга" -> "Тест Тьюринга"
//  "/test.txt"     -> "/test.txt"
//
// Параметры:
//  ИсходнаяСтрока - Строка - строка, текст полного предложения.
// 
// Возвращаемое значение:
//  Строка - капитализированная строка.
//
Функция КапитализироватьСтроку(ИсходнаяСтрока) Экспорт
	Возврат ВРег(Лев(ИсходнаяСтрока, 1)) + Сред(ИсходнаяСтрока, 2);
КонецФункции

// Декапитализирует строку - изменяет регистр первого символа с верхнего на нижний.
// первый символ в нижнем регистре, остальные - без изменения.
// Например:
//  "Это тест"      -> "это тест"
//  "тест Тьюринга" -> "тест Тьюринга"
//  "/test.txt"     -> "/test.txt"
//
// Параметры:
//  ИсходнаяСтрока - Строка - строка, текст полного предложения.
// 
// Возвращаемое значение:
//  Строка - декапитализированная строка.
//
Функция ДекапитализироватьСтроку(ИсходнаяСтрока) Экспорт
	Возврат НРег(Лев(ИсходнаяСтрока, 1)) + Сред(ИсходнаяСтрока, 2);
КонецФункции

// Функция возвращает строку, которая содержит только цифры из исходной строки.
//
// Параметры:
//	ИсходнаяСтрока - Строка - Исходная строка.
//
// Возвращаемое значение:
//	Строка - Строка, содержащая только цифры.
//
Функция ОставитьВСтрокеТолькоЦифры(ИсходнаяСтрока) Экспорт
	
	СтрокаРезультат = "";
	
	Для а = 1 По СтрДлина(ИсходнаяСтрока) Цикл
		ТекущийСимвол = Сред(ИсходнаяСтрока, а, 1);
		КодСимвола = КодСимвола(ТекущийСимвол);
		Если КодСимвола >= 48 И КодСимвола <= 57 Тогда
			СтрокаРезультат = СтрокаРезультат + ТекущийСимвол;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрокаРезультат;
	
КонецФункции

// Функция возвращает истину, если в переданной строке содержатся одни нули.
//
// Параметры:
//	Строка - Строка - анализируемая строка.
//
// Возвращаемое значение:
//	Булево - Если, если в переданной строке есть только 0, в противном случае - ложь.
//
Функция ТолькоНулиВСтроке(Строка) Экспорт
	
	ЗначащиеСимволы = СокрЛП(СтрЗаменить(Строка, "0", ""));
	Возврат ПустаяСтрока(ЗначащиеСимволы);
	
КонецФункции

// Извлекает значения из Соответствие или Структура.
//
// Параметры:
//  Коллекция - Соответствие,Структура - коллекция с данными
//  ТолькоУникальные - Булево - Истина, если нужно извлечь только уникальные значения
// 
// Возвращаемое значение:
//  Массив - значения из коллекции. Порядок элементов не определен.
//
Функция ЗначенияКоллекции(Коллекция, ТолькоУникальные = Ложь) Экспорт
	
	Значения = Новый Массив;
	Для Каждого КлючИЗначение Из Коллекция Цикл
		Значения.Добавить(КлючИЗначение.Значение);
	КонецЦикла;
	
	Если Не ТолькоУникальные Тогда
		Возврат Значения;
	Иначе
		Возврат ОбщегоНазначенияКлиентСервер.СвернутьМассив(Значения);
	КонецЕсли;

КонецФункции

#Область РазделенныйМассив

// Средства для работы с коллекциями типа "бакет" - такие часто используются в хеш-таблицах и часто иллюстрируются в материалах, связанных с ним.
// Такие коллекции могут быть удобны и для прикладных задач.
//
// Они представляют собой Соответствие, значением которого является Массив значений.
// Таким образом, значения в рамках определенного ключа упорядочены.
//
// Можно сказать, что Массив разделен на части (собственно "бакеты") по какому-то ключу.

// Добавляет значение в разделенный массив
//
// Параметры:
//  Бакеты - Соответствие - разделенный массив. Инициализируется пустым соответствием
//  Ключ   - Произвольный - ключ разделения (ключ соответствия)
//  Значение - Произвольный - значение массива
//
Процедура ДополнитьРазделенныйМассив(Бакеты, Ключ, Значение) Экспорт
	
	Бакет = Бакеты[Ключ];
	Если Бакет = Неопределено Тогда
		Бакет = Новый Массив;
		Бакеты.Вставить(Ключ, Бакет);
	КонецЕсли;
	
	Бакет.Добавить(Значение);
	
КонецПроцедуры

// Добавляет в разделенный массив значения, хранимые в виде пар КлючИЗначение (например, в Структура или Соответствие)
//
// Параметры:
//  Бакеты - Соответствие - разделенный массив. Инициализируется пустым соответствием
//  Данные - Структура, Соответствие - источник данных для помещения в бакеты
//
Процедура ЗаполнитьРазделенныйМассив(Бакеты, Данные) Экспорт
	
	Для Каждого КлючИЗначение Из Данные Цикл
		ДополнитьРазделенныйМассив(Бакеты, КлючИЗначение.Значение, КлючИЗначение.Ключ);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает структуру, содержащую наименование юридического лица, его организационно-правовую форму 
// полную и сокращенную, а так же признак ВыводитьКавычки
//
// Параметры:
//   Наименование - Строка - исходная строка Наименования
// 
// Возвращаемое значение:
//   Структура - Структура со свойствами:
//      * Наименование - Строка - наименование без организационно-правовой формы.
//      * ОрганизационноПравоваяФорма - Строка - организационно-правовая форма юридического лица.
//      * ОрганизационноПравоваяФормаСокращенно - Строка - сокращенная организационно-правовая форма юридического лица.
//      * ВыводитьКавычки - Булево - признак, что следует выводить ковычки.
//
Функция РазложитьСтрокуНаименования(Знач Наименование) Экспорт
	
	Результат = Новый Структура(
		"Наименование,ОрганизационноПравоваяФорма,ОрганизационноПравоваяФормаСокращенно,ВыводитьКавычки");
	
	Наименование    = СокрЛП(Наименование);
	ВыводитьКавычки = Истина;
	
	Если УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'ООО';
																	|en = 'LLC'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Общество с ограниченной ответственностью';
														|en = 'Limited liability company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ООО';
														|en = 'LLC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'ПАО';
																			|en = 'PJSC'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Публичное акционерное общество';
														|en = 'Public Joint-Stock Company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ПАО';
														|en = 'PJSC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'АО';
																			|en = 'JSC'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Акционерное общество';
														|en = 'Joint-Stock Company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'АО';
														|en = 'JSC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'ОАО';
																			|en = 'JSC'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Открытое акционерное общество';
														|en = 'Open Joint-Stock Company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ОАО';
														|en = 'JSC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'ЗАО';
																			|en = 'CJSC'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Закрытое акционерное общество';
														|en = 'Closed Joint-Stock Company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ЗАО';
														|en = 'CJSC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'ИП';
																			|en = 'Individual entrepreneur'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Индивидуальный предприниматель';
														|en = 'Individual entrepreneur'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ИП';
														|en = 'Individual entrepreneur'");
		ВыводитьКавычки = Ложь;
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'Общество с ограниченной ответственностью';
																			|en = 'Limited liability company'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Общество с ограниченной ответственностью';
														|en = 'Limited liability company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ООО';
														|en = 'LLC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'Публичное акционерное общество';
																			|en = 'Public Joint-Stock Company'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Публичное акционерное общество';
														|en = 'Public Joint-Stock Company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ПАО';
														|en = 'PJSC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'Акционерное общество';
																			|en = 'Joint-Stock Company'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Акционерное общество';
														|en = 'Joint-Stock Company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'АО';
														|en = 'JSC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'Открытое акционерное общество';
																			|en = 'Open Joint-Stock Company'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Открытое акционерное общество';
														|en = 'Open Joint-Stock Company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ОАО';
														|en = 'JSC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'Закрытое акционерное общество';
																			|en = 'Closed Joint-Stock Company'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Закрытое акционерное общество';
														|en = 'Closed Joint-Stock Company'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ЗАО';
														|en = 'CJSC'");
	ИначеЕсли УбратьИзНаименованияОрганизационнуюФорму(Наименование, НСтр("ru = 'Индивидуальный предприниматель';
																			|en = 'Individual entrepreneur'")) Тогда
		ОрганизационноПравоваяФорма             = НСтр("ru = 'Индивидуальный предприниматель';
														|en = 'Individual entrepreneur'");
		ОрганизационноПравоваяФормаСокращенно   = НСтр("ru = 'ИП';
														|en = 'Individual entrepreneur'");
		ВыводитьКавычки = Ложь;
	Иначе
		ОрганизационноПравоваяФорма             = "";
		ОрганизационноПравоваяФормаСокращенно   = "";
	КонецЕсли;
	
	Если Не ПустаяСтрока(ОрганизационноПравоваяФорма) Тогда
		КоличествоКавычек	= СтрЧислоВхождений(Наименование, """");
		Если КоличествоКавычек > 1 Тогда
			// Наименование организации внутри внешних кавычек
			ПозицияПервойКавычки    = СтрНайти(Наименование, """");
			ПозицияПоследнейКавычки = 0;
			
			ВремНаименование    = Наименование;
			
			ПозицияКавычки      = ПозицияПервойКавычки;
			Пока ПозицияКавычки > 0 Цикл
				ПозицияПоследнейКавычки = ПозицияПоследнейКавычки + ПозицияКавычки;
				ВремНаименование        = Сред(ВремНаименование, ПозицияКавычки + 1);
				ПозицияКавычки          = СтрНайти(ВремНаименование, """");
			КонецЦикла;
			
			Наименование = Сред(Наименование, ПозицияПервойКавычки + 1, ПозицияПоследнейКавычки - ПозицияПервойКавычки - 1);
			Если Не КоличествоКавычек % 2 = 0 Тогда
				Наименование = Наименование + """";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Результат.Наименование                          = СокрЛП(Наименование);
	Результат.ОрганизационноПравоваяФорма           = ОрганизационноПравоваяФорма;
	Результат.ОрганизационноПравоваяФормаСокращенно = ОрганизационноПравоваяФормаСокращенно;
	Результат.ВыводитьКавычки                       = ВыводитьКавычки;
	
	Возврат Результат;
	
КонецФункции

Функция УбратьИзНаименованияОрганизационнуюФорму(Наименование, ИмяОрганизационнойФормы)

	Результат = Ложь;
	
	Наименование = СокрЛП(Наименование);
	
	ДлинаНаименования         = СтрДлина(Наименование);
	ДлинаОрганизационнойФормы = СтрДлина(ИмяОрганизационнойФормы);
	
	Если Лев(Наименование, ДлинаОрганизационнойФормы) = ИмяОрганизационнойФормы Тогда
		Наименование = СокрЛ(Сред(Наименование, ДлинаОрганизационнойФормы + 1));
		Результат    = Истина;
	КонецЕсли;
	
	Если Прав(Наименование, ДлинаОрганизационнойФормы) = ИмяОрганизационнойФормы Тогда
		Наименование = СокрП(Лев(Наименование, ДлинаНаименования - ДлинаОрганизационнойФормы - 1));
		Результат    = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПервоеСловоИзСтрокиВСтилеТРегБезПробелов(СтрокаВСтилеТРегБезПробелов, МассивАббревиатур, ДекапитализироватьСтроку)
	
	Если СтрДлина(СтрокаВСтилеТРегБезПробелов) <= 1 Тогда
		Если ДекапитализироватьСтроку Тогда
			Возврат ДекапитализироватьСтроку(СтрокаВСтилеТРегБезПробелов);
		Иначе	
			Возврат СтрокаВСтилеТРегБезПробелов;	
		КонецЕсли;
	КонецЕсли;
	
	ПервыйСимвол = Лев(СтрокаВСтилеТРегБезПробелов,1);
	
	ПродолжениеСтроки = Сред(СтрокаВСтилеТРегБезПробелов, 2);
	ПродолжениеСтрокиНижРег = НРег(ПродолжениеСтроки);
	
	Если ПродолжениеСтроки = ПродолжениеСтрокиНижРег Тогда
		Если ДекапитализироватьСтроку Тогда
			Возврат ДекапитализироватьСтроку(СтрокаВСтилеТРегБезПробелов);
		Иначе	
			Возврат СтрокаВСтилеТРегБезПробелов;	
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПродолжениеСтроки,1) <> НРег(Лев(ПродолжениеСтроки,1)) Тогда
		АббревиатураНайдена = Ложь;
		Для каждого Аббревиатура Из МассивАббревиатур Цикл
			Если СтрНачинаетсяС(СтрокаВСтилеТРегБезПробелов, Аббревиатура) Тогда
				ПервоеСлово = Аббревиатура;
				АббревиатураНайдена = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		//Аббревиатура не декапитализируется
		Если АббревиатураНайдена Тогда
			Возврат ПервоеСлово;
		КонецЕсли;
		
	КонецЕсли;
	
	Для Сч = 1 По СтрДлина(ПродолжениеСтроки) Цикл
		
		Если Сред(ПродолжениеСтроки, Сч, 1) = Сред(ПродолжениеСтрокиНижРег, Сч, 1) Тогда
			Продолжить;	
		КонецЕсли;
		
		ПервоеСлово = Лев(СтрокаВСтилеТРегБезПробелов, Сч);
		Если ДекапитализироватьСтроку Тогда
			ПервоеСлово = ДекапитализироватьСтроку(ПервоеСлово);
		КонецЕсли;
	    Прервать;
		
	КонецЦикла;
	
	Возврат ПервоеСлово;

КонецФункции

#КонецОбласти
