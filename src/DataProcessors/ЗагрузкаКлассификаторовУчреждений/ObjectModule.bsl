#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ОписаниеПеременных

Перем ВременныеФайлы;

// Пространства имен (xmlns)
Перем xmlnsXML;
перем xmlnsV8XDTO;
Перем xmlnsОписанияТиповКлассификаторов;
Перем xmlnsКлассификатор;

Перем ФабрикаXDTOКлассификаторов;
Перем МассивОбщихПакетовXDTO;
Перем xdtoТипыКлассификаторов;

Перем МетаданныеКонфигурации; // = Метаданные
Перем СвойстваОбъектовМетаданных; // = Метаданные.СвойстваОбъектов

#КонецОбласти

#Область ПрограммныйИнтерфейс

Процедура ДобавитьНовыйКлассификатор(ИмяФайла, Хранение, УникальныйИдентификатор) Экспорт
	
	Если ЭтоАдресВременногоХранилища(Хранение) Тогда
		
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(Хранение);
		ДвоичныеДанные.Записать(ИмяВременногоФайла);
		РабФайл = Новый Файл(ИмяВременногоФайла);
		ВременныеФайлы.Добавить(ИмяВременногоФайла);
		
	Иначе
		РабФайл = Новый Файл(ИмяФайла);
	КонецЕсли;
	
    ДобавитьКлассификатор(РабФайл, РабФайл.ПолноеИмя, ,УникальныйИдентификатор);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Функция возвращает объект-описатель типа классификатора.
//
// Параметры:
//  Идентификатор - Строка; идентификатор типа.
//
// Возвращаемое значение:
//  ОбъектXDTO типа {xmlnsОписанияТиповКлассификаторов}ClassifierTypeType.
// Содержит свойства: xmlid – идентификатор (атрибут
// {http://www.w3.org/XML/1998/namespace}id), ИмяСправочника – строка
// (<catalog-name>), ИмяРеквизитаПолнНаименование – строка
// (<full-name-property>). 
//  Неопределено, если тип не найден.
//
Функция xdtoТипКлассификатора(Идентификатор) Экспорт
	Попытка
		МакетТипов ="<?xml version=""1.0"" encoding=""Windows-1251""?>
		|<classifier-type-list xmlns=""urn:uuid:101fa9a0-ea86-11dc-afc4-0002a5d5c51b"">
		|	<classifier-type xml:id=""ОКОФ"">
		|		<catalog-name>ОбщероссийскийКлассификаторОсновныхФондов</catalog-name>
		|		<full-name-property>НаименованиеГруппировки</full-name-property>
		|		<filename-mask>okof.xml</filename-mask>
		|		<filename-mask>okof.aml</filename-mask>
		|		<filename-mask>okof.finf</filename-mask>
		|		<filename-mask>okof.zip</filename-mask>
		|	</classifier-type>
		|	<classifier-type xml:id=""ОКПД"">
		|		<catalog-name>ОбщероссийскийКлассификаторПродукции</catalog-name>
		|		<full-name-property>НаименованиеПолное</full-name-property>
		|		<filename-mask>okpd.xml</filename-mask>
		|		<filename-mask>okpd.aml</filename-mask>
		|		<filename-mask>okpd.finf</filename-mask>
		|		<filename-mask>okpd.zip</filename-mask>
		|	</classifier-type>
		|	<classifier-type xml:id=""ЕКПС"">
		|		<catalog-name>ЕдиныйКодификаторПредметовСнабжения</catalog-name>
		|		<full-name-property>НаименованиеПолное</full-name-property>
		|		<filename-mask>ecs.xml</filename-mask>
		|		<filename-mask>ecs.aml</filename-mask>
		|		<filename-mask>ecs.finf</filename-mask>
		|		<filename-mask>ecs.zip</filename-mask>
		|	</classifier-type>
		|</classifier-type-list>";

		xdtoТипыКлассификаторов = xdtoПрочитать(МакетТипов,
			ФабрикаXDTOКлассификаторов(),
			xmlnsОписанияТиповКлассификаторов, "ClassifierTypeListType");

		Возврат xdtoТипыКлассификаторов.Получить("ТипыКлассификаторов[xmlid='" + Идентификатор + "']");
	Исключение
		Возврат Неопределено
	КонецПопытки;
КонецФункции  

Функция ПолучитьСодержаниеКлассификатора(ЧитатьПринудительно = Ложь) Экспорт
	
	Если ЭтоАдресВременногоХранилища(АдресВХранилище) Тогда
		Данные = ПолучитьИзВременногоХранилища(АдресВХранилище);
	КонецЕсли;
	
	Если Данные = Неопределено Тогда
		Возврат Неопределено // не может такого быть
	КонецЕсли;
	
	Если Данные.Содержание = Неопределено Тогда
		Если Не ЧитатьПринудительно Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ТекущееСостояние = "Чтение содержимого классификатора " + НаименованиеКлассификатора + "…";
		Если ТипЗнч(Данные.СтрокаXMLИлиФайл) = Тип("Строка") Тогда
			ЧтениеXML = Новый ЧтениеXML;
			ЧтениеXML.УстановитьСтроку(Данные.СтрокаXMLИлиФайл)
		Иначе
			ЧтениеXML = Новый(Данные.ТипЧитателя);
			ЧтениеXML.ОткрытьФайл(Данные.СтрокаXMLИлиФайл.ПолноеИмя);
		КонецЕсли; 
		ЧтениеXML.ПерейтиКСодержимому();
		ЧтениеXML.Прочитать(); //classifier
		Пока ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента
		 Или ЧтениеXML.Прочитать() Цикл
			Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
				Если ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор
				   И ЧтениеXML.ЛокальноеИмя = "data" Тогда
					
					Данные.Содержание = xdtoПрочитать(ЧтениеXML,
						Данные.ФабрикаXDTO,
						xmlnsКлассификатор, "ClassifierDataType");
					
				Иначе
					ЧтениеXML.Пропустить();
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		ТекущееСостояние = "";
	КонецЕсли;
	Возврат Данные.Содержание
КонецФункции // ПолучитьСодержаниеКлассификатора() 

Функция ДобавитьКлассификатор(СтрокаXMLИлиФайл, ПервичныйИсточник = "", MIMEТип = "", УникальныйИдентификатор) Экспорт
	
	Перем ТипЧитателя, Идентификатор, Наименование, НормАкт, Строка;
	
	//Классификаторы.Очистить();
	
	Данные = Новый Структура("Содержание,
	|ФабрикаXDTO,
	|СтрокаXMLИлиФайл,
	|ТипЧитателя,
	|ДатаМодификации,
	|КоличествоЭлементов,
	|МаксимальноеЗначениеПрогрессора");
	
	Файл = ПроверитьРазархивироватьФайл(СтрокаXMLИлиФайл, ТипЧитателя,
	ПервичныйИсточник, MIMEТип,УникальныйИдентификатор);
	
	Если Файл = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	Данные.ДатаМодификации = Файл.ПолучитьВремяИзменения();
	Данные.ТипЧитателя = ТипЧитателя;
	
	ЧтениеXML = Новый(ТипЧитателя);
	Попытка
		ЧтениеXML.ОткрытьФайл(Файл.ПолноеИмя)
	Исключение
		#Если Не ВнешнееСоединение Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Файл (%1) поврежден или имеет неверный формат.';
				|en = 'The file (%1) is damaged or has an incorrect format.'"),
			СтрокаXMLИлиФайл.Имя));
		#КонецЕсли
		Возврат Неопределено
	КонецПопытки;
		
	Попытка
		ЧтениеXML.ПерейтиКСодержимому();
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента
		   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор
		   И ЧтениеXML.ЛокальноеИмя = "classifier" Тогда
			
			Идентификатор = ЧтениеXML.ЗначениеАтрибута("classifier-type-id");
			ПозицияМаркераФрагмента = Найти(Идентификатор, "#");
			
			Если ПозицияМаркераФрагмента = 0 Тогда
				Возврат Неопределено;
			КонецЕсли;
			Идентификатор = Сред(Идентификатор, ПозицияМаркераФрагмента + 1);
			
			Если ДопустимыеТипыКлассификаторов.Количество() > 0 И 
				ДопустимыеТипыКлассификаторов.НайтиПоЗначению(Идентификатор) = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			
			// Узнали, что за классификатор – тут же выясняем, нужен ли он нам.
			Тип = xdtoТипКлассификатора(Идентификатор);
			
			// Неизвестного или незапрашиваемого типа.
			Если Тип = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			
			ЗагружатьПолностью  = ЧтениеXML.ЗначениеАтрибута("allow-partial-load") = "false";
			УдалятьНеактуальные = ЧтениеXML.ЗначениеАтрибута("remove-obsolete") = "true";
			НеЧитать = Ложь;
			Пока НеЧитать Или ЧтениеXML.Прочитать() Цикл
				НеЧитать = Ложь;
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					Если ЧтениеXML.ЛокальноеИмя = "additional-packages"
					   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						xdtoДопМодель = xdtoПрочитать(ЧтениеXML,
							ФабрикаXDTO,// - МассивОбщихПакетовXDTO создается глобальной фабрикой, поэтому и тут надо использовать глобальную фабрику 
							xmlnsV8XDTO, "Model");
						Для Каждого xdtoПакет Из МассивОбщихПакетовXDTO Цикл
							xdtoДопМодель.Package.Добавить(xdtoПакет);
						КонецЦикла;
						Данные.ФабрикаXDTO = Новый ФабрикаXDTO(xdtoДопМодель);
						НеЧитать = Истина; // мы уже на начале элемента, вызывать Прочитать() не надо
						
					ИначеЕсли ЧтениеXML.ЛокальноеИмя = "desc"
					        И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						ЧтениеXML.Прочитать();
						Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
							Наименование = ЧтениеXML.Значение;
						КонецЕсли; 
						
					ИначеЕсли ЧтениеXML.ЛокальноеИмя = "data"
					   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						Попытка
							Данные.КоличествоЭлементов = Число(ЧтениеXML.ЗначениеАтрибута("item-count"));
						Исключение
							Данные.КоличествоЭлементов = 0;
						КонецПопытки;
						Попытка
							Данные.МаксимальноеЗначениеПрогрессора = Число(ЧтениеXML.ЗначениеАтрибута("custom-progress-max-value"));
						Исключение
							Данные.МаксимальноеЗначениеПрогрессора = 0;
						КонецПопытки;
						// Если в файле не указано количество элементов, пытаемся определить его сами
						// посредством XPath. Очень долго…
						Если Данные.КоличествоЭлементов = 0 И Данные.МаксимальноеЗначениеПрогрессора = 0 Тогда
							ТекущееСостояние = "Подсчет позиций классификатора…";
							Попытка
								ПостроительDOM = Новый ПостроительDOM;
								ВремЧтениеXML  = Новый(ТипЧитателя);
								ВремЧтениеXML.ОткрытьФайл(Файл.ПолноеИмя);
								ДокументDOM = ПостроительDOM.Прочитать(ВремЧтениеXML);
								Разыменователь = Новый РазыменовательПространствИменDOM("csf", xmlnsКлассификатор);
								Результат = ДокументDOM.ВычислитьВыражениеXPath(
									"count(/csf:classifier/csf:data//csf:*[local-name()='group' or local-name()='item'])",
									ДокументDOM.ЭлементДокумента,
									Разыменователь,
									ТипРезультатаDOMXPath.Число);
								Данные.КоличествоЭлементов = Результат.ЧисловоеЗначение;
								// Освободим память.
								ДокументDOM   = Неопределено;
								ВремЧтениеXML = Неопределено;
							Исключение
							КонецПопытки;
							ТекущееСостояние = "";
						КонецЕсли; 
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка классификатора';
										|en = 'Import classifier'"), УровеньЖурналаРегистрации.Ошибка,,,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат Неопределено
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(Идентификатор) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Данные.ФабрикаXDTO = Неопределено Тогда
		Данные.ФабрикаXDTO = ФабрикаXDTOКлассификаторов()
	КонецЕсли;
	
	ИдентификаторКлассификатора  	= Идентификатор;
	Дата 							= Данные.ДатаМодификации;
	Загружать               		= Истина;
	ПерезаписыватьОбъекты   		= Истина;
	ПерезаписыватьЭтоГруппа 		= Истина;
	Источник                		= СтрокаXMLИлиФайл;
	НаименованиеКлассификатора      = ?(ПустаяСтрока(Наименование),
	                                 	МетаданныеКонфигурации.Справочники.Найти(Тип.ИмяСправочника).Синоним,
	                                 	Наименование);
	
										
	Если НормАкт = Неопределено Тогда
		Редакция = "<не указана>";
	Иначе
		Редакция = "" + НормАкт.Вид + " " + НормАкт.ВыпустившийОрган
			+ ?(ПустаяСтрока(НормАкт.Название), "", " " + НормАкт.Название)
			+ " от " + Формат(НормАкт.ДатаОпубликования, "ДЛФ=D");
	КонецЕсли;
	
	Данные.СтрокаXMLИлиФайл = Файл;
	АдресВХранилище  = ПоместитьВоВременноеХранилище(Данные, УникальныйИдентификатор);
	КоличествоЭлементов = Данные.КоличествоЭлементов;
		
	Возврат Загружать;
	
КонецФункции // ДобавитьКлассификатор()

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция создает объект XDTO из XML.
//
// Параметы:
//  XML          - Строка, ЧтениеXML, ЧтениеFastInfoset, ЧтениеУзловDOM;
//                 источник – строка XML или уже созданный читатель;
//  Фабрика      - ФабрикаXDTO; фабрика, содержащая пакеты типов, которые
//                 будем читать;
//  ТипURI       - Строка; URI пространства имен типа, объект которого мы
//                 собрались читать;
//  ТипИмя       - Строка; локальное имя типа считываемого объекта.
//
// Возвращаемое значение:
//  ОбъектXDTO.
//
Функция xdtoПрочитать(Знач XML, 
					  Знач Фабрика,
                      Знач ТипURI = "",
                      Знач ТипИмя = "")
					  
	Если Не ПустаяСтрока(ТипИмя) Тогда
		Тип = Фабрика.Тип(ТипURI, ТипИмя)
	Иначе
		Тип = Неопределено
	КонецЕсли;
	
	Если ТипЗнч(XML) = Тип("Строка") Тогда
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XML)
	Иначе
		ЧтениеXML = XML;
	КонецЕсли;
	
	Возврат Фабрика.ПрочитатьXML(ЧтениеXML, Тип);
	
КонецФункции // ПрочитатьXDTO() 

// Функция формирует, если нужно, и возвращает фабрику XDTO, содержащую пакеты
// типов пространства имен {xmlnsКлассификатор}. Объект XDTO типа
// {http://v8.1c.ru/8.1/xdto}Model – модель типов – считывается из макета.
//
// Возвращаемое значение:
//  ФабрикаXDTO.
//
Функция ФабрикаXDTOКлассификаторов()
	Если ФабрикаXDTOКлассификаторов = Неопределено Тогда
		Если МассивОбщихПакетовXDTO = Неопределено Тогда
			МассивОбщихПакетовXDTO = Новый Массив;
			xdtoМодельXDTOТипов = xdtoПрочитать(ПолучитьМакет("МодельXDTO").ПолучитьТекст(),
				ФабрикаXDTO,
				xmlnsV8XDTO, "Model");
			Для Каждого xdtoПакет Из xdtoМодельXDTOТипов.Package Цикл
				МассивОбщихПакетовXDTO.Добавить(xdtoПакет);
			КонецЦикла;
		Иначе
			xdtoМодельXDTOТипов = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(xmlnsV8XDTO, "Model"));
			Для Каждого xdtoПакет Из МассивОбщихПакетовXDTO Цикл
				xdtoМодельXDTOТипов.Package.Добавить(xdtoПакет);
			КонецЦикла;
		КонецЕсли;
		ФабрикаXDTOКлассификаторов = Новый ФабрикаXDTO(xdtoМодельXDTOТипов);
	КонецЕсли;
	Возврат ФабрикаXDTOКлассификаторов
КонецФункции // ФабрикаXDTOКлассификаторов()

// Процедура обрабатывает файл и решает, похож ли он на файл классификатора.
//
// Параметры:
//  Файл         - Файл; файл-источник;
//  ТипЧитателя  - Тип; переменная, принимающая тип объекта, который нужно
//                 создать, чтобы прочесть файл (ЧтениеXML или
//                 ЧтениеFastInfoset);
//  ПервичныйИсточник - Строка; первичное имя файла (Файл может быть
//                 временным) или URL для отображения в сообщениях об ошибках;
//  MIMEТип      - Строка; MIME-тип файла (в случае, если принят по протоколу
//                 HTTP), также используется для определения типа файла.
Функция ПроверитьРазархивироватьФайл(Файл, ТипЧитателя, ПервичныйИсточник, MIMEТип = "",УникальныйИдентификатор)
	
	Если НРег(Файл.Расширение) = ".aml" Тогда
		
		ИмяРаспакованногоФайла = ПолучитьИмяВременногоФайла("xml");
		ТекущееСостояние = "Распаковка файла " + Файл.Имя + "…";
		РаспаковкаФайла        = Новый ЧтениеТекста(Файл.Имя, КодировкаТекста.UTF8);
		Попытка
			Хранилище              = XMLЗначение(Тип("ХранилищеЗначения"), РаспаковкаФайла.Прочитать());
			ДвоичныеДанные         = Хранилище.Получить();
			ДвоичныеДанные.Записать(ИмяРаспакованногоФайла);
		Исключение
			#Если Не ВнешнееСоединение Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Файл (%1) не удалось распаковать: файл поврежден, имеет неверный формат, или не достаточно места на диске.';
				|en = 'Cannot unpack the file (%1). The file is damaged, has an incorrect format, or there is not enough space on the hard drive.'"),
			Файл.Имя));
			#КонецЕсли
			Возврат Неопределено
		КонецПопытки;
		ВременныеФайлы.Добавить(ИмяРаспакованногоФайла);
		Результат = Новый Файл(ИмяРаспакованногоФайла);
		Результат.УстановитьВремяИзменения(Файл.ПолучитьВремяИзменения());
		ТипЧитателя = Тип("ЧтениеXML");
		
	ИначеЕсли НРег(Файл.Расширение) = ".zip"
	      Или MIMEТип = "application/zip"
	      Или MIMEТип = "multipart/x-zip" Тогда
		
		ТекущееСостояние = "Распаковка файла " + Файл.Имя + "…";
		Zip = Новый ЧтениеZipФайла;
		Zip.Открыть(Файл.ПолноеИмя);
		Для Каждого Элемент Из Zip.Элементы Цикл
			Если Найти(".aml.xml.fin.finf.zip", НРег(Элемент.Расширение)) = 0
			 Или Элемент.Зашифрован Тогда
				Продолжить;
			КонецЕсли;
			ТемпКаталог = ПолучитьИмяВременногоФайла();
			Попытка
				Zip.Извлечь(Элемент, ТемпКаталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
			Исключение
				#Если Не ВнешнееСоединение Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Файл (%1) не удалось извлечь из (%2): архив поврежден, имеет неверный формат, или не достаточно места на диске.';
					|en = 'Cannot extract the file (%1) from (%2). The archive is damaged, has an incorrect format, or there is not enough space on the hard drive.'"),
				Элемент.Имя,Файл.Имя));
				#КонецЕсли
				Продолжить
			КонецПопытки;
			НовоеИмя = ТемпКаталог + "\" + Элемент.Имя;
			ВременныеФайлы.Добавить(НовоеИмя);
			ВременныеФайлы.Добавить(ТемпКаталог);
			НовыйФайл = Новый Файл(НовоеИмя);
			ДобавитьКлассификатор(НовыйФайл, ПервичныйИсточник, "",УникальныйИдентификатор);
		КонецЦикла;
		Результат = Неопределено;
		
	ИначеЕсли НРег(Файл.Расширение) = ".finf"
	      Или НРег(Файл.Расширение) = ".fin"
	      Или MIMEТип = "application/fastinfoset" Тогда
		
		Результат = Файл;
		ТипЧитателя = Тип("ЧтениеFastInfoset");
		
	ИначеЕсли НРег(Файл.Расширение) = ".xml"
	      Или MIMEТип = "text/xml"
	      Или MIMEТип = "text/plain"
	      Или MIMEТип = "application/xml"
	      Или MIMEТип = "" Тогда
		
		Результат = Файл;
		ТипЧитателя = Тип("ЧтениеXML");
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Файл (%1) не является файлом классификатора.';
				|en = 'The file (%1) is not a classifier file.'"),
			Файл.Имя);
		Результат = Неопределено;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПроверитьРазархивироватьФайл()

#КонецОбласти

#Область ОператорыОсновнойПрограммы

xmlnsXML                			= "http://www.w3.org/XML/1998/namespace";
xmlnsV8XDTO             			= "http://v8.1c.ru/8.1/xdto";
xmlnsОписанияТиповКлассификаторов 	= "urn:uuid:101fa9a0-ea86-11dc-afc4-0002a5d5c51b";
xmlnsКлассификатор      			= "urn:uuid:be515360-d4a7-11dc-8abf-0002a5d5c51b";

ДопДанные = Новый Соответствие;

// Запоминаем временные файлы, чтобы стереть по окончании работы.
ВременныеФайлы = Новый Массив;

МетаданныеКонфигурации = Метаданные;

СвойстваОбъектовМетаданных = МетаданныеКонфигурации.СвойстваОбъектов;

#КонецОбласти

#КонецЕсли